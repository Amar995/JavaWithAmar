{"id":4807,"date":"2015-06-24T07:01:49","date_gmt":"2015-06-24T07:01:49","guid":{"rendered":"http:\/\/howtodoinjava.com\/?page_id=4807"},"modified":"2020-10-22T12:07:51","modified_gmt":"2020-10-22T06:37:51","slug":"gang-of-four-java-design-patterns","status":"publish","type":"page","link":"https:\/\/howtodoinjava.com\/gang-of-four-java-design-patterns\/","title":{"rendered":"Design Patterns"},"content":{"rendered":"<p><strong>Design patterns<\/strong>, as name suggest, are solutions for most commonly (and frequently) occurred problems while designing a software. These patterns are mostly &#8220;evolved&#8221; rather than &#8220;discovered&#8221;. A lot of learning, by lots of professional, have been summarized into these design patterns. None of these patterns force you anything in regard to implementation; they are just guidelines to solve a particular problem &#8211; in a particular way &#8211; in particular contexts. Code implementation is your responsibility.<\/p>\n<p>Being so much of importance, let&#8217;s learn these design patterns (in context of java) in more detail.<\/p>\n<h2>1. Creational Design Patterns<\/h2>\n<p>Creational patterns often used in place of direct instantiation with constructors. They make the creation process more adaptable and dynamic. In particular, they can provide a great deal of flexibility about which objects are created, how those objects are created, and how they are initialized. <\/p>\n<table class=\"mtr-table mtr-tr-th\">\n<tr>\n<th width=\"30%\" data-mtr-content=\"Design Pattern Name\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Design Pattern Name<\/div><\/th>\n<th width=\"70%\" data-mtr-content=\"Purpose\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Purpose<\/div><\/th>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/creational\/builder-pattern-in-java\/\" target=\"_blank\" rel=\"noopener noreferrer\">Builder<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Builder design pattern is an alternative way to construct complex objects and should be used only when we want to build different types of immutable objects using same object building process.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/creational\/prototype-design-pattern-in-java\/\" target=\"_blank\" rel=\"noopener noreferrer\">Prototype<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Prototype design pattern is used in scenarios where application needs to create a large number of instances of a class, which have almost same state or differ very little.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/creational\/implementing-factory-design-pattern-in-java\/\" target=\"_blank\" rel=\"noopener noreferrer\">Factory<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Factory design pattern is most suitable when complex object creation steps are involved. To ensure that these steps are centralized and not exposed to composing classes.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/creational\/abstract-factory-pattern-in-java\/\" target=\"_blank\" rel=\"noopener noreferrer\">Abstract factory<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Abstract factory pattern is used whenever we need another level of abstraction over a group of factories created using factory pattern.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/creational\/singleton-design-pattern-in-java\/\" target=\"_blank\" rel=\"noopener noreferrer\">Singleton<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Singleton enables an application to have one and only one instance of a class per JVM.<\/div><\/td>\n<\/tr>\n<\/table>\n<h2>2. Structural Design Patterns<\/h2>\n<p>Structural design patterns show us how to glue different pieces of a system together in a flexible and extensible fashion. These patterns help us guarantee that when one of the parts changes, the entire application structure does not need to change. <\/p>\n<table class=\"mtr-table mtr-tr-th\">\n<tr>\n<th width=\"30%\" data-mtr-content=\"Design Pattern Name\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Design Pattern Name<\/div><\/th>\n<th width=\"70%\" data-mtr-content=\"Purpose\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Purpose<\/div><\/th>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/structural\/adapter-design-pattern-in-java\/\" target=\"_blank\" rel=\"noopener noreferrer\">Adapter<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">An adapter convert the interface of a class into another interface clients expect. It lets classes work together that couldn\u2019t otherwise because of incompatible interfaces.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/structural\/bridge-design-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Bridge<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Bridge design pattern is used to decouple a class into two parts \u2013 <em>abstraction<\/em> and it\u2019s <em>implementation<\/em> \u2013 so that both can evolve in future without affecting each other. It increases the loose coupling between class abstraction and it\u2019s implementation.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/structural\/composite-design-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Composite<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Composite design pattern helps to compose the objects into tree structures to represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/structural\/decorator-design-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Decorator<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Decorator design pattern is used to add additional features or behaviors to a particular instance of a class, while not modifying the other instances of same class.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/structural\/facade-design-pattern\/\" rel=\"noopener noreferrer\" target=\"_blank\">Facade<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Facade design pattern provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/structural\/flyweight-design-pattern\/\" rel=\"noopener noreferrer\" target=\"_blank\">Flyweight<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Flyweight design pattern enables use sharing of objects to support large numbers of fine-grained objects efficiently. A flyweight is a shared object that can be used in multiple contexts simultaneously. The flyweight acts as an independent object in each context.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/structural\/proxy-design-pattern\/\" rel=\"noopener noreferrer\" target=\"_blank\">Proxy<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">In proxy design pattern, a proxy object provide a surrogate or placeholder for another object to control access to it. Proxy is heavily used to implement lazy loading related usecases where we do not want to create full object until it is actually needed.<\/div><\/td>\n<\/tr>\n<\/table>\n<h2>3. Behavioral Design Patterns<\/h2>\n<p>Behavioral patterns abstract an action we want to take on the object or class that takes the action. By changing the object or class, we can change the algorithm used, the objects affected, or the behavior, while still retaining the same basic interface for client classes. <\/p>\n<table class=\"mtr-table mtr-tr-th\">\n<tr>\n<th width=\"30%\" data-mtr-content=\"Design Pattern Name\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Design Pattern Name<\/div><\/th>\n<th width=\"70%\" data-mtr-content=\"Purpose\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Purpose<\/div><\/th>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/chain-of-responsibility-design-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Chain of responsibility<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Chain of responsibility design pattern gives more than one object an opportunity to handle a request by linking receiving objects together in form of a chain.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/command-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Command<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Command design pattern is useful to abstract the business logic into discrete actions which we call commands. These command objects help in loose coupling between two classes where one class (invoker) shall call a method on other class (receiver) to perform a business operation.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Interpreter<\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Interpreter pattern specifies how to evaluate sentences in a language, programatically. It helps in building a grammar for a simple language, so that sentences in the language can be interpreted.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/iterator-design-pattern\/\" rel=\"noopener noreferrer\" target=\"_blank\">Iterator<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. <\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/mediator-pattern\/\">Mediator<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Mediator pattern defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets us vary their interaction independently.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/memento-design-pattern\/\" rel=\"noopener noreferrer\" target=\"_blank\">Memento<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Memento pattern is used to restore state of an object to a previous state. It is also known as snapshot pattern.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/observer-design-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Observer<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. It is also referred to as the publish-subscribe pattern.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/state-design-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">State<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">In state pattern allows an object to alter its behavior when its internal state changes. The object will appear to change its class. There shall be a separate concrete class per possible state of an object.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/strategy-design-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Strategy<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Strategy pattern is used where we choose a specific implementation of algorithm or task in run time \u2013 out of multiple other implementations for same task.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/template-method-pattern\/\" target=\"_blank\" rel=\"noopener noreferrer\">Template method<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Template method pattern defines the sequential steps to execute a multi-step algorithm and optionally can provide a default implementation as well (based on requirements).<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Design Pattern Name\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\"><a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/visitor-design-pattern-example-tutorial\/\" target=\"_blank\" rel=\"noopener noreferrer\">Visitor<\/a><\/div><\/td>\n<td data-mtr-content=\"Purpose\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Visitor pattern is used when we want a hierarchy of objects to modify their behavior but without modifying their source code.<\/div><\/td>\n<\/tr>\n<\/table>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Design patterns, as name suggest, are solutions for most commonly (and frequently) occurred problems while designing a software. These patterns are mostly &#8220;evolved&#8221; rather than &#8220;discovered&#8221;. A lot of learning, by lots of professional, have been summarized into these design patterns. None of these patterns force you anything in regard to implementation; they are just &#8230; <a title=\"Design Patterns\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/gang-of-four-java-design-patterns\/\" aria-label=\"More on Design Patterns\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":4808,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":[],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns.png",300,300,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns-150x150.png",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns.png",300,300,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns.png",300,300,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns.png",300,300,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns.png",300,300,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns.png",300,300,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-design-patterns.png",120,120,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":5,"uagb_excerpt":"Design patterns, as name suggest, are solutions for most commonly (and frequently) occurred problems while designing a software. These patterns are mostly &#8220;evolved&#8221; rather than &#8220;discovered&#8221;. A lot of learning, by lots of professional, have been summarized into these design patterns. None of these patterns force you anything in regard to implementation; they are just&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/pages\/4807"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=4807"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/pages\/4807\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/4808"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=4807"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}