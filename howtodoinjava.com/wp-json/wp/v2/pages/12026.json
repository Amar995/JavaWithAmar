{"id":12026,"date":"2018-11-03T22:30:40","date_gmt":"2018-11-03T17:00:40","guid":{"rendered":"https:\/\/howtodoinjava.com\/?page_id=12026"},"modified":"2020-12-26T00:37:14","modified_gmt":"2020-12-25T19:07:14","slug":"java-collections","status":"publish","type":"page","link":"https:\/\/howtodoinjava.com\/java-collections\/","title":{"rendered":"Collections in Java"},"content":{"rendered":"<p>A collection, as name implies, is group of objects. <strong>Java Collections framework<\/strong> is consist of the interfaces and classes which helps in working with different types of collections such as <strong>lists, sets, maps, stacks and queues<\/strong> etc.<\/p>\n<p>These ready-to-use collection classes solve lots of very common problems where we need to deal with group of homogeneous as well as heterogeneous objects. The common operations in involve <strong>add, remove, update, sort, search<\/strong> and more complex algorithms. These collection classes provide very transparent support for all such operations using <strong>Collections APIs<\/strong>.<\/p>\n<h2>1. Java Collections Hierarchy<\/h2>\n<p>The Collections framework is better understood with the help of <strong>core interfaces<\/strong>. The collections classes implement these interfaces and provide concrete functionalities.<\/p>\n<figure id=\"attachment_12027\" aria-describedby=\"caption-attachment-12027\" style=\"width: 392px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif\" alt=\"Java Collections Hierarchy\" width=\"402\" height=\"146\" class=\"size-full wp-image-12027\" \/><figcaption id=\"caption-attachment-12027\" class=\"wp-caption-text\">Java Collections Hierarchy<\/figcaption><\/figure>\n<h4>1.1. Collection<\/h4>\n<p><strong>Collection interface<\/strong> is at the root of the hierarchy. Collection interface provides all general purpose methods which all collections classes must support (or throw <code>UnsupportedOperationException<\/code>). It <strong>extends Iterable<\/strong> interface which adds support for iterating over collection elements using the &#8220;<a href=\"https:\/\/howtodoinjava.com\/java\/flow-control\/enhanced-for-each-loop-in-java\/\"><strong>for-each loop<\/strong><\/a>&#8221; statement.<\/p>\n<p>All other collection interfaces and classes (except Map) either extend or implement this interface. For example, List <em>(indexed, ordered)<\/em> and Set <em>(sorted)<\/em> interfaces implement this collection.<\/p>\n<h4>1.2. List<\/h4>\n<p><strong>Lists<\/strong> represents an <strong>ordered<\/strong> collection of elements. Using lists, we can access elements by their integer index (position in the list), and search for elements in the list. index start with <code>0<\/code>, just like an array.<\/p>\n<p>Some useful classes which implement <code>List<\/code> interface are &#8211; <strong>ArrayList<\/strong>, <strong>CopyOnWriteArrayList<\/strong>, <strong>LinkedList<\/strong>, <strong>Stack<\/strong> and <strong>Vector<\/strong>.<\/p>\n<h4>1.3. Set<\/h4>\n<p><strong>Sets<\/strong> represents a collection of <strong>sorted<\/strong> elements. Sets do not allow the duplicate elements. Set interface does not provides no guarantee to return the elements in any predictable order; though some Set implementations store elements in their <a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-comparable-interface\/\">natural ordering<\/a> and guarantee this order.<\/p>\n<p>Some useful classes which implement <code>Set<\/code> interface are &#8211; <strong>ConcurrentSkipListSet<\/strong>, <strong>CopyOnWriteArraySet<\/strong>, <strong>EnumSet<\/strong>, <strong>HashSet<\/strong>, <strong>LinkedHashSet<\/strong> and <strong>TreeSet<\/strong>.<\/p>\n<h4>1.4. Map<\/h4>\n<p>The <strong>Map<\/strong> interface enable us to store data in <em>key-value pairs<\/em> (keys should be immutable). A map cannot contain duplicate keys; each key can map to at most one value.<\/p>\n<p>The Map interface provides three collection views, which allow a map&#8217;s contents to be viewed as a set of keys, collection of values, or set of key-value mappings. Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not.<\/p>\n<p>Some useful classes which implement <code>Map<\/code> interface are &#8211;  <strong>ConcurrentHashMap<\/strong>, <strong>ConcurrentSkipListMap<\/strong>, <strong>EnumMap<\/strong>, <strong>HashMap<\/strong>, <strong>Hashtable<\/strong>, <strong>IdentityHashMap<\/strong>, <strong>LinkedHashMap<\/strong>, <strong>Properties<\/strong>, <strong>TreeMap<\/strong> and <strong>WeakHashMap<\/strong>.<\/p>\n<h4>1.5. Stack<\/h4>\n<p>The Java <strong>Stack<\/strong> interface represents a classical stack data structure, where elements can be pushed to last-in-first-out (LIFO) stack of objects. In Stack we push an element to the top of the stack, and popped off from the top of the stack again later.\t<\/p>\n<h4>1.6. Queue<\/h4>\n<p>A queue data structure is intended to hold the elements (put by producer threads) prior to processing by consumer thread(s). Besides basic Collection operations, queues provide additional insertion, extraction, and inspection operations.<\/p>\n<p>Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. One such exception is priority queue which order elements according to a supplied <a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-comparator\/\">Comparator<\/a>, or the elements&#8217; natural ordering.<\/p>\n<p>In general, queues do not support blocking insertion or retrieval operations. Blocking queue implementations classes implement <strong>BlockingQueue<\/strong> interface.<\/p>\n<p>Some useful classes which implement <code>Map<\/code> interface are &#8211; ArrayBlockingQueue, ArrayDeque, ConcurrentLinkedDeque, ConcurrentLinkedQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedList, LinkedTransferQueue, PriorityBlockingQueue, PriorityQueue and SynchronousQueue.<\/p>\n<h4>1.7. Deque<\/h4>\n<p>A double ended queue (pronounced &#8220;<strong><em>deck<\/em><\/strong>&#8220;) that supports element insertion and removal at both ends. When a deque is used as a queue, <a href=\"https:\/\/en.wikipedia.org\/wiki\/FIFO_(computing_and_electronics)\" rel=\"noopener noreferrer\" target=\"_blank\">FIFO (First-In-First-Out)<\/a> behavior results. When a deque is used as a stack, LIFO (Last-In-First-Out) behavior results.<\/p>\n<p>This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque.<\/p>\n<p>Some common known classes implementing this interface are ArrayDeque, ConcurrentLinkedDeque, LinkedBlockingDeque and LinkedList.<\/p>\n<h2>2. Java Collections and Generics<\/h2>\n<p>By purpose, <a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/\" rel=\"noopener noreferrer\" target=\"_blank\">generics<\/a> provide type safety. It detects the incompatible types (in method arguments) and prevent <strong>ClassCastException<\/strong> in runtime. In Java collections as well, we can define a collection class to store only a certain type of objects. All other types should be disallowed. This is done via generics.<\/p>\n<p>In given example, first two add() methods are allowed. Third one will not compile and will give error &#8211; &#8220;The method put(Integer, String) in the type <code>HashMap&lt;Integer,String&gt;<\/code> is not applicable for the arguments (String, String)&#8221;. It helps in detecting incompatible types early to prevent unpredictable behavior in runtime.<\/p>\n<pre class=\"brush: java; title: Generic HashMap; notranslate\" title=\"Generic HashMap\">\r\nHashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\r\n        \r\nmap.put(1, &quot;A&quot;);\t\/\/allowed\r\nmap.put(2, &quot;B&quot;);\t\/\/allowed\r\n\r\nmap.put(&quot;3&quot;, &quot;C&quot;);\t\/\/NOT allowed - Key is string\r\n<\/pre>\n<h2>3. equals() and hashCode() Methods<\/h2>\n<p>Many collection classes provide specific functionalities such as sorted elements, no duplicate elements etc. To implement this behavior, the added elements (objects) must implement the <a href=\"https:\/\/howtodoinjava.com\/java\/basics\/java-hashcode-equals-methods\/\">equals() and hashCode() methods<\/a> correctly.<\/p>\n<p>All Java wrapper classes and String class override these functions with their specific implementation so they behave correctly in such collections. we need to make sure that these functions are overridden correctly in our user defined custom classes as well.<\/p>\n<pre class=\"brush: java; title: SortedSet HashMap; notranslate\" title=\"SortedSet HashMap\">\r\nSortedSet&lt;Integer&gt; sortedSet = new TreeSet&lt;&gt;();\r\n\r\nsortedSet.add(2);\r\n\r\nsortedSet.add(1);\r\nsortedSet.add(1);\r\n\r\nsortedSet.add(3);\r\n\r\nSystem.out.println(sortedSet); \t\/\/[1,2,3]\r\n<\/pre>\n<h2>4. Java 8 Collections<\/h2>\n<p><a href=\"https:\/\/howtodoinjava.com\/java-8-tutorial\/\">Java 8<\/a> was a major release which introduced <a href=\"https:\/\/howtodoinjava.com\/java8\/lambda-expressions\/\">lambda style of programming<\/a> in Java. Collections classes was also improved as a result. For example, we can iterate over collections in single line and perform an action on all elements of collection using <strong>forEach<\/strong> statement.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\r\n        \r\nlist.add(1);\r\nlist.add(2);\r\nlist.add(3);\r\n\r\nlist.forEach(System.out::print);\r\n<\/pre>\n<h2>5. Benefits of Java Collections<\/h2>\n<ul>\n<li><strong>Consistent and reusable APIs<\/strong> &#8211; This is any framework does. It provides a consistent set of classes methods which can be used to solve a similar set of problems over and over, without getting unpredictable results. Java collections framework also helps in solving common problems related to a group of objects &#8211; in consistent manner.\n<p>All collection classes have consistent implementation and provide some common methods like add, get, put, remove etc. No matter what kind of data structure you are dealing with, these methods work according to underlying implementation and perform actions transparently.<\/li>\n<li><strong>Less development time<\/strong> &#8211; A common and predictable framework always decreases the development time and helps in writing application program in speedy manner. Java collection also helps in performing some most repeated common tasks with objects and collections and thus improve time factor.<\/li>\n<li><strong>Performance<\/strong> &#8211; The Java collection APIs are written by some most brilliant minds of industry and their performance is top notch in most of the scenarios. Ongoing development work by Oracle and very enthusiastic Java developer community helps in making it better.<\/li>\n<li><strong>Clean code<\/strong> &#8211; These APIs have been written with all good <a href=\"https:\/\/howtodoinjava.com\/java-best-practices\/\">coding practices<\/a> and documented very well. They follow a certain standard across whole Java collection framework. It makes the programmer code look good and clean.\n<p>The code is easier to read as well because of consistent class and method names.<\/li>\n<\/ul>\n<h2>6. Java collection examples<\/h2>\n<ul>\n<li><a href=\"https:\/\/howtodoinjava.com\/series\/java-arrays\/\">Array<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java-arraylist\/\">ArrayList<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-linkedlist-class\/\">LinkedList<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java-hashmap\/\">HashMap<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/hashtable-class\/\">Hashtable<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/linkedhashmap\/\">LinkedHashMap<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/treemap-class\/\">TreeMap<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-hashset\/\">HashSet<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-linkedhashset\/\">LinkedHashSet<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-treeset-class\/\">TreeSet<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-comparable-interface\/\">Comparable<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-comparator\/\">Comparator<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-iterator\/\">Iterator<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-listiterator\/\">ListIterator<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-spliterator\/\">Spliterator<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-priorityqueue\/\">PriorityQueue<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-priorityblockingqueue\/\">PriorityBlockingQueue<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-arrayblockingqueue\/\">ArrayBlockingQueue<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/transferqueue-linkedtransferqueue\/\">LinkedTransferQueue<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-copyonwritearraylist\/\">CopyOnWriteArrayList<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/collections\/java-copyonwritearrayset\/\">CopyOnWriteArraySet<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/java\/sort\/java-sorting\/\">Collection Sorting<\/a><\/li>\n<li><a href=\"https:\/\/howtodoinjava.com\/interview-questions\/useful-java-collection-interview-questions\/\">Interview Questions<\/a><\/li>\n<\/ul>\n<p>Read More:<\/p>\n<p><a href=\"https:\/\/en.wikipedia.org\/wiki\/Java_collections_framework\">Wikepedia Link<\/a><br \/>\n<a href=\"https:\/\/docs.oracle.com\/javase\/tutorial\/collections\/index.html\">Java Docs<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>A collection, as name implies, is group of objects. Java Collections framework is consist of the interfaces and classes which helps in working with different types of collections such as lists, sets, maps, stacks and queues etc. These ready-to-use collection classes solve lots of very common problems where we need to deal with group of &#8230; <a title=\"Collections in Java\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java-collections\/\" aria-label=\"More on Collections in Java\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":12027,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":[],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",402,146,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",150,54,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",300,109,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",402,146,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",402,146,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",402,146,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",402,146,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/11\/Java-collections-interfaces.gif",120,44,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"A collection, as name implies, is group of objects. Java Collections framework is consist of the interfaces and classes which helps in working with different types of collections such as lists, sets, maps, stacks and queues etc. These ready-to-use collection classes solve lots of very common problems where we need to deal with group of&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/pages\/12026"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=12026"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/pages\/12026\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/12027"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=12026"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}