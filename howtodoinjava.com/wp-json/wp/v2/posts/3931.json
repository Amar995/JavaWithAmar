{"id":3931,"date":"2014-05-28T11:15:00","date_gmt":"2014-05-28T11:15:00","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=3931"},"modified":"2020-12-26T00:39:28","modified_gmt":"2020-12-25T19:09:28","slug":"java-7-changes-features-and-enhancements","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java7\/java-7-changes-features-and-enhancements\/","title":{"rendered":"Java 7 Changes, Features and Enhancements"},"content":{"rendered":"<p>I have already covered many <strong>java 7 changes<\/strong> which were new in the release. In this post, I am creating a summary of them so that if anyone interested can take a quick look into all features in short time.<\/p>\n<pre><strong>Features covered in this post<\/strong>\r\n\r\n<a href=\"#diamond_operator\">Improved type Inference Or Diamond Operator<\/a>\r\n<a href=\"#automatic_resource_mgmt\">Automatic resource management with try-with-resources<\/a>\r\n<a href=\"#nio2\">NIO 2.0<\/a>\r\n<a href=\"#exception_improvements\">Exception handling improvements<\/a>\r\n    <a href=\"#suppressed_exceptions\">Suppressed exceptions<\/a>\r\n    <a href=\"#catch_multiple_exceptions\">Catch Multiple Exceptions in catch block<\/a>\r\n<a href=\"#number_formatting\">Number formatting enhancement<\/a>\r\n<a href=\"#string_in_switch\">String class support in switch statement<\/a>\r\n<a href=\"#binary_literal\">Binary Literals with prefix \"0b\"<\/a>\r\n<a href=\"#fork-join\">ForkJoin Framework<\/a>\r\n<a href=\"#watchservice\">Automatic reloading with WatchService<\/a>\r\n<a href=\"#g1_garbage_collector\">G1 Garbage Collector<\/a><\/pre>\n<p><a name=\"diamond_operator\"><\/a><\/p>\n<h2><a title=\"Diamond Operator: Improved type inference in java 7\" href=\"https:\/\/howtodoinjava.com\/java7\/improved-type-inference-in-java-7\/\" target=\"_blank\" rel=\"noopener noreferrer\">Improved type Inference<\/a><\/h2>\n<p>Before java 7, while using generics you had to supply type parameters to variables types and to their actual types. Now, it has been relieved a bit in this new java 7 feature, and a blank diamond on right side of declaration will work fine.<\/p>\n<p>Compiler is smart enough in java 7 to identify that blank diamond infer to type defined on left hand side of declaration.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">public class ElvisOperatorTest {\r\n    public static void main(String[] args) {\r\n        @SuppressWarnings(&quot;unused&quot;)\r\n        Map params = new HashMap&amp;lt;&amp;gt;();\r\n    }\r\n}<\/pre>\n<p><a name=\"automatic_resource_mgmt\"><\/a><\/p>\n<h2><a title=\"Automatic resource management with try-with-resources in java 7\" href=\"https:\/\/howtodoinjava.com\/java7\/try-with-resources\/\" target=\"_blank\" rel=\"noopener noreferrer\">Automatic resource management with try-with-resources<\/a><\/h2>\n<p>Before java 7, we had to use finally blocks to cleanup the resources. Finally blocks were not mandatory, but resource clean up was to prevent the system from being corrupt. With java 7, there is no need to explicit resource cleanup. Its done automatically. Automatic resource cleanup is done when initializing resource in try-with-resources block (try(\u2026) {\u2026}).<\/p>\n<p>Cleanup happens because of new interface <code>AutoCloseable<\/code>. Its close method is invoked by JVM as soon as try block finishes. You are not supposed to call <strong>close()<\/strong> method in your code. This should be called automatically bu JVM. Calling it manually may cause unexpected results.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class ResourceManagementInJava7\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n        try (BufferedReader br = new BufferedReader(new FileReader(&quot;C:\/temp\/test.txt&quot;)))\r\n        {\r\n            String sCurrentLine;\r\n            while ((sCurrentLine = br.readLine()) != null)\r\n            {\r\n                System.out.println(sCurrentLine);\r\n            }\r\n        }\r\n        catch (IOException e)\r\n        {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n<\/pre>\n<p><a name=\"nio2\"><\/a><\/p>\n<h2><a title=\"nio 2\" href=\"https:\/\/howtodoinjava.com\/java\/nio\/nio-read-file\/\" target=\"_blank\" rel=\"noopener noreferrer\">NIO 2.0<\/a><\/h2>\n<p>Java SE 7 introduced <code>java.nio.file<\/code> package and its related package, <code>java.nio.file.attribute<\/code>, provide comprehensive support for file I\/O and for accessing the default file system. Path class has been a big addition which allow you to represent any path in operating system in uniform way. New APIs complements older one and provides several useful method checking, deleting, copying, and moving files. You can also create symbolic links and hard links like in linux. JDK 7 new file API is also capable of searching for files using wild cards\/regex. You also get support to watch a directory for changes.<\/p>\n<p>Go ahead and explore all these changes in linked webpages.<\/p>\n<p><a name=\"exception_improvements\"><\/a><\/p>\n<h2>Exception handling improvements<\/h2>\n<p>Java 7 has brought some nice enhancements in exception handling as well. These can be broadly divided into two features:<\/p>\n<p><a name=\"suppressed_exceptions\"><\/a><\/p>\n<h3><a title=\"Suppressed exceptions in java 7\" href=\"https:\/\/howtodoinjava.com\/java7\/java-suppressed-exceptions\/\" target=\"_blank\" rel=\"noopener noreferrer\">Suppressed exceptions<\/a><\/h3>\n<p>Suppressed exceptions, as name suggest, are exceptions thrown in the code but were ignored somehow. If you remember try-catch-finally block execution sequence and how they return any value or exceptions, you will recall that exceptions thrown in finally block are suppressed is exception is thrown in try block also. Before java 7, you was informed about these exceptions by logging if implemented, but you didn\u2019t have any control over these types of exceptions once finally block is over. With new features in java 7 you got control over these suppressed exceptions as well.<\/p>\n<p>A example usage is below:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class SuppressedExceptionDemoWithTryFinallyNew\r\n{\r\n    \/**\r\n    * Executable member function demonstrating suppressed exceptions\r\n    * Suppressed expression is added back in primary exception\r\n    *\/\r\n    public static void memberFunction() throws Exception\r\n    {\r\n        Throwable th = null;\r\n        DirtyResource resource= new DirtyResource();\r\n        try\r\n        {\r\n              resource.accessResource();\r\n        }\r\n        catch(Exception e)\r\n        {\r\n            th = e;\r\n            throw e;\r\n        }\r\n        finally\r\n        {\r\n            try\r\n            {\r\n                resource.close();\r\n            }\r\n            catch(Exception e)\r\n            {\r\n                if(th != null)\r\n                {\r\n                    e.addSuppressed(th); \/\/Add to primary exception\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n    }\r\n   \/**\r\n    * Executable function demonstrating suppressed exceptions.\r\n    *\/\r\n   public static void main(String[] arguments) throws Exception\r\n   {\r\n      try\r\n      {\r\n          memberFunction();\r\n      }\r\n      catch(Exception ex)\r\n      {\r\n          err.println(&quot;Exception encountered: &quot; + ex.toString());\r\n          final Throwable[] suppressedExceptions = ex.getSuppressed();\r\n          final int numSuppressed = suppressedExceptions.length;\r\n          if (numSuppressed &amp;gt; 0)\r\n          {\r\n              err.println(&quot;tThere are &quot; + numSuppressed + &quot; suppressed exceptions:&quot;);\r\n              for (final Throwable exception : suppressedExceptions)\r\n              {\r\n                  err.println(&quot;tt&quot; + exception.toString());\r\n              }\r\n          }\r\n      }\r\n   }\r\n}\r\n\r\nOutput:\r\n\r\nException encountered: java.lang.NullPointerException: Remember me. I am your worst nightmare !! I am Null pointer exception !!\r\n    There are 1 suppressed exceptions:\r\n        java.lang.RuntimeException: I wanted to access this resource. Bad luck. Its dirty resource !!!\r\n<\/pre>\n<p>Read more on linked article.<\/p>\n<p><a name=\"catch_multiple_exceptions\"><\/a><\/p>\n<h3><a title=\"Improved exception handling in Java 7\" href=\"https:\/\/howtodoinjava.com\/java7\/improved-exception-handling\/\" target=\"_blank\" rel=\"noopener noreferrer\">Catch Multiple Exceptions in catch block<\/a><\/h3>\n<p>In this feature, now you can catch multiple exceptions in single catch block. Before java 7, you was restricted to catch only one. To specify the list of expected exceptions a pipe (\u2018|\u2019) character is used.<\/p>\n<p>Lets understand using an example.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\ntry\r\n{\r\n       \/\/Do some processing which throws NullPointerException; I am sending directly\r\n       throw new NullPointerException();\r\n}\r\n\r\n\/\/You can catch multiple exception added after 'pipe' character\r\ncatch(NullPointerException | IndexOutOfBoundsException ex)\r\n{\r\n       throw ex;\r\n}\r\n<\/pre>\n<div class=\"noticeboxesde bluenoticebox\">Remember: If a catch block handles more than one exception type, then the catch parameter is implicitly final. In this example, the catch parameter ex is final and therefore you cannot assign any values to it within the catch block.<\/div>\n<p><a name=\"number_formatting\"><\/a><\/p>\n<h2><a title=\"Improved formatted numbers in java 7\" href=\"https:\/\/howtodoinjava.com\/java7\/improved-formatted-numbers-in-java-7\/\" target=\"_blank\" rel=\"noopener noreferrer\">Number formatting enhancement<\/a><\/h2>\n<p>If you have to read a number \u201c1000000\u201c, then how much convenient it read in first site. Not much, right?? We have a habit of reading numbers in 10,00,000 format. Good news is that java has started supporting to write numbers in this format. Well, not exactly this but a matching format.<\/p>\n<p>Now you can write above number like this : 10_00_000. Good enough, Isn\u2019t it??<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n\/**\r\n * Supported in int\r\n * *\/\r\nint improvedInt = 10_00_000;\r\n\/**\r\n * Supported in float\r\n * *\/\r\nfloat improvedFloat = 10_00_000f;\r\n\/**\r\n * Supported in long\r\n * *\/\r\nfloat improvedLong = 10_00_000l;\r\n\/**\r\n * Supported in double\r\n * *\/\r\nfloat improvedDouble = 10_00_000;\r\n<\/pre>\n<p><a name=\"string_in_switch\"><\/a><\/p>\n<h2><a title=\"String class is supported in switch statement in java 7\" href=\"https:\/\/howtodoinjava.com\/java7\/strings-in-switch-statement\/\" target=\"_blank\" rel=\"noopener noreferrer\">String class support in switch statement<\/a><\/h2>\n<p>If you remember the switch statement before java 7, it supported only int and <code>enum<\/code> types. Now with java 7 release, support for String class has also been added. Lets see using an example.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nswitch (token)\r\n{\r\n\tcase (&quot;one&quot;):\r\n\t\treturn &quot;Token one identified&quot;;\r\n\r\n\tcase (&quot;two&quot;):\r\n\t\treturn &quot;Token one identified&quot;;\r\n\r\n\tcase (&quot;three&quot;):\r\n\t\treturn &quot;Token one identified&quot;;\r\n\r\n\tcase (&quot;four&quot;):\r\n\t\treturn &quot;Token one identified&quot;;\r\n\r\n\tdefault:\r\n\t\treturn &quot;No token was identified&quot;;\r\n}\r\n<\/pre>\n<p><a name=\"binary_literal\"><\/a><\/p>\n<h2>Binary Literals with prefix &#8220;0b&#8221;<\/h2>\n<p>In JDK 7, you can express literal values in binary with prefix &#8216;0b&#8217; (or &#8216;0B&#8217;) for integral types (byte, short, int and long). Before JDK 7, you can only use octal values (with prefix &#8216;0&#8217;) or hexadecimal values (with prefix &#8216;0x&#8217; or &#8216;0X&#8217;). e.g.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nint sameVarOne = 0b01010000101;\r\n\r\nor if use the number formatting feature as well.\r\n\r\nint sameVarTwo = 0B01_010_000_101;\r\n<\/pre>\n<p><a name=\"fork-join\"><\/a><\/p>\n<h2><a title=\"Fork\/Join Framework Tutorial: ForkJoinPool Example\" href=\"https:\/\/howtodoinjava.com\/java7\/forkjoin-framework-tutorial-forkjoinpool-example\/\" target=\"_blank\" rel=\"noopener noreferrer\">ForkJoin Framework<\/a><\/h2>\n<p>The effective use of parallel cores in a Java program has always been a challenge. There were few home-grown frameworks that would distribute the work across multiple cores and then join them to return the result set. Java 7 has incorporated this feature as a Fork and Join framework.<\/p>\n<p>Basically the Fork-Join breaks the task at hand into mini-tasks until the mini-task is simple enough that it can be solved without further breakups. It\u2019s like a divide-and-conquer algorithm. One important concept to note in this framework is that ideally no worker thread is idle. They implement a work-stealing algorithm in that idle workers steal the work from those workers who are busy.<\/p>\n<p>It\u2019s based on the work of Doug Lea, a thought leader on Java concurrency. Fork\/Join deals with the threading hassles; you just indicate to the framework which portions of the work can be broken apart and handled recursively. It employs pseudo-code (as taken from Doug Lea\u2019s paper on the subject):<\/p>\n<pre>Result solve(Problem problem) {\r\n\tif (problem is small)\r\n\t\tdirectly solve problem\r\n\telse {\r\n\t\tsplit problem into independent parts\r\n\t\tfork new subtasks to solve each part\r\n\t\tjoin all subtasks\r\n\t\tcompose result from subresults\r\n\t}\r\n}<\/pre>\n<p><a name=\"watchservice\"><\/a><\/p>\n<h2><a title=\"Auto reload of configuration when any change happen\" href=\"https:\/\/howtodoinjava.com\/java7\/auto-reload-of-configuration-when-any-change-happen\/\" target=\"_blank\" rel=\"noopener noreferrer\">Automatic reloading with WatchService<\/a><\/h2>\n<p>Every application has some configuration which is expected to be refreshed on every change in configuration file. Past approaches to solve this problem had consisted of having a Thread, which periodically poll for file change based on \u2018last update time stamp\u2019 of configuration file.<\/p>\n<p>Now with java 7, things have changed. Java 7 has introduced an excellent feature: <code>WatchService<\/code>. A <code>WatchService<\/code> is JDKs internal service which watches for changes on registered objects. These registered objects are necessarily the instances of <code>Watchable<\/code> interface. When registering the watchable instance with WatchService, we need to specify the kind of change events we are interested in.<\/p>\n<p>A example usage of <code>WatchService<\/code> is given in linked article.<\/p>\n<p><a name=\"g1_garbage_collector\"><\/a><\/p>\n<h2>G1 Garbage Collector<\/h2>\n<p>JDK 7 introduced a new Garbage Collector known as G1 Garbage Collection, which is short form of garbage first. G1 garbage collector performs clean-up where there is most garbage. To achieve this it split Java heap memory into multiple regions as opposed to 3 regions in the prior to Java 7 version (new, old and perm-gen space). G1 is quite predictable and provides greater through put for memory intensive applications.<\/p>\n<p>That&#8217;s all for this quick summary. You can find the full list of features in this link.<\/p>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>I have already covered many java 7 changes which were new in the release. In this post, I am creating a summary of them so that if anyone interested can take a quick look into all features in short time. Features covered in this post Improved type Inference Or Diamond Operator Automatic resource management with &#8230; <a title=\"Java 7 Changes, Features and Enhancements\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java7\/java-7-changes-features-and-enhancements\/\" aria-label=\"More on Java 7 Changes, Features and Enhancements\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[17],"tags":[1435],"uagb_featured_image_src":{"full":false,"thumbnail":false,"medium":false,"medium_large":false,"large":false,"1536x1536":false,"2048x2048":false,"yarpp-thumbnail":false},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":6,"uagb_excerpt":"I have already covered many java 7 changes which were new in the release. In this post, I am creating a summary of them so that if anyone interested can take a quick look into all features in short time. Features covered in this post Improved type Inference Or Diamond Operator Automatic resource management with&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3931"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=3931"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3931\/revisions"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=3931"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=3931"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=3931"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}