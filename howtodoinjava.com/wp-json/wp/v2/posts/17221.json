{"id":17221,"date":"2021-02-20T21:29:56","date_gmt":"2021-02-20T15:59:56","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=17221"},"modified":"2021-08-22T06:25:00","modified_gmt":"2021-08-22T00:55:00","slug":"java-15-new-features","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java15\/java-15-new-features\/","title":{"rendered":"Java 15 New Features"},"content":{"rendered":"<p>Java 15 released on 15th Sep&#8217;2020 following the 6th-month release cycle. Java 15 continues support for various preview features in previous JDK releases; and also introduced some new features.<\/p>\n<p>Let us learn about these new features in Java 15.<\/p>\n<h2>1. Sealed Classes and Interfaces (Preview) (JEP 360)<\/h2>\n<p>Prior to Java 15, there was no restriction on classes or interfaces regarding which all classes can inherit them. A public interface was available to be implemented by any class, and any public class was available to be extended by any other class &#8211; unless declared <a href=\"https:\/\/howtodoinjava.com\/java\/keywords\/final-finally-finalize\/\">final<\/a>.<\/p>\n<p>Now with Java 15, a class or an interface can be declared sealed class or sealed interface using the modifier <strong>sealed<\/strong>. It is a <em>preview feature<\/em> in Java 15 through <a href=\"https:\/\/openjdk.java.net\/jeps\/360\">JEP 360<\/a>.<\/p>\n<p>A sealed class or interface restricts which other classes or interfaces may extend or implement them. Conceptually, it is a more declarative way than <a href=\"https:\/\/howtodoinjava.com\/java\/oops\/java-access-modifiers\/\">access modifiers<\/a> to restrict the use of a class or interface as a parent class or as a parent interface.<\/p>\n<p>The reserved keyword <strong>permits<\/strong> lists all the classes that can extend the sealed class directly. The listed subclasses can either be <code>final<\/code>, <code>non-sealed<\/code>, or <code>sealed<\/code>.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nsealed class Account\r\n    permits CurrentAccount, SavingAccount, LoanAccount {\r\n}\r\n \r\nfinal class CurrentAccount extends Account {}\r\nnon-sealed class SavingAccount extends Account {}\r\nsealed class LoanAccount extends Account permits HomeloanAccount, AutoloanAccount {}\r\n \r\nfinal class HomeloanAccount extends LoanAccount{}\r\nfinal class AutoloanAccount extends LoanAccount{}\r\n<\/pre>\n<blockquote><p>Read More: <a href=\"https:\/\/howtodoinjava.com\/java15\/sealed-classes-interfaces\/\">Sealed Classes and Interfaces<\/a><\/p><\/blockquote>\n<h2>2. EdDSA Algorithm (JEP 339)<\/h2>\n<p>EdDSA (Edwards-Curve Digital Signature Algorithm) [<a href=\"https:\/\/tools.ietf.org\/html\/rfc8032\">RFC 8032<\/a>] is another additional digital signature scheme added in Java 15 thorough <a href=\"https:\/\/openjdk.java.net\/jeps\/339\">JEP 339<\/a>.<\/p>\n<p>It provides much better performance and secure signatures in comparison to other available signature schemes.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nKeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;Ed25519&quot;);\r\nKeyPair kp = kpg.generateKeyPair();\r\n\r\nbyte[] msg = &quot;test_string&quot;.getBytes(StandardCharsets.UTF_8);\r\n\r\nSignature sig = Signature.getInstance(&quot;Ed25519&quot;);\r\nsig.initSign(kp.getPrivate());\r\nsig.update(msg);\r\nbyte[] s = sig.sign();\r\n\r\nString encodedString = Base64.getEncoder().encodeToString(s);\r\nSystem.out.println(encodedString);\r\n<\/pre>\n<blockquote><p>Read More: <a href=\"https:\/\/howtodoinjava.com\/java15\/java-eddsa-example\/\">Java EdDSA (Ed25519 \/ Ed448) Example<\/a><\/p><\/blockquote>\n<h2>3. Hidden Classes (JEP 371)<\/h2>\n<p>Hidden classes are different from normal Java classes. They cannot be used directly by the bytecode of other classes. Hidden classes are intended for use by frameworks that generate classes at run time and use them indirectly, via <a href=\"https:\/\/howtodoinjava.com\/java\/reflection\/real-usage-examples-of-reflection-in-java\/\">reflection<\/a>.<\/p>\n<p>With hidden classes, not framework developers can create non-discoverable classes which cannot be seen by the outside classes; and can be unloaded explicitly without being worrying about possible references from other classes.<\/p>\n<p>JVM supports aggressive unloading of non-discoverable classes so that frameworks have the flexibility to define as many as they need.<\/p>\n<p>Prior to Java 15, we could have created similar classes but with using non-recommeneded <a href=\"https:\/\/blogs.oracle.com\/javamagazine\/the-unsafe-class-unsafe-at-any-speed\">sun.misc.UnSafe<\/a> API.<\/p>\n<h2>4. Other Enhancements<\/h2>\n<h4>4.1. Pattern Matching for instanceof (Second Preview) (JEP 375)<\/h4>\n<p>JEP 375 proposes to re-preview the feature in JDK 15, with no changes relative to the preview in JDK 14, in order to gather additional feedback.<\/p>\n<p>A <strong>type test pattern<\/strong> (used in <code>instanceof<\/code>) consists of a predicate that specifies a type, along with a single binding variable.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nif (obj instanceof String s) {\r\n    \/\/ can use s here\r\n} else {\r\n    \/\/ can't use s here\r\n}\r\n\r\n\/\/Example\r\n\r\nif(customer instanceof PersonalCustomer pCustomer)\r\n{\r\n    customerName = String.join(&quot; &quot;, pCustomer.getFirstName(), \r\n                            pCustomer.getMiddleName(), \r\n                            pCustomer.getLastName());\r\n}\r\nelse if(customer instanceof BusinessCustomer bCustomer)\r\n{\r\n    customerName = bCustomer.getLegalName();\r\n}\r\n<\/pre>\n<blockquote><p>Read More: <a href=\"https:\/\/howtodoinjava.com\/java14\/pattern-matching-instanceof\/\">Pattern Matching for instanceof<\/a><\/p><\/blockquote>\n<h4>4.2. Removed Nashorn JavaScript Engine (JEP 372)<\/h4>\n<p>Nashorn JavaScript script engine was first introduced in Java 8 as a replacement for the Rhino scripting engine. It got the first depreciation notice in Java 11.<\/p>\n<p>With the rapid pace at which ECMAScript language constructs, along with APIs, are adapted and modified, maintaining Nashorn is becoming more challenging each day.<\/p>\n<h4>4.3. Reimplement the Legacy DatagramSocket API (JEP 373)<\/h4>\n<p>The new implementation is easy to debug and to adapt to work with virtual threads. This is currently being explored in Project Loom.<\/p>\n<h4>4.4. Records (Second Preview) (JEP 384)<\/h4>\n<p>Records are aimed for providing the classes which acts as immutable data carrier rather than having extensible behavior. Records automatically implement data-driven methods such as constructors, accessors, <a href=\"https:\/\/howtodoinjava.com\/java\/basics\/java-hashcode-equals-methods\/\"><code>equals()<\/code>, <code>hashCode()<\/code><\/a> and <code>toString()<\/code>.<\/p>\n<p>Records help in minimizing the common complaint with Java i.e. verbosity.<\/p>\n<p>In the second preview, Records have some minor changes. Now fields inside a record should not be modified via reflection as it will throw <code>IllegalAccessException<\/code>. <\/p>\n<h4>4.5 Text Blocks (JEP 378)<\/h4>\n<p>Text blocks are finally a standard feature in Java 15. A text block is a multi-line string literal. <\/p>\n<p>While using text blocks, we do not need to provide explicit line terminators, string concatenations, and delimiters otherwise used for writing the normal string literals.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nString dbSchema =   &quot;&quot;&quot;\r\n            CREATE TABLE 'TEST'.'EMPLOYEE'\r\n            (\r\n              'ID' INT NOT NULL DEFAULT 0 ,\r\n              'FIRST_NAME' VARCHAR(100) NOT NULL ,\r\n              'LAST_NAME' VARCHAR(100) NULL ,\r\n              'STAT_CD' TINYINT NOT NULL DEFAULT 0\r\n            );\r\n                    &quot;&quot;&quot;;\r\n<\/pre>\n<blockquote><p>Read More : <a href=\"https:\/\/howtodoinjava.com\/java14\/java-text-blocks\/\">Text blocks<\/a><\/p><\/blockquote>\n<h4>4.6. Garbage Collection (JEP 377 and 379)<\/h4>\n<p>Since Java 15, <strong>ZGC<\/strong> (JEP 377) and <strong>Shenandoah<\/strong> (JEP 379) are no longer the experimental features. The default GC remains <a href=\"https:\/\/howtodoinjava.com\/java\/garbage-collection\/all-garbage-collection-algorithms\/\">G1<\/a>.<\/p>\n<h2>5. Conclusion<\/h2>\n<p>Java 15 provides new features such as sealed classes and hidden classes, as well as provides continued support to several features of past releases, including records, text blocks, new garbage collection algorithms, and more. <\/p>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Java 15 released on 15th Sep&#8217;2020 following the 6th-month release cycle. Java 15 continues support for various preview features in previous JDK releases; and also introduced some new features. Let us learn about these new features in Java 15. 1. Sealed Classes and Interfaces (Preview) (JEP 360) Prior to Java 15, there was no restriction &#8230; <a title=\"Java 15 New Features\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java15\/java-15-new-features\/\" aria-label=\"More on Java 15 New Features\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":14658,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[1348],"tags":[1435],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15.png",600,300,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15-150x150.png",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15-300x150.png",300,150,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15.png",600,300,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15.png",600,300,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15.png",600,300,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15.png",600,300,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/11\/java15.png",120,60,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"Java 15 released on 15th Sep&#8217;2020 following the 6th-month release cycle. Java 15 continues support for various preview features in previous JDK releases; and also introduced some new features. Let us learn about these new features in Java 15. 1. Sealed Classes and Interfaces (Preview) (JEP 360) Prior to Java 15, there was no restriction&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/17221"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=17221"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/17221\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/14658"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=17221"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=17221"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=17221"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}