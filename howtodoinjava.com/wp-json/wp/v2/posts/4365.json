{"id":4365,"date":"2014-12-08T07:23:56","date_gmt":"2014-12-08T07:23:56","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=4365"},"modified":"2020-12-26T00:50:08","modified_gmt":"2020-12-25T19:20:08","slug":"complete-java-servlets-tutorial","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/","title":{"rendered":"Complete Java Servlets Tutorial"},"content":{"rendered":"<p>Servlets are Java classes that conform to the Java Servlet API, which allows a Java class to respond to requests. Although servlets can respond to any type of request, they are most commonly written to respond to web-based requests. A servlet must be deployed to a Java servlet container in order to become usable. Although many developers use servlet frameworks such as <strong><a href=\"https:\/\/en.wikipedia.org\/wiki\/JavaServer_Pages\" title=\"jsp\" target=\"_blank\" rel=\"noopener noreferrer\">Java Server Pages (JSP)<\/a><\/strong> and <strong><a href=\"https:\/\/en.wikipedia.org\/wiki\/JavaServer_Faces\" title=\"jsf\" target=\"_blank\" rel=\"noopener noreferrer\">Java Server Faces (JSF)<\/a><\/strong>, both of those technologies compile pages into Java servlets behind the scenes via the servlet container. That said, a <strong>fundamental knowledge of Java servlet technology<\/strong> could be very useful for any Java web developer.<\/p>\n<p>In this tutorial, we will cover below topics to get overall understanding of java servlet technology.<\/p>\n<pre><strong>Table of Contents<\/strong>\r\n\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#write_simple_servlet\">Writing your first Servlet<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#servlet_life_cycle_methods\">Servlet Life Cycle Methods<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#webservlet_annotation\">Develop Servlet with @WebServlet Annotation<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#packaging_deploying_in_tomcat\">Packaging and Deploying Servlet into Tomcat Server<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#write_dynamic_content\">Writing dynamic content in Servlet response<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#servlet_request_response\">Handling Servlet Request and Response<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#container_event_listener\">Listening for Servlet Container Events<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#servlet_init_params\">Passing Servlet Initialization Parameters<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#filter_interface\">Adding Servlet Filters for Specific URL Requests<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#file_download\">Downloading a binary file using Servlet<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#forward_method\">Forward request to another servlet using RequestDispatcher.forward()<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#sendredirect_method\">Redirect request to another servlet using HttpServletResponse.sendRedirect()<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/#write_read_cookie\">Writing and Reading Cookie using Servlets<\/a><\/pre>\n<p>Let&#8217;s start learning about servlets step by step.<\/p>\n<p><a name=\"write_simple_servlet\"><\/a><\/p>\n<h2>Writing your first Servlet<\/h2>\n<p>Our first servlet is very simple servlet having very minimum code, so that you can only focus on what matters.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npackage com.howtodoinjava.servlets;\r\n\r\nimport java.io.IOException;\r\nimport java.io.PrintWriter;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\npublic class MyFirstServlet extends HttpServlet {\r\n\r\n\tprivate static final long serialVersionUID = -1915463532411657451L;\r\n\r\n\t@Override\r\n\tprotected void doGet(HttpServletRequest request,\r\n\t\t\tHttpServletResponse response) throws ServletException, IOException \r\n\t{\r\n\t\tresponse.setContentType(&quot;text\/html;charset=UTF-8&quot;);\r\n\t\tPrintWriter out = response.getWriter();\r\n\t\ttry {\r\n\t\t\t\/\/ Write some content\r\n\t\t\tout.println(&quot;&lt;html&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;head&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;title&gt;MyFirstServlet&lt;\/title&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;\/head&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;body&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;h2&gt;Servlet MyFirstServlet at &quot; + request.getContextPath() + &quot;&lt;\/h2&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;\/body&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;\/html&gt;&quot;);\r\n\t\t} finally {\r\n\t\t\tout.close();\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tprotected void doPost(HttpServletRequest request,\r\n\t\t\tHttpServletResponse response) throws ServletException, IOException {\r\n\t\t\/\/Do some other work\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String getServletInfo() {\r\n\t\treturn &quot;MyFirstServlet&quot;;\r\n\t}\r\n}\r\n<\/pre>\n<p><strong>To register above servlet with web container, you will make an entry web.xml file for your application.<\/strong><\/p>\n<pre class=\"brush: xml; title: ; notranslate\" title=\"\">\r\n&lt;?xml version=&quot;1.0&quot;?&gt;\r\n&lt;web-app \txmlns=&quot;http:\/\/xmlns.jcp.org\/xml\/ns\/javaee&quot; \r\n\t\t\txmlns:xsi=&quot;http:\/\/www.w3.org\/2001\/XMLSchema-instance&quot;\r\n\t\t\txsi:schemaLocation=&quot;http:\/\/xmlns.jcp.org\/xml\/ns\/javaee \r\n\t\t\thttp:\/\/www.oracle.com\/webfolder\/technetwork\/jsc\/xml\/ns\/javaee\/web-app_3_0.xsd&quot;\r\n\t\t\tversion=&quot;3.0&quot;&gt;\r\n\t\t\t\r\n\t&lt;welcome-file-list&gt;\r\n\t\t&lt;welcome-file&gt;\/MyFirstServlet&lt;\/welcome-file&gt;\r\n\t&lt;\/welcome-file-list&gt;\r\n\t\r\n\t&lt;servlet&gt;\r\n\t\t&lt;servlet-name&gt;MyFirstServlet&lt;\/servlet-name&gt;\r\n\t\t&lt;servlet-class&gt;com.howtodoinjava.servlets.MyFirstServlet&lt;\/servlet-class&gt;\r\n\t&lt;\/servlet&gt;\r\n\t&lt;servlet-mapping&gt;\r\n\t\t&lt;servlet-name&gt;MyFirstServlet&lt;\/servlet-name&gt;\r\n\t\t&lt;url-pattern&gt;\/MyFirstServlet&lt;\/url-pattern&gt;\r\n\t&lt;\/servlet-mapping&gt;\r\n\t\r\n&lt;\/web-app&gt;\r\n<\/pre>\n<p>Above servlet does few important things, you may want to learn.<\/p>\n<ol>\n<li><strong>MyFirstServlet extends HttpServlet<\/strong>. This is mandatory because all servlets must be either a generic servlet that extends <code>javax.servlet.GenericServlet<\/code> or an HTTP servlet that extends <code>javax.servlet.http.HttpServlet<\/code>.<\/li>\n<li>Overriding <code>doGet()<\/code> and <code>doPost()<\/code> methods. These methods are defined in <code>HttpServlet<\/code> class. Whenever a GET or POST request come, it is mapped to it&#8217;s respective method e.g. if you send a<\/li>\n<li>HTTP GET request to this servlet, then <code>doGet()<\/code> method is called.<br \/>\nThere are some other useful methods as well which you can override to control the application in runtime e.g. <code>getServletInfo()<\/code>.<\/li>\n<li><code>HttpServletRequest<\/code> and <code>HttpServletResponse<\/code> are default parameters to all doXXX() methods. We will learn more about these objects in later section.<\/li>\n<\/ol>\n<p>That&#8217;s pretty all about a simple servlet you should know.<\/p>\n<p><a name=\"servlet_life_cycle_methods\"><\/a><\/p>\n<h2>Servlet Life Cycle Methods<\/h2>\n<p>Whenever in your application, a servlet is loaded and used; there occur a series of events during the initialization and destruction of that servlet. These are called <strong>life cycle events (or methods) of servlet<\/strong>. Let&#8217;s read more about them.<\/p>\n<p>Three methods are central to the life cycle of a servlet. These are <code>init()<\/code>, <code>service()<\/code>, and <code>destroy()<\/code>. They are implemented by every servlet and are invoked at specific times by the runtime.<\/p>\n<p>1) During initialization stage of the servlet life cycle, the <strong>web container initializes the servlet instance by calling the init() method<\/strong>, passing an object implementing the <code>javax.servlet.ServletConfig<\/code> interface. This configuration object allows the servlet to access name-value initialization parameters defined in web.xml file of the web application. This is <strong>called only once in lifetime of that servlet instance<\/strong>.<\/p>\n<p>The init method definition looks like this:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic void  init() throws ServletException {\r\n\t\/\/custom initialization code\r\n}\r\n<\/pre>\n<p>2) After initialization, the servlet instance can service client requests. The <strong>web container calls the service() method of the servlet for every request<\/strong>. The <code>service()<\/code> method determines the kind of request being made and dispatches it to an appropriate method to handle the request. The developer of the servlet must provide an implementation for these methods. If a request is made for a method that is not implemented by the servlet, the method of the parent class is called, typically resulting in an error being returned to the requester.<\/p>\n<p>There&#8217;s no need to override this method in &#8216;almost&#8217; all situations.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\r\n\tthrows ServletException, IOException\r\n{\r\nString method = req.getMethod();\r\n\r\nif (method.equals(METHOD_GET)) {\r\n\tlong lastModified = getLastModified(req);\r\n\tif (lastModified == -1) {\r\n\t\/\/ servlet doesn't support if-modified-since, no reason\r\n\t\/\/ to go through further expensive logic\r\n\tdoGet(req, resp);\r\n\t} else {\r\n\tlong ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\r\n\tif (ifModifiedSince &lt; (lastModified \/ 1000 * 1000)) {\r\n\t\t\/\/ If the servlet mod time is later, call doGet()\r\n\t\t\t\t\/\/ Round down to the nearest second for a proper compare\r\n\t\t\t\t\/\/ A ifModifiedSince of -1 will always be less\r\n\t\tmaybeSetLastModified(resp, lastModified);\r\n\t\tdoGet(req, resp);\r\n\t} else {\r\n\t\tresp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\r\n\t}\r\n\t}\r\n\r\n} else if (method.equals(METHOD_HEAD)) {\r\n\tlong lastModified = getLastModified(req);\r\n\tmaybeSetLastModified(resp, lastModified);\r\n\tdoHead(req, resp);\r\n\r\n} else if (method.equals(METHOD_POST)) {\r\n\tdoPost(req, resp);\r\n\t\r\n} else if (method.equals(METHOD_PUT)) {\r\n\tdoPut(req, resp);\t\r\n\t\r\n} else if (method.equals(METHOD_DELETE)) {\r\n\tdoDelete(req, resp);\r\n\t\r\n} else if (method.equals(METHOD_OPTIONS)) {\r\n\tdoOptions(req,resp);\r\n\t\r\n} else if (method.equals(METHOD_TRACE)) {\r\n\tdoTrace(req,resp);\r\n\t\r\n} else {\r\n\t\/\/\r\n\t\/\/ Note that this means NO servlet supports whatever\r\n\t\/\/ method was requested, anywhere on this server.\r\n\t\/\/\r\n\r\n\tString errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);\r\n\tObject[] errArgs = new Object[1];\r\n\terrArgs[0] = method;\r\n\terrMsg = MessageFormat.format(errMsg, errArgs);\r\n\t\r\n\tresp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\r\n}\r\n}\r\n<\/pre>\n<p>3) Finally, the <strong>web container calls the destroy() method that takes the servlet out of service<\/strong>. You should call this method if you want to close or destroy some filesystem or network resources before the servlet goes out of scope. The <code>destroy()<\/code> method, like init(), is called only once in the lifecycle of a servlet.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic void destroy() {\r\n\t\/\/\r\n}\r\n<\/pre>\n<p>Usually you do not need to override any of them in your servlet in most of the scenarios.<\/p>\n<blockquote><p><strong>Read More :<\/strong> <a href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/\" title=\"A birds-eye view on \u201chow web servers work?\u201d\" target=\"_blank\" rel=\"noopener noreferrer\">How web servers work?<\/a><\/p><\/blockquote>\n<p><a name=\"webservlet_annotation\"><\/a><\/p>\n<h2>Develop Servlet with @WebServlet Annotation<\/h2>\n<p>If you are not very fond of xml configurations, and rather like annotations particularly then Servlets API has something you as well. You can use <code><a href=\"https:\/\/docs.oracle.com\/javaee\/6\/api\/javax\/servlet\/annotation\/WebServlet.html\" title=\"WebServlet\" target=\"_blank\" rel=\"noopener noreferrer\">@WebServlet<\/a><\/code> annotation as below example and then you do not need to make any entry in web.xml. <strong>Container will automatically register your servlet into runtime, and process it as usual<\/strong>. <\/p>\n<pre class=\"brush: java; highlight: [12]; title: ; notranslate\" title=\"\">\r\npackage com.howtodoinjava.servlets;\r\n\r\nimport java.io.IOException;\r\nimport java.io.PrintWriter;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(name = &quot;MyFirstServlet&quot;, urlPatterns = {&quot;\/MyFirstServlet&quot;})\r\npublic class MyFirstServlet extends HttpServlet {\r\n\r\n\tprivate static final long serialVersionUID = -1915463532411657451L;\r\n\r\n\t@Override\r\n\tprotected void doGet(HttpServletRequest request,\r\n\t\t\tHttpServletResponse response) throws ServletException, IOException \r\n\t{\r\n\t\t\/\/Do some work\r\n\t}\r\n\t\r\n\t@Override\r\n\tprotected void doPost(HttpServletRequest request,\r\n\t\t\tHttpServletResponse response) throws ServletException, IOException {\r\n\t\t\/\/Do some other work\r\n\t}\r\n}\r\n<\/pre>\n<p><a name=\"packaging_deploying_in_tomcat\"><\/a><\/p>\n<h2>Packaging and Deploying Servlet into Tomcat Server<\/h2>\n<p>If you are using any IDE (e.g. eclipse) then packaging and deploying your application is simply one step. <code>Right click on project > Run As > Run As Server<\/code>. Configure the server if not done already and you are ready to roll.<\/p>\n<p>If you are not using any IDE, then you need to do some additional work e.g compiling the application from command prompt, using ANT to create a war file etc. But I am pretty confident that everyone nowadays uses some IDE for development, so I will not waste more time in this section.<\/p>\n<p>When you deploy our first servlet in tomcat and hit the URL &#8220;<em>http:\/\/localhost:8080\/servletexamples\/MyFirstServlet<\/em>&#8221; in browser, you will get below response.<\/p>\n<p><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/servlet-example.png\" alt=\"servlet example\" width=\"659\" height=\"166\" class=\"aligncenter size-full wp-image-4366\" srcset=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/servlet-example.png 659w, https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/servlet-example-300x75.png 300w\" sizes=\"(max-width: 659px) 100vw, 659px\" \/><\/p>\n<p><a name=\"write_dynamic_content\"><\/a><\/p>\n<h2>Writing dynamic content in Servlet response<\/h2>\n<p>One of the reasons why Java servlets are so useful is because they allow dynamic content to be displayed on a web page. The content can be taken from the server itself, a database, another web site, or many other web-accessible resources. Servlets are not static web pages; they are dynamic, and that is arguably their biggest strength.<\/p>\n<p>Let&#8217;s take example of a servlet which is responsible for displaying current date and time to user, along with his name and some custom message. Let&#8217;s code for it.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npackage com.howtodoinjava.servlets;\r\n\r\nimport java.io.IOException;\r\nimport java.io.PrintWriter;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@WebServlet(name = &quot;CalendarServlet&quot;, urlPatterns = {&quot;\/CalendarServlet&quot;})\r\npublic class CalendarServlet extends HttpServlet {\r\n\r\n\tprivate static final long serialVersionUID = -1915463532411657451L;\r\n\r\n\t@Override\r\n\tprotected void doGet(HttpServletRequest request,\r\n\t\t\tHttpServletResponse response) throws ServletException, IOException \r\n\t{\r\n\t\t\r\n\t\tMap&lt;String,String&gt; data = getData();\r\n\t\t\r\n\t\tresponse.setContentType(&quot;text\/html;charset=UTF-8&quot;);\r\n\t\tPrintWriter out = response.getWriter();\r\n\t\ttry {\r\n\t\t\t\/\/ Write some content\r\n\t\t\tout.println(&quot;&lt;html&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;head&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;title&gt;CalendarServlet&lt;\/title&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;\/head&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;body&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;h2&gt;Hello &quot; + data.get(&quot;username&quot;) + &quot;, &quot; + data.get(&quot;message&quot;) + &quot;&lt;\/h2&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;h2&gt;The time right now is : &quot; + new Date() + &quot;&lt;\/h2&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;\/body&gt;&quot;);\r\n\t\t\tout.println(&quot;&lt;\/html&gt;&quot;);\r\n\t\t} finally {\r\n\t\t\tout.close();\r\n\t\t}\r\n\t}\r\n\t\r\n\t\/\/This method will access some external system as database to get user name, and his personalized message\r\n\tprivate Map&lt;String, String&gt; getData() \r\n\t{\r\n\t\tMap&lt;String, String&gt; data = new HashMap&lt;String, String&gt;();\r\n\t\tdata.put(&quot;username&quot;, &quot;Guest&quot;);\r\n\t\tdata.put(&quot;message&quot;,  &quot;Welcome to my world !!&quot;);\r\n\t\treturn data;\r\n\t}\r\n}\r\n<\/pre>\n<p>When you run above servlet in tomcat and hit the URL &#8220;<em>http:\/\/localhost:8080\/servletexamples\/CalendarServlet<\/em>&#8221; in browser, you will get below response.<\/p>\n<p><a href=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png\" alt=\"dynamic content in servlet\" width=\"694\" height=\"259\" class=\"aligncenter size-full wp-image-4367\" srcset=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png 694w, https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet-300x111.png 300w\" sizes=\"(max-width: 694px) 100vw, 694px\" \/><\/a><\/p>\n<p><a name=\"servlet_request_response\"><\/a><\/p>\n<h2>Handling Servlet Request and Response<\/h2>\n<p>Servlets make it easy to create web applications that adhere to a request and response life cycle. They have the ability to provide HTTP responses and also process business logic within the same body of code. The ability to process business logic makes servlets much more powerful than standard HTML code. <\/p>\n<p>In real world applications, an HTML web form contains parameters that are sent to a servlet. The servlet then processes those parameters in some fashion and publishes a response that can be seen by the client. In the case of an HttpServlet object, the client is a web browser, and the response is a web page. The &lt;form&gt; action attribute states that which should be used to process the values that are contained within the form.<\/p>\n<p>To obtain request parameters, call the <code>HttpServletRequest<\/code> object\u2019s <code>getParameter()<\/code> method, passing the id of the input parameter you want to obtain.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nString value1 = req.getParameter(&quot;param1&quot;);\r\nString value1 = req.getParameter(&quot;param2&quot;);\r\n<\/pre>\n<p>Once the values are obtained, they can be processed as needed. Then the response for client is prepared as we discussed in above sections. This response is sent back to client using <code>HttpServletResponse<\/code> object.<\/p>\n<p>A basic usage of request and response processing can be done like this:<\/p>\n<pre class=\"brush: java; highlight: [6,7,9,10]; title: ; notranslate\" title=\"\">\r\n@Override\r\nprotected void doGet(HttpServletRequest request,\r\n\t\tHttpServletResponse response) throws ServletException, IOException \r\n{\r\n\t\r\n\tresponse.setContentType(&quot;text\/html;charset=UTF-8&quot;);\r\n\tPrintWriter out = response.getWriter();\r\n\t\r\n\tString username = request.getParameter(&quot;username&quot;);\r\n\tString password = request.getParameter(&quot;password&quot;);\r\n\t\r\n\tboolean success = validateUser(username, password);\r\n\t\r\n\ttry {\r\n\t\t\/\/ Write some content\r\n\t\tout.println(&quot;&lt;html&gt;&quot;);\r\n\t\tout.println(&quot;&lt;head&gt;&quot;);\r\n\t\tout.println(&quot;&lt;title&gt;LoginServlet&lt;\/title&gt;&quot;);\r\n\t\tout.println(&quot;&lt;\/head&gt;&quot;);\r\n\t\tout.println(&quot;&lt;body&gt;&quot;);\r\n\r\n\t\tif(success) {\r\n\t\t\tout.println(&quot;&lt;h2&gt;Welcome Friend&lt;\/h2&gt;&quot;);\r\n\t\t}else{\r\n\t\t\tout.println(&quot;&lt;h2&gt;Validate your self again.&lt;\/h2&gt;&quot;);\r\n\t\t}\r\n\t\t\r\n\t\tout.println(&quot;&lt;\/body&gt;&quot;);\r\n\t\tout.println(&quot;&lt;\/html&gt;&quot;);\r\n\t} finally {\r\n\t\tout.close();\r\n\t}\r\n}\r\n<\/pre>\n<p>For sending the content, you will have to use <code>PrintWriter<\/code> object obtained from <code>HttpServletResponse<\/code>. Any content written to it will be written into outputstream and data will be sent back to client.<\/p>\n<p><a name=\"container_event_listener\"><\/a><\/p>\n<h2>Listening for Servlet Container Events<\/h2>\n<p>Sometimes it is useful to know when certain events occur within the application server container. This concept can be useful under many different circumstances, but most often it would likely be used for initializing an application upon start-up or cleaning up after an application upon shutdown. A servlet listener can be registered with an application to indicate when it has been started up or shut down. Therefore, by listening for such events, the servlet has the opportunity to perform some actions when they occur.<\/p>\n<p>To create a listener that performs actions based upon a container event, you must develop a class that implements the <code>ServletContextListener<\/code> interface. The methods that need to be implemented are <code>contextInitialized()<\/code> and <code>contextDestroyed()<\/code>. Both of the methods accept a <code>ServletContextEvent<\/code> as an argument, and they are automatically called each time the servlet container is initialized or shut down, respectively. <\/p>\n<p>To register the listener with the container, you can use one of the following techniques:<\/p>\n<p>1) Utilize the <code>@WebListener<\/code> annotation.<br \/>\n2) Register the listener within the web.xml application deployment descriptor.<br \/>\n3) Use the <code>addListener()<\/code> methods defined on <code>ServletContext<\/code>.<\/p>\n<p>Please note that <code>ServletContextListener<\/code> is not the only listner in servlet API. There are some more e.g.<\/p>\n<ul>\n<li>javax.servlet.ServletRequestListener<\/li>\n<li>javax.servlet.ServletRequestAttrbiteListener<\/li>\n<li>javax.servlet.ServletContextListener<\/li>\n<li>javax.servlet.ServletContextAttributeListener<\/li>\n<li>javax.servlet.HttpSessionListener<\/li>\n<li>javax.servlet.HttpSessionAttributeListener<\/li>\n<\/ul>\n<p>They can be implemented by your listner class based on choice that which all events you want to listen to; e.g. <code>HttpSessionListener<\/code> will be notified everytime a new user session is created or destroyed.<\/p>\n<p><a name=\"servlet_init_params\"><\/a><\/p>\n<h2>Passing Servlet Initialization Parameters<\/h2>\n<p>Most of the today&#8217;s application needs to set some configuration parameters which you can pass them upon application\/controller startup. Servlets also can receive initialization parameters which they can use to fully construct them before serving their first request. <\/p>\n<p>Obviously, you can hard-code the configuration values in servlet itself, but changing any of them will require you to recompile whole application again, and nobody would love to do that.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n&lt;web-app&gt;\r\n    &lt;servlet&gt;\r\n        &lt;servlet-name&gt;SimpleServlet&lt;\/servlet-name&gt;\r\n        &lt;servlet-class&gt;com.howtodoinjava.servlets.SimpleServlet&lt;\/servlet-class&gt;\r\n\t\t\r\n\t\t&lt;!-- Servlet init param --&gt;\r\n        &lt;init-param&gt;\r\n            &lt;param-name&gt;name&lt;\/param-name&gt;\r\n            &lt;param-value&gt;value&lt;\/param-value&gt;\r\n        &lt;\/init-param&gt;\r\n\r\n    &lt;\/servlet&gt;\r\n\r\n&lt;\/web-app&gt;\r\n<\/pre>\n<p>Once set, the parameter can be used within code by calling <code>getServletConfig().getInitializationParameter()<\/code> and passing the name of the parameter, as shown in the following line of code:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nString value = getServletConfig().getInitParameter(&quot;name&quot;);\r\n<\/pre>\n<p><a name=\"filter_interface\"><\/a><\/p>\n<h2>Adding Servlet Filters for Specific URL Requests<\/h2>\n<p>Web filters are useful for pre-processing requests and invoking certain functionality when a given URL is visited. Rather than invoking a servlet that exists at a given URL directly, any filter that contains the same URL pattern will be invoked prior to the servlet. This can be helpful in many situations, perhaps the most useful for performing logging, authentication, or other services that occur in the background without user interaction.<\/p>\n<p>Filters must implement the <code>javax.servlet.Filter<\/code> interface. Methods contained within this interface include <strong>init(), destroy(), and doFilter()<\/strong>. The init() and destroy() methods are invoked by the container. The doFilter() method is used to implement tasks for the filter class. If you want to chain filters or if more than one filter exists for a given URL pattern, they will be invoked in the order in which they are configured in the web.xml deployment descriptor.<\/p>\n<p>To configure the web.xml file to include a filter, use the &lt;filter&gt; and &lt;filter-mapping&gt; XML elements along with their associated child element tags.<\/p>\n<pre class=\"brush: xml; title: ; notranslate\" title=\"\">\r\n&lt;filter&gt;\r\n    &lt;filter-name&gt;LoggingFilter&lt;\/filter-name&gt;\r\n    &lt;filter-class&gt;LoggingFilter&lt;\/filter-class&gt;\r\n&lt;\/filter&gt;\r\n&lt;filter-mapping&gt;\r\n    &lt;filter-name&gt;LogingFilter&lt;\/filter-name&gt;\r\n    &lt;url-pattern&gt;\/*&lt;\/url-pattern&gt;\r\n&lt;\/filter-mapping&gt;\r\n<\/pre>\n<div class=\"noticeboxesde bluenoticebox\">If you want to use annotation to configure filters for specific servlets, you can use <code>@WebFilte<\/code>r annotation.<\/div>\n<p><a name=\"file_download\"><\/a><\/p>\n<h2>Downloading a binary file using Servlet<\/h2>\n<p>Downloading files is an essential task for almost any web application. To download a file, the servlet must provide a response of the same type that matches that of the file to be downloaded. It must also indicate in the response header that an attachment is to be included like below.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nString mimeType = context.getMimeType( fileToDownload );\r\nresponse.setContentType( mimeType != null ? mimeType : &quot;text\/plain&quot; );\r\nresponse.setHeader( &quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileToDownload + &quot;\\&quot;&quot; );\r\n<\/pre>\n<p>You can obtain a reference to the file that is to be downloaded (stored in filesystem) by calling the <code>ServletContext.getResourceAsStream()<\/code> method and passing the path of the file. This will return an <code>InputStream<\/code> object that can be used to read the contents of the file. A byte buffer is then created, which will be used to obtain chunks of data from the file when it is being read. The final real task is to read the file contents and copy them to the output stream. This is done using a while loop, which will continue to read from the <code>InputStream<\/code> until everything has been processed. Chunks of data are read in and written to the output stream using the loop. After this, <code>ServletOutputStream<\/code> object\u2019s flush method is called to clear the contents and release the resources.<\/p>\n<p>Let&#8217;s look at sample code<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nprivate void downloadFile(HttpServletRequest request, HttpServletResponse response, String fileToDownload) throws IOException\r\n\t{\r\n\t\tfinal int BYTES = 1024;\r\n\t\tint length = 0;\r\n\t\t\r\n\t\tServletOutputStream outStream = response.getOutputStream();\r\n\t\tServletContext context = getServletConfig().getServletContext();\r\n\r\n\t\tString mimeType = context.getMimeType( fileToDownload );\r\n\t\tresponse.setContentType( mimeType != null ? mimeType : &quot;text\/plain&quot; );\r\n\t\tresponse.setHeader( &quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileToDownload + &quot;\\&quot;&quot; );\r\n\r\n\t\tInputStream in = context.getResourceAsStream(&quot;\/&quot; + fileToDownload);\r\n\t\t\r\n\t\tbyte[] bbuf = new byte[BYTES];\r\n\r\n\t\twhile ((in != null) &amp;&amp; ((length = in.read(bbuf)) != -1)) {\r\n\t\t\toutStream.write(bbuf, 0, length);\r\n\t\t}\r\n\r\n\t\toutStream.flush();\r\n\t\toutStream.close();\r\n\t}\r\n<\/pre>\n<p><a name=\"forward_method\"><\/a><\/p>\n<h2>Forward request to another servlet using RequestDispatcher.forward()<\/h2>\n<p>Sometimes, your application require that a servlet should hands off requests to other servlets to complete the task that needs to be accomplished. Furthermore, the requests should be handed off without redirecting the client to another URL i.e. the URL in the browser should not change.<\/p>\n<p>The facilities for doing so are built right into the <code>ServletContext<\/code>, so once you obtain a reference to <code>ServletContext<\/code>, then you simply call the <code>getRequestDispatcher()<\/code> method to obtain a RequestDispatcher object that can be used to dispatch the request. When calling the <code>getRequestDispatcher()<\/code> method, pass a String containing the name of the servlet that you want to hand off the request to. After a <code>RequestDispatcher<\/code> object has been obtained, invoke its forward method by passing the <code>HttpServletRequest<\/code> and <code>HttpServletResponse<\/code> objects to it. The forward method performs the task of handing off the request.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nRequestDispatcher rd = servletContext.getRequestDispatcher(&quot;\/NextServlet&quot;);\r\nrd.forward(request, response);\r\n<\/pre>\n<p><a name=\"sendredirect_method\"><\/a><\/p>\n<h2>Redirect request to another servlet using HttpServletResponse.sendRedirect()<\/h2>\n<p>Though is some scenarios you will not like to notify user that servlet redirection has happened as we saw in previous section, but in some scenarios we actually want that to happen. You want to redirect the browser to another URL when a specific URL within your application is visited.<\/p>\n<p>To do this, you will need to call sendRedirect() method of <code>HttpServletResponse<\/code> object.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nhttpServletResponse.sendRedirect(&quot;\/anotherURL&quot;);\r\n<\/pre>\n<div class=\"noticeboxesde bluenoticebox\">This simple redirect, as opposed to servlet chaining, does not pass the <code>HttpRequest<\/code> object along to the target address.<\/div>\n<p><a name=\"write_read_cookie\"><\/a><\/p>\n<h2>Writing and Reading Cookie using Servlets<\/h2>\n<p>Many applications wants to store user&#8217;s current state of user browsing history in clients machine so that when user return to application again, he start from where he left. Usually for this requirement, cookies are used. You can see cookies as key-value pair based data stored on client&#8217;s machine. When application is accesses in browser then application is able to read or write these values.<\/p>\n<p>To create a cookie, simply instantiate a new <code>javax.servlet.http.Cookie<\/code> object and assign a name and value to it.  Once the cookie has been instantiated, properties can be set that will help to configure the cookie.  In the example to this recipe, the cookie\u2019s <code>setMaxAge()<\/code> and <code>setHttpOnly()<\/code> methods are called, setting the time of life for the cookie and ensuring that it will be guarded against client-side scripting.<\/p>\n<div class=\"noticeboxesde bluenoticebox\">Since Servlet 3.0 API, the ability to mark a cookie as HTTP only has become available. This allows the cookie to be safeguarded against client-side scripting attacks, making the cookie more secure.<\/div>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nCookie cookie = new Cookie(&quot;sessionId&quot;,&quot;123456789&quot;);\r\ncookie.setHttpOnly(true);\r\ncookie.setMaxAge(-30);\r\nresponse.addCookie(cookie);\r\n<\/pre>\n<p>Here response is instance of <code>HttpServletResponse<\/code> passed to <em>doXXX()<\/em> method.<\/p>\n<p>To read back the cookie information on server sire, use following code:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nCookie[] cookies = request.getCookies();\r\nfor(Cookie cookie : cookies)\r\n{\r\n\t\/\/cookie.getName();\r\n\t\/\/cookie.getValue()\r\n}\r\n<\/pre>\n<p>That&#8217;s all for this tutorial about servlets technology. Feel free to drop comment\/feedback.<\/p>\n<p><strong>Happy Learning !!<\/strong><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Servlets are Java classes that conform to the Java Servlet API, which allows a Java class to respond to requests. Although servlets can respond to any type of request, they are most commonly written to respond to web-based requests. A servlet must be deployed to a Java servlet container in order to become usable. Although &#8230; <a title=\"Complete Java Servlets Tutorial\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java\/servlets\/complete-java-servlets-tutorial\/\" aria-label=\"More on Complete Java Servlets Tutorial\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":4367,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[677],"tags":[1457],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png",694,259,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet-150x150.png",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet-300x111.png",300,111,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png",694,259,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png",694,259,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png",694,259,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png",694,259,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2014\/12\/dynamic-content-in-servlet.png",120,45,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":6,"uagb_excerpt":"Servlets are Java classes that conform to the Java Servlet API, which allows a Java class to respond to requests. Although servlets can respond to any type of request, they are most commonly written to respond to web-based requests. A servlet must be deployed to a Java servlet container in order to become usable. Although&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/4365"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=4365"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/4365\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/4367"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=4365"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=4365"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=4365"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}