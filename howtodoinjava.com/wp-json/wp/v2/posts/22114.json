{"id":22114,"date":"2022-07-18T15:37:00","date_gmt":"2022-07-18T10:07:00","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=22114"},"modified":"2022-07-19T08:39:21","modified_gmt":"2022-07-19T03:09:21","slug":"structured-concurrency","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/multi-threading\/structured-concurrency\/","title":{"rendered":"Structured Concurrency in Java &#8211; Project Loom"},"content":{"rendered":"\n<p>The <strong>structured concurrency<\/strong> feature (<a href=\"https:\/\/openjdk.org\/jeps\/428\" target=\"_blank\" rel=\"noreferrer noopener\">JEP-428<\/a>) aims to simplify Java concurrent programs by treating multiple tasks running in different threads (forked from the same parent thread) as a single unit of work. Treating all such child threads as a single unit will help in managing all threads as a unit; thus, canceling and error handling can be done more reliably.<\/p>\n\n\n\n<p>The reliability in error handling and task cancellations will eliminate common risks such as thread leaks and cancellation delays.<\/p>\n\n\n\t\t\t\t<div class=\"wp-block-uagb-table-of-contents uagb-toc__align-left uagb-toc__columns-1   uagb-block-49442531 \" \n\t\t\t\t\tdata-scroll= \"1\"\n\t\t\t\t\tdata-offset= \"30\"\n\t\t\t\t\tdata-delay= \"800\"\n\t\t\t\t>\n\t\t\t\t<div class=\"uagb-toc__wrap\">\n\t\t\t\t\t<div class=\"uagb-toc__title-wrap\">\n\t\t\t\t\t\t<div class=\"uagb-toc__title\">\n\t\t\t\t\t\t\tTable Of Contents\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"uagb-toc__list-wrap\">\n\t\t\t\t\t\t<ol class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#1-issues-with-traditional-concurrency\">1. Issues with Traditional Concurrency<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#11-thread-leaks\">1.1. Thread Leaks<\/a><li class=\"uagb-toc__list\"><a href=\"#12-unrelated-thread-dumps-and-diagnosis\">1.2. Unrelated Thread Dumps and Diagnosis<\/a><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#2-structured-concurrency\">2. Structured Concurrency<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#21-basic-concept\">2.1. Basic Concept<\/a><li class=\"uagb-toc__list\"><a href=\"#22-implementing-with-structuredtaskscope\">2.2. Implementing with StructuredTaskScope<\/a><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#3-structured-concurrency-and-virtual-threads\">3. Structured Concurrency and Virtual Threads<\/a><li class=\"uagb-toc__list\"><a href=\"#4-conclusion\">4. Conclusion<\/a><\/li><\/ul><\/li><\/ul><\/ol>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\n\n\n<h2 id=\"h-1-issues-with-traditional-concurrency\">1. Issues with Traditional Concurrency<\/h2>\n\n\n\n<h3 id=\"h-1-1-thread-leaks\">1.1. Thread Leaks<\/h3>\n\n\n\n<p>In traditional <a href=\"https:\/\/howtodoinjava.com\/java-concurrency-tutorial\/\">multi-threaded programming<\/a> (<strong>unstructured concurrency<\/strong>), if an application has to perform a complex task, it breaks the program into multiple smaller and independent units of sub-tasks. Then application submits all the tasks to <em><a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/java-thread-pool-executor-example\/\">ThreadPoolExecutor<\/a><\/em>, generally with an <em><a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/executor-service-example\/\">ExecutorService<\/a><\/em> that runs all tasks and sub-tasks.<\/p>\n\n\n\n<p>In such a programming model, all the child tasks run concurrently, so each can succeed or fail independently. There is no support in the API to cancel all related subtasks if one of them fails. The application has no control over the subtasks and must wait for all of them to finish before returning the result of the parent task. This waiting is a waste of resources and decreases the application&#8217;s performance.<\/p>\n\n\n\n<p>For example, if a task has to fetch the details of an account and it requires fetching details from multiple sources such as account details, linked accounts, user&#8217;s demographic data etc., then pseudo code a concurrent request processing will look like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Response fetch(Long id) throws ExecutionException, InterruptedException {\n    Future&lt;AccountDetails&gt;  accountDetailsFuture  = es.submit(() -&gt; getAccountDetails(id));\n    Future&lt;LinkedAccounts&gt; linkedAccountsFuture = es.submit(() -&gt; fetchLinkedAccounts(id));\n    Future&lt;DemographicData&gt; userDetailsFuture = es.submit(() -&gt; fetchUserDetails(id));\n\n    AccountDetails accountDetails  = accountDetailsFuture.get();  \n    LinkedAccounts linkedAccounts  = linkedAccountsFuture.get();  \n    DemographicData userDetails    = userDetailsFuture.get();  \n\n    return new Response(accountDetails, linkedAccounts, userDetails);\n}<\/code><\/pre>\n\n\n\n<p>In the above example, all three threads execute independently.<\/p>\n\n\n\n<ul><li>Suppose if there is an error in fetching the linked accounts then <em>fetch()<\/em> will return an error response. But the other two threads will continue running in the background. This is a case of the thread leak.<\/li><li>Similarly, if the user cancels the request from the front end and the <em>fetch()<\/em> is interrupted, all three threads will continue running in the background.<\/li><\/ul>\n\n\n\n<p>Though <a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/executor-service-cancel-task\/\">canceling the subtasks<\/a> is programmatically possible, there is no straightforward way to do it, and there are chances of error.<\/p>\n\n\n\n<h3>1.2. Unrelated Thread Dumps and Diagnosis<\/h3>\n\n\n\n<p>In the previous example, if there is an error in the <em>fetch()<\/em> API then it is hard to <a href=\"https:\/\/howtodoinjava.com\/linux\/how-to-get-thread-dump-in-linux-using-jstack\/\">analyze the thread dumps<\/a> because these are running in 3 different threads. Making a relationship between the information in 3 threads is very difficult because there is no relationship between these threads at the API level.<\/p>\n\n\n\n<p>When the call stack defines the task-subtask hierarchy, such as in sequential method executions, we get the parent-child relationship, which flows into error propagation.<\/p>\n\n\n\n<p>Ideally, the task relationship should reflect at the API level to control child threads&#8217; execution and debug when necessary. This would allow a child to report a result or exception only to its parent \u2014 the unique task that owns all the subtasks \u2014 which, then, could implicitly cancel the remaining subtasks.<\/p>\n\n\n\n<h2>2. Structured Concurrency<\/h2>\n\n\n\n<h3>2.1. Basic Concept<\/h3>\n\n\n\n<p><strong>In structured multi-threaded code, if a task splits into concurrent subtasks, they all return to the same place<\/strong> i.e., the task&#8217;s code block. This way the lifetime of a concurrent subtask is confined to that syntactic block.<\/p>\n\n\n\n<p>In this approach, <strong>subtasks work on behalf of a task that awaits their results and monitors them for failures<\/strong>. At run time, structured concurrency builds a <em>tree-shaped hierarchy of tasks<\/em>, with sibling subtasks being owned by the same parent task. This tree can be viewed as the concurrent counterpart to the call stack of a single thread with multiple method calls.<\/p>\n\n\n\n<h3>2.2. Implementing with StructuredTaskScope<\/h3>\n\n\n\n<p>The <code>StructuredTaskScope<\/code> is a basic API for structured concurrency that supports cases where a task splits into several concurrent sub-tasks, to be executed in their own threads.<\/p>\n\n\n\n<p>It enforces that the sub-tasks must complete before the main task continues. It ensures that the lifetime of a concurrent operation is confined by a syntax block.<\/p>\n\n\n\n<p>Let us rewrite the previous example with <em>StructuredTaskScope<\/em> API. Note that the <code>fork()<\/code> method starts a <a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/virtual-threads\/\">virtual thread<\/a> to execute a task, the <code>join()<\/code> method waits for all threads to finish, and the <code>close()<\/code> method closes the task scope.<\/p>\n\n\n\n<p>The <em>StructuredTaskScope<\/em> class implements <em><a href=\"https:\/\/howtodoinjava.com\/java\/basics\/java-cleaners\/\">AutoCloseable<\/a><\/em> interface so if we use the <em><a href=\"https:\/\/howtodoinjava.com\/java7\/try-with-resources\/\">try-with-resources<\/a><\/em> block then <code>close()<\/code> will be invoked automatically after the parent thread finishes execution.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">try (var scope = new StructuredTaskScope.ShutdownOnFailure()()) {\n\n    Future&lt;AccountDetails&gt; accountDetailsFuture = scope.fork(() -&gt; getAccountDetails(id));\n    Future&lt;LinkedAccounts&gt; linkedAccountsFuture = scope.fork(() -&gt; fetchLinkedAccounts(id));\n    Future&lt;DemographicData&gt; userDetailsFuture = scope.fork(() -&gt; fetchUserDetails(id));\n\n    scope.join();\t\/\/ Join all subtasks\n    scope.throwIfFailed(e -&gt; new WebApplicationException(e));\n\n    \/\/The subtasks have completed by now so process the result\n    return new Response(accountDetailsFuture.resultNow(), \n\t    \tlinkedAccountsFuture.resultNow(),\n\t    \tuserDetailsFuture.resultNow());\n}<\/code><\/pre>\n\n\n\n<p>This solution resolves all the problems with unstructured concurrency as noted down in the first section.<\/p>\n\n\n\n<h2>3. Structured Concurrency and Virtual Threads<\/h2>\n\n\n\n<p>Virtual threads are JVM-managed lightweight threads for writing high throughput concurrent applications. As virtual threads are inexpensive compared to traditional OS threads, structured concurrency takes advantage of them for forking all new threads.<\/p>\n\n\n\n<p>In addition to being plentiful, virtual threads are cheap enough to represent any concurrent unit of behavior, even behavior that involves I\/O. Behind the scenes, the task-subtask relationship is maintained by associating each virtual thread with its unique owner, so it knows its hierarchy, similar to how a frame in the call stack knows its unique caller.<\/p>\n\n\n\n<h2>4. Conclusion<\/h2>\n\n\n\n<p>When combined with virtual threads, the structured concurrency promises long-awaited and much-needed features to Java that are already present in other programming languages (e.g., goroutines in Go and processes in Erlang). It will help in writing more complex and concurrent applications with excellent reliability and fewer thread leaks.<\/p>\n\n\n\n<p>Such applications will be easier to debug and profile when errors occur.<\/p>\n\n\n\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Structured concurrency (JEP-428) aims to simplify Java concurrent programs by treating multiple tasks running in different threads as a single unit of work.<\/p>\n","protected":false},"author":2,"featured_media":21889,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[789],"tags":[28,1571,1573],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-150x150.jpg",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-300x127.jpg",300,127,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-768x326.jpg",768,326,true],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-120x120.jpg",120,120,true]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"Structured concurrency (JEP-428) aims to simplify Java concurrent programs by treating multiple tasks running in different threads as a single unit of work.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/22114"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=22114"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/22114\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/21889"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=22114"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=22114"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=22114"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}