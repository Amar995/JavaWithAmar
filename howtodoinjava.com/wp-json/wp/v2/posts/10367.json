{"id":10367,"date":"2018-05-17T15:12:17","date_gmt":"2018-05-17T09:42:17","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=10367"},"modified":"2022-01-25T02:00:20","modified_gmt":"2022-01-24T20:30:20","slug":"jdk-jre-jvm","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/basics\/jdk-jre-jvm\/","title":{"rendered":"Java JDK, JRE and JVM"},"content":{"rendered":"<p>Learn the <strong>differences between JDK, JRE and JVM<\/strong>. How JVM works inside? What are <strong>class loaders<\/strong>, <strong>interpreter<\/strong> and <strong>JIT compilers<\/strong>. Also checkout some <a href=\"https:\/\/howtodoinjava.com\/java-interview-questions\/\">Java interview questions<\/a>.<\/p>\n<pre>Table of Contents\r\n\r\n<a href=\"#execution\">1. Execution of a Java Program<\/a>\r\n<a href=\"#jvm\">2. What is JVM?<\/a>\r\n<a href=\"#jre\">3. What is JRE?<\/a>\r\n<a href=\"#jdk\">4. What is JDK?<\/a>\r\n<a href=\"#differences\">5. Differences between JDK, JRE and JVM<\/a>\r\n<a href=\"#interview-questions\">6. Interview questions related to JDK, JRE and JVM<\/a>\r\n<a href=\"#downloads\">7. JDK and JRE downloads<\/a><\/pre>\n<p><a id=\"execution\"><\/a><\/p>\n<h2>1. Execution of a Java Program<\/h2>\n<p>Before jumping into the internals of Java, let&#8217;s understand how a Java source file is executed. <\/p>\n<ol>\n<li>We write the Java source code in <code>Simple.Java<\/code> file using an editor or IDE (<strong>integrated development environment<\/strong>) e.g. <em>Eclipse<\/em> or <em>IntelliJ Idea<\/em>.<\/li>\n<li>Program has to be compiled into bytecode. Java compiler (<code>javac<\/code>) compiles the sourcecode to <code>Simple.class<\/code> file.<\/li>\n<li>This class file can be executed in any platform\/OS by JVM (<strong>Java virtual machine<\/strong>).<\/li>\n<li>JVM translates bytecode into native machine code which machines can execute.<\/li>\n<\/ol>\n<figure id=\"attachment_11122\" aria-describedby=\"caption-attachment-11122\" style=\"width: 949px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/Java-Execution-Flow.png\" alt=\"Java Execution Flow\" width=\"959\" height=\"359\" class=\"size-full wp-image-11122\" \/><figcaption id=\"caption-attachment-11122\" class=\"wp-caption-text\">Java Execution Flow<\/figcaption><\/figure>\n<p><a id=\"jvm\"><\/a><\/p>\n<h2>2. What is JVM?<\/h2>\n<p><strong>Java Virtual machine<\/strong> (JVM) is the virtual machine that runs the Java bytecodes. You get this bytecode by compiling the <code>.java<\/code> files into <code>.class<\/code> files. <code>.class<\/code> files contain the bytecodes understood by the JVM.<\/p>\n<p>In the real world, JVM is a specification that provides a runtime environment in which Java bytecode can be executed. Different vendors provide different implementations of this specification. For example, this wiki page lists down <a href=\"https:\/\/en.wikipedia.org\/wiki\/List_of_Java_virtual_machines\">different JVM implementations<\/a>.<\/p>\n<p>Most popular implementation of JVM is <a href=\"https:\/\/www.oracle.com\/java\/technologies\/javase\/javase-core-technologies-apis.html\">Hotspot<\/a> which is owned and provided by Oracle Corporation. (<em>Previously by Sun Microsystems, Inc.<\/em>).<\/p>\n<p>JVM delivers the optimal performance for Java applications using many advanced techniques, incorporating a state-of-the-art memory model, <strong>garbage collector<\/strong>, and <strong>adaptive optimizer<\/strong>.<\/p>\n<p>JVM comes in two different flavors &#8211; <strong>client<\/strong> and <strong>server<\/strong>. Although the Server and the Client VMs are similar, the Server VM has been specially tuned to maximize peak operating speed. It is intended for executing long-running server applications, which need the fastest possible operating speed more than a fast start-up time or smaller runtime memory footprint. Developers can choose which system they want by specifying <code>-client<\/code> or <code>-server<\/code>.<\/p>\n<p>The JVM is called <strong>virtual<\/strong> because it provides a machine interface that does not depend on the underlying operating system and machine hardware architecture. This independence from hardware and the operating system is a cornerstone of the write-once-run-anywhere value of Java programs.<\/p>\n<h4>2.1. JVM Architecture<\/h4>\n<figure id=\"attachment_11123\" aria-describedby=\"caption-attachment-11123\" style=\"width: 721px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png\" alt=\"JVM Architecture\" width=\"731\" height=\"477\" class=\"size-full wp-image-11123\" \/><figcaption id=\"caption-attachment-11123\" class=\"wp-caption-text\">JVM Architecture<\/figcaption><\/figure>\n<h5>2.1.1. Class Loader<\/h5>\n<p>The class loader is a subsystem used for loading class files. It performs three primary functions, i.e. class loading, linking, and initialization.<\/p>\n<ol>\n<li>\n<h5>Loading<\/h5>\n<ul>\n<li>To load classes, JVM has 3 kind of class loaders.  <strong>Bootstrap<\/strong>, <strong>extension<\/strong> and <strong>application<\/strong> class loader.<\/li>\n<li>When loading a class file, JVM finds out a dependency for some arbitrary class <co\nde>XYZ.class<\/code>.<\/li>\n<li>First bootstrap class loader tries to find the class. It scans the <code>rt.jar<\/code> file in JRE <code>lib<\/code> folder.<\/li>\n<li>If class is not found then extension class loader searches the class file in inside <strong>jre\\lib\\ext<\/strong> folder.<\/li>\n<li>Again if class is not found then application classloader searches all the Jar files and classes in <code>CLASSPATH<\/code> environment variable of system.<\/li>\n<li>If class is found by any loader then class is loaded by class loader; else <code>ClassNotFoundException<\/code> is thrown.<\/li>\n<\/ul>\n<\/li>\n<li>\n<h5>Linking<\/h5>\n<p>After class is loaded by the classloader, linking is performed. A <strong>bytecode verifier<\/strong> will verify whether the generated bytecode is proper or not. If verification fails we will get a verification error. It also performs the memory allocation to static variables and methods found in the class.<\/li>\n<li>\n<h5>Initialization<\/h5>\n<p>This is the final phase of class loading, here all static variable will be assigned with the original values, and the static blocks will be executed.<\/li>\n<\/ol>\n<h5>2.1.2. JVM Memory Areas<\/h5>\n<p>The memory area inside JVM is divided into multiple parts to store specific pieces of application data.<\/p>\n<ul>\n<li><strong>Method Are<\/strong>a stores class structures like metadata, the constant runtime pool, and the code for methods.<\/li>\n<li><strong>Heap<\/strong> stores all objects that are created during application execution.<\/li>\n<li><strong>Stacks<\/strong> store local variables, and intermediate results. All such variables are local to the thread by which they are created. Each thread has its own JVM stack, created simultaneously as the thread is created. So all such local variable are called <strong>thread-local variables<\/strong>.<\/li>\n<li><strong>PC register<\/strong> store the physical memory address of the statements which is currently executing. In Java, each thread has its separate PC register.<\/li>\n<li>Java supports and uses <strong>native code<\/strong> as well. Many low level code is written in languages like C and C++. Native method stacks hold the instruction of native code.<\/li>\n<\/ul>\n<h4>2.2. JVM Execution Engine<\/h4>\n<p>All code assigned to JVM is executed by an <strong>execution engine<\/strong>. The execution engine reads the byte code and executes one by one. It uses two inbuilt <em>interpreter<\/em> and <em>JIT compiler<\/em> <strong>to convert the bytecode to machine code and execute it<\/strong>.<\/p>\n<figure id=\"attachment_11126\" aria-describedby=\"caption-attachment-11126\" style=\"width: 437px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/OS-Specific-Interpreters.png\" alt=\"Platform Specific Interpreters\" width=\"447\" height=\"168\" class=\"size-full wp-image-11126\" \/><figcaption id=\"caption-attachment-11126\" class=\"wp-caption-text\">Platform Specific Interpreters<\/figcaption><\/figure>\n<p>With JVM, both interpreter and compiler produce native code. The difference is in how they generate the native code, how optimized it is as well how costly the optimization is. <\/p>\n<h4>2.2.1. Interpreter<\/h4>\n<p>A JVM interpreter pretty much converts each byte-code instruction to corresponding native instruction by looking up a predefined JVM-instruction to machine instruction mapping. It <strong>directly<\/strong> executes the bytecode and does not perform any optimization.<\/p>\n<h4>2.2.2. JIT Compiler<\/h4>\n<p><strong>To improve performance<\/strong>, JIT compilers interact with the JVM at runtime and compile appropriate bytecode sequences into native machine code. Typically, the JIT compiler takes a block of code (not one statement at a time as interpreter), optimizes the code, and then translates it to optimized machine code.<\/p>\n<p>The <strong>JIT compiler is enabled by default<\/strong>. You can disable the JIT compiler, in which case the entire Java program will be interpreted. Disabling the JIT compiler is not recommended except to diagnose or workaround JIT compilation problems.<\/p>\n<p><a id=\"jre\"><\/a><\/p>\n<h2>3. What is JRE?<\/h2>\n<p>The <strong>Java Runtime Environment<\/strong> (JRE) is a software package which bundles the libraries (jars) and the Java Virtual Machine, and other components to run applications written in the Java. JVM is just a part of JRE distributions.<\/p>\n<p>To execute any Java application, you need JRE installed in the machine. It&#8217;s the minimum requirement to run Java applications on any computer.<\/p>\n<p>JRE bundles the following components &#8211; <\/p>\n<ol>\n<li><strong>DLL<\/strong> files used by the Java HotSpot <strong>Client Virtual Machine<\/strong>.<\/li>\n<li>DLL files used by the Java HotSpot <strong>Server Virtual Machine<\/strong>.<\/li>\n<li><strong>Code libraries<\/strong>, <strong>property settings<\/strong>, and <strong>resource files<\/strong> used by the Java runtime environment. e.g. <strong>rt.jar<\/strong> and <strong>charsets.jar<\/strong>.<\/li>\n<li>Java <strong>extension files<\/strong> such as <strong>localedata.jar<\/strong>.<\/li>\n<li>Contains files used for security management. These include the <strong>security policy<\/strong> (java.policy) and <strong>security properties<\/strong> (java.security) files.<\/li>\n<li>Jar files containing support classes for <strong>applets<\/strong>.<\/li>\n<li>Contains <strong>TrueType font files<\/strong> for use by the platform.<\/li>\n<\/ol>\n<p>JREs can be downloaded as part of JDKs, or you can download them separately. JREs are platform dependent. It means that based on the type of machine (OS and architecture), you will have to select the JRE bundle to import and install.<\/p>\n<p>For example, you cannot install a <code>64-bit<\/code> JRE distribution on <code>32-bit<\/code> machine. Similarly, JRE distribution for <em>Windows<\/em> will not work in <em>Linux<\/em>; and vice-versa.<\/p>\n<p><a id=\"jdk\"><\/a><\/p>\n<h2>4. What is JDK?<\/h2>\n<p><strong>JDK is a superset of JRE<\/strong>. JDK contains everything that JRE has along with development tools for developing, debugging, and monitoring Java applications. You need JDK when you need <strong>to develop Java applications<\/strong>. <\/p>\n<p>Few important components shipped with JDKs are as follows:<\/p>\n<ul>\n<li><strong>appletviewer<\/strong> \u2013 this tool can be used to run and debug Java applets without a web browser<\/li>\n<li><strong>apt<\/strong> \u2013 the annotation-processing tool<\/li>\n<li><strong>extcheck<\/strong> \u2013 a utility that detects JAR file conflicts<\/li>\n<li><strong>javadoc<\/strong> \u2013 the documentation generator, which automatically generates documentation from source code comments<\/li>\n<li><strong>jar<\/strong> \u2013 the archiver, which packages related class libraries into a single JAR file. This tool also helps manage JAR files<\/li>\n<li><strong>jarsigner<\/strong> \u2013 the jar signing and verification tool<\/li>\n<li><strong>javap<\/strong> \u2013 the class file disassembler<\/li>\n<li><strong>javaws<\/strong> \u2013 the Java Web Start launcher for JNLP applications<\/li>\n<li><strong>JConsole<\/strong> \u2013 Java Monitoring and Management Console<\/li>\n<li><strong>jhat<\/strong> \u2013 Java Heap Analysis Tool<\/li>\n<li><strong>jrunscript<\/strong> \u2013 Java command-line script shell<\/li>\n<li><strong>jstack<\/strong> \u2013 utility that prints Java stack traces of Java threads<\/li>\n<li><strong>keytool<\/strong> \u2013 tool for manipulating the keystore<\/li>\n<li><strong>policytool<\/strong> \u2013 the policy creation and management tool<\/li>\n<li><strong>xjc<\/strong> \u2013 Part of the Java API for XML Binding (JAXB) API. It accepts an XML schema and generates Java classes<\/li>\n<\/ul>\n<p>Same as JREs, JDKs are also platform dependent. So take care when you download the JDK package for your machine.<\/p>\n<p><a id=\"differences\"><\/a><\/p>\n<h2>5. Difference between JDK, JRE and JVM<\/h2>\n<p>Based on the above discussions, we can draw a relationship between these three as below &#8211; <\/p>\n<blockquote><p>JRE = JVM + libraries to run Java application.<\/p>\n<p>JDK = JRE + tools to develop Java Application.<\/p><\/blockquote>\n<figure id=\"attachment_10368\" aria-describedby=\"caption-attachment-10368\" style=\"width: 534px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JDK-JRE-JVM.png\" alt=\"JDK vs JRE vs JVM\" width=\"544\" height=\"439\" class=\"size-full wp-image-10368\" \/><figcaption id=\"caption-attachment-10368\" class=\"wp-caption-text\">JDK vs JRE vs JVM<\/figcaption><\/figure>\n<p>In short, if you are a Java application developer who writes code, you will need JDK installed in your machine. But, if you only want to run applications built in Java, you only need JRE installed into your computer.<\/p>\n<p><a id=\"interview-questions\"><\/a><\/p>\n<h2>6. Interview questions related to JDK, JRE and JVM<\/h2>\n<p>If you understood whatever we have discussed so far in this post, then facing any interview question will not be difficult. Still, be prepared to answer questions like below:<\/p>\n<ol>\n<li>\n<h4>What  is JVM architecture?<\/h4>\n<p>It&#8217;s already explained in detail.<\/li>\n<li>\n<h4>How many types of class loaders are in Java?<\/h4>\n<p>There are 3 class loaders. Bootstrap, extension and application class loaders.<\/li>\n<li>\n<h4>How class loader works in Java?<\/h4>\n<p>Class loaders scan their pre-defined locations for jar files and classes. They scan all those class files in the path and look for the required class. If found, they load, link, and initialize the class file. <\/li>\n<li>\n<h4>Difference between JRE and JVM?<\/h4>\n<p>JVM is the specification for a runtime environment that executes the Java applications. Hotspot JVM is such one implementation of the specification. It loads the class files and uses the interpreter and JIT compiler to convert bytecode into machine code and execute it. <\/li>\n<li>\n<h4>Difference between interpreter and JIT compiler?<\/h4>\n<p>The interpreter interprets the bytecode line by line and executes it sequentially. It results in poor performance. JIT compiler add optimization to this process by analyzing the code in blocks and then prepare more optimized machine code.<\/li>\n<\/ol>\n<p><a id=\"downloads\"><\/a><\/p>\n<h2>7. JDK and JRE downloads<\/h2>\n<p>You can find the platform-specific JDK and JRE software packages in Oracle&#8217;s Java distribution pages.<\/p>\n<p>For example, this <a href=\"https:\/\/www.oracle.com\/java\/technologies\/javase\/javase-jdk8-downloads.html\">page<\/a> lists down all available JDK distributions for Java 8.<\/p>\n<figure id=\"attachment_11124\" aria-describedby=\"caption-attachment-11124\" style=\"width: 541px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JDK-8-Distributions.png\" alt=\"JDK 8 Distributions\" width=\"551\" height=\"296\" class=\"size-full wp-image-11124\" \/><figcaption id=\"caption-attachment-11124\" class=\"wp-caption-text\">JDK 8 Distributions<\/figcaption><\/figure>\n<p>Similarly, JRE 8 distributions are available in this <a href=\"https:\/\/www.oracle.com\/java\/technologies\/javase-server-jre8-downloads.html\">page<\/a>.<\/p>\n<figure id=\"attachment_11125\" aria-describedby=\"caption-attachment-11125\" style=\"width: 536px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JRE-8-Distributions.png\" alt=\"JRE 8 Distributions\" width=\"546\" height=\"342\" class=\"size-full wp-image-11125\" \/><figcaption id=\"caption-attachment-11125\" class=\"wp-caption-text\">JRE 8 Distributions<\/figcaption><\/figure>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>JDK, JRE and JVM is very common words when developers talk about java applications and their development environments. Let&#8217;s find out the differeneces between these words.<\/p>\n","protected":false},"author":2,"featured_media":11123,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[753],"tags":[4,309,620,323],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",731,477,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",150,98,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",300,196,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",731,477,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",731,477,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",731,477,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",731,477,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/05\/JVM-Architecture.png",120,78,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"JDK, JRE and JVM is very common words when developers talk about java applications and their development environments. Let's find out the differeneces between these words.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/10367"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=10367"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/10367\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/11123"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=10367"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=10367"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=10367"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}