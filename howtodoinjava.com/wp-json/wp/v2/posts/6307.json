{"id":6307,"date":"2016-04-13T04:18:20","date_gmt":"2016-04-12T22:48:20","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=6307"},"modified":"2021-12-18T14:43:26","modified_gmt":"2021-12-18T09:13:26","slug":"jms-java-message-service-tutorial","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/jms\/jms-java-message-service-tutorial\/","title":{"rendered":"JMS Tutorial &#8211; Java Message Service Tutorial"},"content":{"rendered":"\n<p><a href=\"https:\/\/en.wikipedia.org\/wiki\/Java_Message_Service\" target=\"_blank\" rel=\"noopener noreferrer\">Java Message Service<\/a> is an API that supports the formal communication called <strong>messaging between computers<\/strong> on a network. JMS provides a common interface for standard message protocols and message services in support of the Java programs. <\/p>\n\n\n\n<p>JMS provides the <strong>facility to create, send and read messages<\/strong>. The JMS API reduces the concepts that a programmer must learn to use the messaging services\/products and also provides the features that support the messaging applications.<\/p>\n\n\n\n<p>JMS helps in building the communication between two or more applications in a loosely coupled manner. It means that the applications which have to communicate are not connected directly they are connected through a common destination. <\/p>\n\n\n\t\t\t\t<div class=\"wp-block-uagb-table-of-contents uagb-toc__align-left uagb-toc__columns-1 uagb-toc__collapse uagb-block-bade4496 \" \n\t\t\t\t\tdata-scroll= \"1\"\n\t\t\t\t\tdata-offset= \"30\"\n\t\t\t\t\tdata-delay= \"800\"\n\t\t\t\t>\n\t\t\t\t<div class=\"uagb-toc__wrap\">\n\t\t\t\t\t<div class=\"uagb-toc__title-wrap\">\n\t\t\t\t\t\t<div class=\"uagb-toc__title\">\n\t\t\t\t\t\t\tTable Of Contents\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"uag-toc__collapsible-wrap\">\t\t\t<svg xmlns=\"https:\/\/www.w3.org\/2000\/svg\" viewBox= \"0 0 320 512\"><path d=\"M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z\"><\/path><\/svg>\n\t\t\t<\/span>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"uagb-toc__list-wrap\">\n\t\t\t\t\t\t<ol class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#1-why-we-need-jms\">1. Why We Need JMS?<\/a><li class=\"uagb-toc__list\"><a href=\"#2-benefits-of-jms\">2. Benefits of JMS<\/a><li class=\"uagb-toc__list\"><a href=\"#3-jms-messaging-domains\">3. JMS Messaging Domains<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#31-point-to-point-messaging\">3.1. Point-to-Point Messaging<\/a><li class=\"uagb-toc__list\"><a href=\"#32-publishsubscribe-messaging\">3.2. Publish\/Subscribe Messaging<\/a><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#4-receiving-a-message\">4. Receiving a Message<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#41-synchronous\">4.1. Synchronous<\/a><li class=\"uagb-toc__list\"><a href=\"#42-asynchronous\">4.2. Asynchronous<\/a><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#5-jms-participating-objects\">5. JMS Participating Objects<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#51-jms-administered-objects\">5.1. JMS Administered Objects<\/a><li class=\"uagb-toc__list\"><a href=\"#52-connection-factories\">5.2. Connection Factories<\/a><li class=\"uagb-toc__list\"><a href=\"#53-destination\">5.3. Destination<\/a><li class=\"uagb-toc__list\"><a href=\"#54-jms-connection\">5.4. JMS Connection<\/a><li class=\"uagb-toc__list\"><a href=\"#55-jms-session\">5.5. JMS Session<\/a><li class=\"uagb-toc__list\"><a href=\"#56-message-producer\">5.6. Message Producer<\/a><li class=\"uagb-toc__list\"><a href=\"#57-message-consumer\">5.7. Message Consumer<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#6-message-components\">6. Message Components<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#61-message-header\">6.1. Message Header<\/a><li class=\"uagb-toc__list\"><a href=\"#62message-properties\">6.2.Message Properties<\/a><li class=\"uagb-toc__list\"><a href=\"#63-message-body\">6.3. Message Body<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/ol>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\n\n\n<h2>1. Why We Need JMS?<\/h2>\n\n\n\n<p>When one application wants to send a message to another application in such a way that both applications do not know anything about each other; and even they may NOT be deployed on the same server. <\/p>\n\n\n\n<p>For example, one application A is running in India and another application B is running in the USA, and A is interested in sending some updates\/messages to B &#8211; whenever something unique happens on A. There may be N number of such applications that are interested in such updates to B.<\/p>\n\n\n\n<p>In this scenario, Java provides one of the solutions in form of JMS &#8211; and solves the exact same problem discussed above.<\/p>\n\n\n\n<p>JMS is also useful when we are writing any event-based application like a <a href=\"https:\/\/howtodoinjava.com\/java\/library\/java-aiml-chatbot-example\/\">chat server<\/a> where it needs a publish event mechanism to send messages between the server and the clients. <\/p>\n\n\n\n<p>Note that JMS is different from RMI so there is no need for the destination object to be available online while sending a message. The publisher publishes the message and forgets it, whenever the receiver comes online, it will fetch the message. It&#8217;s a very powerful solution for very common problems in today&#8217;s world.<a name=\"advantages\"><\/a><\/p>\n\n\n\n<h2>2. Benefits of JMS<\/h2>\n\n\n\n<h4>2.1. Asynchronous<\/h4>\n\n\n\n<p><p>JMS is asynchronous by default. So to receive a message, the client is not required to initiate the communication. The message will arrive automatically to the client as they become available.<\/p><\/p>\n\n\n\n<h4>2.2. <span style=\"color: rgb(49, 59, 119); font-size: 20px; font-weight: 700;\">Reliable<\/span><\/h4>\n\n\n\n<p><p>JMS provides the facility of assurance that the message will be delivered once and only once. We know that duplicate messages create problems. JMS helps you avoid such problems.<\/p><a name=\"domains\"><\/a><\/p>\n\n\n\n<h2>3. JMS Messaging Domains<\/h2>\n\n\n\n<p>Even before the JMS API existed, most messaging products supported either the <strong>point-to-point<\/strong> or the <strong>publish\/subscribe<\/strong> approach to messaging. The JMS also provides a separate domain for each of both approaches and defines the compliance for each domain. <\/p>\n\n\n\n<p>Any JMS provider can implement both or one domain, it&#8217;s his own choice. The JMS provides the common interfaces which enable us to use the JMS API in such a way that it is not specific to either domain.<\/p>\n\n\n\n<p>Let&#8217;s see both types of messaging domains in more detail to understand <strong>how JMS works<\/strong>.<\/p>\n\n\n\n<h3>3.1. Point-to-Point Messaging<\/h3>\n\n\n\n<p>In the <a href=\"https:\/\/howtodoinjava.com\/jms\/jms-point-to-point-message-example\/\" target=\"_blank\" rel=\"noreferrer noopener\">point-to-point messaging<\/a> domain the application is built on the basis of <strong>message queues, senders and receivers<\/strong>. <\/p>\n\n\n\n<p>Each and every message is addressed to a particular <strong><a href=\"https:\/\/docs.oracle.com\/javaee\/6\/api\/javax\/jms\/Queue.html\" target=\"_blank\" rel=\"noopener noreferrer\">queue<\/a><\/strong>. Queues retain all messages sent to them until the messages are consumed or expired. <\/p>\n\n\n\n<p>There are some characteristics of PTP messaging:<\/p>\n\n\n\n<ol><li>There is only one client for each message.<\/li><li>There is no timing dependency for sender and receiver of a message.<\/li><li>The receiver can fetch message whether it is running or not when the sender sends the message.<\/li><li>The receiver sends the acknowledgement after receiving the message.<\/li><\/ol>\n\n\n\n<div class=\"wp-block-image size-full wp-image-6308\"><figure class=\"aligncenter\"><img loading=\"lazy\" width=\"575\" height=\"135\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-pointToPoint.gif\" alt=\"Point to point JMS Messaging\" class=\"wp-image-6308\"\/><figcaption>Point to point JMS Messaging<\/figcaption><\/figure><\/div>\n\n\n\n<h3>3.2. Publish\/Subscribe Messaging<\/h3>\n\n\n\n<p>In <a href=\"https:\/\/howtodoinjava.com\/jms\/jms-publish-subscribe-message-example\/\" target=\"_blank\" rel=\"noreferrer noopener\">publish\/subscribe messaging<\/a> domain, only one message is published which is delivered to all clients through <strong><a href=\"https:\/\/docs.oracle.com\/javaee\/6\/api\/javax\/jms\/Topic.html\" target=\"_blank\" rel=\"noopener noreferrer\">Topic<\/a><\/strong> which acts as a bulletin board. <\/p>\n\n\n\n<p>Publishers and subscribers are generally anonymous and can dynamically publish or subscribe to the topic. The Topic is responsible to hold and deliver messages. The topic retains messages as long as it takes to distribute to the present clients.<\/p>\n\n\n\n<p>Some of the characteristics are:<\/p>\n\n\n\n<ol><li>There can be multiple subscribers for a message.<\/li><li>The publisher and subscribe have a timing dependency. A client that subscribes to a topic can consume only messages published after the client has created a subscription, and the subscriber must continue to be active in order for it to consume messages.<\/li><\/ol>\n\n\n\n<div class=\"wp-block-image size-full wp-image-6309\"><figure class=\"aligncenter\"><img loading=\"lazy\" width=\"402\" height=\"164\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe.gif\" alt=\"Publish Subscribe JMS Messaging\" class=\"wp-image-6309\"\/><figcaption>Publish Subscribe JMS Messaging<\/figcaption><\/figure><\/div>\n\n\n\n<blockquote class=\"wp-block-quote is-style-default\"><p>Read More: <a href=\"https:\/\/howtodoinjava.com\/hornetq\/basic-jms-messaging-example-using-hornetq-stand-alone-server\/\" target=\"_blank\" rel=\"noreferrer noopener\">HornetQ Basic Example<\/a><\/p><\/blockquote>\n\n\n\n<h2>4. Receiving a Message<\/h2>\n\n\n\n<p>In JMS, the message consumption can be done in two ways:<\/p>\n\n\n\n<h3>4.1. Synchronous<\/h3>\n\n\n\n<p>In synchronous message consumption, the subscriber\/receiver requests the message from the destination by calling the <code><a href=\"https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/jms\/MessageConsumer.html#receive--\" target=\"_blank\" rel=\"noopener noreferrer\">receive()<\/a><\/code> method. <\/p>\n\n\n\n<p>The <code>receive()<\/code> method will block till the message arrives or time out if the message does not arrive within a given time. Just like normal java method calls with some return value.<\/p>\n\n\n\n<h3>4.2. Asynchronous<\/h3>\n\n\n\n<p>In asynchronous message consumption, a subscriber can register (or subscribe) as a <em>message listener<\/em> with the consumer. <\/p>\n\n\n\n<p>The message listener is the same as the event listener, whenever the message arrives at the destination the JMS provider will deliver the message by calling the listener\u2019s <code><a href=\"https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/jms\/MessageListener.html#onMessage-javax.jms.Message-\" target=\"_blank\" rel=\"noopener noreferrer\">onMessage()<\/a><\/code> method which will act on the content of the message.<a name=\"participants\"><\/a><\/p>\n\n\n\n<h2>5. JMS Participating Objects<\/h2>\n\n\n\n<p>JMS application has some basic building blocks, which are:<\/p>\n\n\n\n<ol><li>Administered objects \u2013 Connection Factories and Destination<\/li><li>Connections<\/li><li>Sessions<\/li><li>Message Producers<\/li><li>Message Consumers<\/li><li>Message Listeners<\/li><\/ol>\n\n\n\n<div class=\"wp-block-image size-full wp-image-6310\"><figure class=\"aligncenter\"><img loading=\"lazy\" width=\"699\" height=\"513\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/JMS-API-Programming-Model.png\" alt=\"JMS API Programming Model\" class=\"wp-image-6310\" srcset=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/JMS-API-Programming-Model.png 699w, https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/JMS-API-Programming-Model-300x220.png 300w\" sizes=\"(max-width: 699px) 100vw, 699px\" \/><figcaption>JMS API Programming Model<\/figcaption><\/figure><\/div>\n\n\n\n<h3>5.1. JMS Administered Objects<\/h3>\n\n\n\n<p>JMS application provides two types of administered objects:<\/p>\n\n\n\n<ul><li>Connection Factories<\/li><li>Destinations<\/li><\/ul>\n\n\n\n<p>These two administered objects are created by the JMS system administrator in JMS Provider by using the Application Server the admin console. Both objects are stored in the Application server JNDI Directory or JNDI Registry.<\/p>\n\n\n\n<h3>5.2. Connection Factories<\/h3>\n\n\n\n<p>The client uses an object which is a <a href=\"https:\/\/docs.oracle.com\/javaee\/6\/api\/javax\/jms\/ConnectionFactory.html\" target=\"_blank\" rel=\"noopener noreferrer\">connection factory<\/a> used to create a connection to a provider. It creates a connection between JMS Provider and JMS Client. <\/p>\n\n\n\n<p>When JMS Client such as sender or receiver search out for this object in JNDI Registry, then the JMS Client receives one connection object which is nothing just a physical connection between JMS Provider and JMS Client. Using this connection, the client can have communication with the destination object to send or receive messages into Queue or Topic. <\/p>\n\n\n\n<p>Let us have an example to understand it to send the message:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">QueueConnectionFactory queueConnFactory = (QueueConnectionFactory) initialCtx.lookup (\"primaryQCF\");\nQueue purchaseQueue = (Queue) initialCtx.lookup (\"Purchase_Queue\");\nQueue returnQueue = (Queue) initialCtx.lookup (\"Return_Queue\");<\/code><\/pre>\n\n\n\n<h3>5.3. Destination<\/h3>\n\n\n\n<p>The client uses an object known as a destination which is used to specify the target of messages it produces and the source of message who consumes it. <\/p>\n\n\n\n<p>The JMS application uses two types of destinations:<\/p>\n\n\n\n<ul><li>Queue<\/li><li>Topic<\/li><\/ul>\n\n\n\n<p>The code examples to create a queue or a topic:<\/p>\n\n\n\n<p><strong>Create queue session<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">QueueSession ses = con.createQueueSession (false, Session.AUTO_ACKNOWLEDGE);  \/\/get the Queue object\nQueue t = (Queue) ctx.lookup (\"myQueue\");  \/\/create QueueReceiver\nQueueReceiver receiver = ses.createReceiver(t);<\/code><\/pre>\n\n\n\n<p><strong>Create topic session<\/strong><\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">TopicSession ses = con.createTopicSession (false, Session.AUTO_ACKNOWLEDGE); \/\/ get the Topic object\nTopic t = (Topic) ctx.lookup (\"myTopic\");  \/\/create TopicSubscriber\nTopicSubscriber receiver = ses.createSubscriber(t);<\/code><\/pre>\n\n\n\n<h3>5.4. JMS Connection<\/h3>\n\n\n\n<p>The connection encapsulates the virtual connection with a JMS Provider. The connection implements the <em>Connection<\/em> interface, when it will have a <em>ConnectionFactory<\/em> object then we can use this to create a connection.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Connection connection = connectionFactory.createConnection();<\/code><\/pre>\n\n\n\n<h3>5.5. JMS Session<\/h3>\n\n\n\n<p>The <a href=\"https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/jms\/Session.html\" target=\"_blank\" rel=\"noopener noreferrer\">session<\/a> is a single-threaded context that is used for producing and consuming messages. <\/p>\n\n\n\n<p>The sessions are used to create the following:<\/p>\n\n\n\n<ul><li>Message Producers<\/li><li>Message Consumers<\/li><\/ul>\n\n\n\n<p>The session implements the Session interface and after creating a Connection object we use this to create a Session.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);<\/code><\/pre>\n\n\n\n<h3>5.6. Message Producer<\/h3>\n\n\n\n<p>A message producer is an object which is created by a session and is used for sending messages to the destination. This implements the <code><a href=\"https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/jms\/MessageProducer.html\" target=\"_blank\" rel=\"noopener noreferrer\">MessageProducer<\/a><\/code> interface. <\/p>\n\n\n\n<p>We use Session to create a <code>MessageProducer<\/code> for the destination, queue or topic object.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">MessageProducer producer = session.createProducer(dest);\nMessageProducer producer = session.createProducer(queue);\nMessageProducer producer = session.createProducer(topic);<\/code><\/pre>\n\n\n\n<h3>5.7. Message Consumer<\/h3>\n\n\n\n<p>A message consumer is an object which is created by a session and is used to receive messages sent at a destination. It will implement the <code><a href=\"https:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/jms\/MessageConsumer.html\" target=\"_blank\" rel=\"noopener noreferrer\">MessageConsumer<\/a><\/code> interface. <\/p>\n\n\n\n<p>We use a session to create a MessageConsumer for a destination, queue or topic object.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">MessageConsumer consumer = session.createConsumer(dest);\nMessageConsumer consumer = session.createConsumer(queue);\nMessageConsumer consumer = session.createConsumer(topic);<\/code><\/pre>\n\n\n\n<h4>5.8. Message Listener<\/h4>\n\n\n\n<p>A message listener is an object which acts as an asynchronous event handler for messages. The message listener implements the MessageListener interface which contains the one method <code>onMessage()<\/code>. <\/p>\n\n\n\n<p>In  <code>onMessage()<\/code> method, we define the actions to be performed when the message arrives. By using <code>setMessageListener()<\/code> we define the message listener with a specific <code>MessageConsumer<\/code>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Listener myListener = new Listener();\nconsumer.setMessageListener(myListener);<\/code><\/pre>\n\n\n\n<h2><a name=\"components\"><\/a>6. Message Components<\/h2>\n\n\n\n<p>The JMS Messages are used by the JMS Clients to have communication between systems. The JMS messages have a simple format but are highly flexible, which allows creating messages matching different formats. <\/p>\n\n\n\n<p>The JMS message is divided into three parts:<\/p>\n\n\n\n<h3>6.1. <span style=\"color: rgb(49, 59, 119); font-size: 20px; font-weight: 700;\">Message Header<\/span> <\/h3>\n\n\n\n<p><span style=\"font-size: inherit;\">The JMS message header contains the number of predefined fields which contain those values which are used by the clients and providers to identify and send messages. The predefined headers are:<\/span><\/p>\n\n\n\n<p><p>&#8211; JMSDestination<br>&#8211; JMSDeliveryMode<br>&#8211; JMSMessageID<br>&#8211; JMSTimestamp<br>&#8211; JMSCorrelationID<br>&#8211; JMSReplyTo<br>&#8211; JMSRedelivered<br>&#8211; JMSType<br>&#8211; JMSExpiration<br>&#8211; JMSPriority<\/p><\/p>\n\n\n\n<h3>6.2.Message Properties<span style=\"font-size: inherit;\"> <\/span><\/h3>\n\n\n\n<p><span style=\"font-size: inherit;\">In message properties we can create and set properties for messages. The message properties are custom name value pairs which are set or read by applications. The message properties are useful for supporting filtering messages. The JMS API provides some predefined property that a provider can support. The message property is optional.<\/span><\/p>\n\n\n\n<h3>6.3. <span style=\"color: rgb(49, 59, 119); font-size: 20px; font-weight: 700;\">Message Body<\/span> <\/h3>\n\n\n\n<p><span style=\"font-size: inherit;\">In message bodies the JMS API defines five message body formats which are also called as message types which allow us to send and receive data in many different forms and also provides compatibility with the existing messaging formats. It basically consists of the actual message sent from JMS sender to receiver. <\/span><\/p>\n\n\n\n<p><span style=\"font-size: inherit;\">The different message types are:<\/span> <\/p>\n\n\n\n<ul><li><p><strong>Text<\/strong>: Represented by <em>javax.jms.TextMessage<\/em>. It is used to represent a block of text.<\/p><\/li><li><p><strong>Object<\/strong>: Represented by <em>javax.jms.ObjectMessage<\/em>. It is used to represent a java object.<\/p><\/li><li><p><strong>Bytes<\/strong>: Represented by <em>javax.jms.BytesMessage<\/em>. It is used to represent the binary data.<\/p><\/li><li><p><strong>Stream<\/strong>: Represented by <em>javax.jms.StreamMessage<\/em>. It is used to represent a list of java primitive values.<\/p><\/li><li><p><strong>Map<\/strong>: Represented by <em>javax.jms.MapMessage<\/em>. It is used to represent a set of keyword or value pairs<\/p><\/li><\/ul>\n\n\n\n<p><p><span style=\"font-size: inherit;\">That&#8217;s all for the <\/span><strong style=\"font-size: inherit;\">JMS Introduction Tutorial and it&#8217;s related terminologies. In the <\/strong><span style=\"font-size: inherit;\">next set of posts. we will see some examples of JMS.<\/span><\/p><\/p>\n\n\n\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Java Message Service is an API that supports the formal communication called messaging between computers on a network. JMS provides a common interface for standard message protocols and message services in support of the Java programs. JMS provides the facility to create, send and read messages. The JMS API reduces the concepts that a programmer &#8230; <a title=\"JMS Tutorial &#8211; Java Message Service Tutorial\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/jms\/jms-java-message-service-tutorial\/\" aria-label=\"More on JMS Tutorial &#8211; Java Message Service Tutorial\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":6309,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[885],"tags":[313],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe.gif",402,164,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe-150x150.gif",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe-300x122.gif",300,122,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe.gif",402,164,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe.gif",402,164,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe.gif",402,164,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe.gif",402,164,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/04\/jms-publishSubscribe.gif",120,49,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":11,"uagb_excerpt":"Java Message Service is an API that supports the formal communication called messaging between computers on a network. JMS provides a common interface for standard message protocols and message services in support of the Java programs. JMS provides the facility to create, send and read messages. The JMS API reduces the concepts that a programmer&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/6307"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=6307"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/6307\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/6309"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=6307"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=6307"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=6307"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}