{"id":98,"date":"2012-10-18T12:07:41","date_gmt":"2012-10-18T06:37:41","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=98"},"modified":"2022-01-29T23:30:20","modified_gmt":"2022-01-29T18:00:20","slug":"exploring-interfaces-and-abstract-classes-in-java","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/oops\/exploring-interfaces-and-abstract-classes-in-java\/","title":{"rendered":"Interface vs Abstract Class in Java"},"content":{"rendered":"<p>Abstract classes and interfaces are the two main building blocks of most Java APIs. In this article, We will touch down the most glaring differences between interfaces and abstract classes in Java.<\/p>\n<pre>Table of Contents\r\n\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/oops\/exploring-interfaces-and-abstract-classes-in-java\/#abstract-class\">1. Abstract classes in java<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/oops\/exploring-interfaces-and-abstract-classes-in-java\/#interface\">2. Interfaces in java<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/oops\/exploring-interfaces-and-abstract-classes-in-java\/#abstractclass-vs-interface\">3. Abstract classes vs Interfaces<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/oops\/exploring-interfaces-and-abstract-classes-in-java\/#usecases\">4. When to use abstract class and when to use interfaces<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/oops\/exploring-interfaces-and-abstract-classes-in-java\/#default-methods\">5. Java 8 default methods in interfaces<\/a><\/pre>\n<div class=\"noticeboxesde bluenoticebox\">I will recommend you to read about <a title=\"Understanding abstraction in java\" href=\"https:\/\/howtodoinjava.com\/java\/oops\/understanding-abstraction-in-java\/\">abstraction<\/a> first, because it the main force behind abstract classes and interfaces.<\/div>\n<p><a id=\"abstract-class\"><\/a><\/p>\n<h2>1. Abstract classes in java<\/h2>\n<p>In simplest words, <strong>an abstract class is which is declared abstract using keyword <code>abstract<\/code><\/strong>. It may or may not contain any abstract method. JVM identifies abstract class as <strong>incomplete class<\/strong>, which has not defined its complete behavior. Declaring a class <code>abstract<\/code> enforces only one thing: you can not create an instance of this class, and that&#8217;s it.<\/p>\n<p>So why even you bother to create a class which can not be instantiated at all? The answer is in its usage in solving some critical design issues. We will come to that part later in this article.<\/p>\n<h4>1.1. Syntax of abstract class<\/h4>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nabstract class TestAbstractClass\r\n{\r\n    public abstract void abstractMethod();\r\n    public void normalMethod()\r\n    {\r\n        \/\/method body\r\n    }\r\n}\r\n<\/pre>\n<p>Here, our <code>TestAbstractClass<\/code> has two methods, one is abstract and second one is normal method. An abstract method. Having an abstract method in your class will force you to declare your class as abstract itself.<\/p>\n<h4>1.2. Abstract method<\/h4>\n<p>An <strong>abstract method<\/strong>, is a method which is not implemented in place. An abstract method adds the incompleteness to class, thus compiler wants to declare whole class abstract.<\/p>\n<p>The only way to use an abstract class in your application is to extend this class. Its subclasses if not declared <code>abstract<\/code> again, can be instantiated. The feature that subclass inherits the behavior of the superclass and superclass can hold the reference of subclass increases the importance of abstract classes many folds.<\/p>\n<p><a id=\"interface\"><\/a><\/p>\n<h2>2. Interfaces in java<\/h2>\n<p>Interfaces are yet another basic building block of most Java APIs. You name it e.g. collection, I\/O or SWT, you can see them in action everywhere.<\/p>\n<blockquote><p>Interface define contracts, which implementing classes need to honor.<\/p><\/blockquote>\n<p>These contracts are essentially unimplemented methods. Java already has a keyword for unimplemented methods i.e. <em>abstract<\/em>.  Java has the provision where any class can implement any interface, so all the methods declared in interfaces need to be public only.<\/p>\n<h4>2.1. Syntax of interface<\/h4>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic interface TestInterface\r\n{\r\n    void implementMe();\r\n}\r\n<\/pre>\n<p>For above interface, any implementing class needs to override <code>implementMe()<\/code> method. <\/p>\n<h4>2.2. Abstract class implementing interface<\/h4>\n<p>There is only one scenario when you implement an interface and do not override the method i.e. declare the implementing class itself <code>abstract<\/code>.<\/p>\n<pre class=\"brush: java; title: Abstract class; notranslate\" title=\"Abstract class\">\r\npublic abstract class TestMain implements TestInterface\r\n{\r\n    \/\/No need to override implement Me\r\n}\r\n<\/pre>\n<p>Otherwise, you must implement the method <code>implementMe()<\/code> in you class without any other exception.<\/p>\n<pre class=\"brush: java; title: Non-abstract class; notranslate\" title=\"Non-abstract class\">\r\npublic class TestMain implements TestInterface\r\n{\r\n    @Override\r\n    public void implementMe() {\r\n        \/\/ TODO Auto-generated method stub\r\n    }\r\n}\r\n<\/pre>\n<p><a id=\"abstractclass-vs-interface\"><\/a><\/p>\n<h2>3) Abstract classes vs Interfaces<\/h2>\n<p>Let&#8217;s note down <strong>differences between abstract classes and interfaces<\/strong> for quick review:<\/p>\n<ol>\n<li>Interfaces have all methods inherently <strong><em>public<\/em> and <em>abstract<\/em><\/strong>. You can not override this behavior by trying to reduce accessibility of methods. You can not even declare the static methods. Only public and abstract.\n<p>On the other side, abstract classes are flexible in declaring the methods. You can define abstract methods with protected accessibility also. Additionally, you can define static methods as well, provided they are not abstract. Non-abstract static methods are allowed.<\/li>\n<li>Interfaces can&#8217;t have fully defined methods. By definition, interfaces are meant to provide the only contract.\n<p>Abstract classes can have non-abstract methods without any limitation. You can use any keyword with non-abstract methods as you will do in any other class.<\/li>\n<li>Any class which want to use abstract class can extend abstract class using keyword <code>extends<\/code>, whereas for implementing interfaces keyword used is <code>implements<\/code>.\n<p>A class can extend only one class but can implement any number of interfaces. This property is often referred as simulation of<strong> multiple inheritance<\/strong> in java.<\/li>\n<li>Interface is absolutely <code>abstract<\/code> and cannot be instantiated; A Java abstract class also cannot be instantiated, but can be invoked if a main() exists.<\/li>\n<\/ol>\n<p>Next, a question may come if we have abstract methods and main class both, we may try to call the abstract method from <code>main()<\/code>. But this attempt will fail, as <code>main()<\/code> method is always static and abstract methods can never be static, so you can never access any non-static method inside the static method.<\/p>\n<p><a id=\"usecases\"><\/a><\/p>\n<h2>4. When to use abstract class and when to use interfaces<\/h2>\n<p>Always remember that <strong>choice between the interface or abstract class<\/strong> is not either\/or scenario, where choosing anyone without proper analysis would yield the same results. A choice must be made very intelligently after understanding the problem at hand. Let us try to put some intelligence here.<\/p>\n<h4>4.1. Partial behavior with abstract classes<\/h4>\n<p>Abstract classes let you define some behaviors; it makes them excellent candidates inside of application frameworks.<\/p>\n<p>Lets take example of <a title=\"HTTP servlet\" href=\"https:\/\/docs.oracle.com\/javaee\/1.3\/api\/javax\/servlet\/http\/HttpServlet.html\">HttpServlet<\/a>. It is the main class you must inherit if you are developing a web application using Servlets technology. As we know, each servlet has a definite life cycle phases, i.e. initialization, service, and destruction. What if each servlet we create, we have to write the same piece of code regarding initialization and destruction again and again. Surely, it will be a big pain.<\/p>\n<p>JDK designers solved this by making <code>HttpServlet<\/code> abstract class. It has all basic code already written for initialization of a servlet and destruction of it also. You only need to override certain methods where you write your application processing related code, that&#8217;s all. Make sense, right !!<\/p>\n<p>Can you add above feature using interface? No, even if you can, the design will be like a hell for most innocent programmers.<\/p>\n<h4>4.2. Contract only interfaces<\/h4>\n<p>Now, let&#8217;s look at the usage of interfaces.<strong>An interface only provide contracts and it is the responsibility of implementing classes to implement each and every single contract provided to it<\/strong>.<\/p>\n<p>An interface is the best fit for cases where you want to <strong>define only the characteristics of class<\/strong>, and you want to force all implementing entities to implement those characteristics.<\/p>\n<h4>4.3. Example<\/h4>\n<p>I would like to take an example of <code>Map<\/code> interface in the collections framework. It provides only rules, how a map should behave in practice. e.g. it should store the key-value pair, the value should be accessible using keys etc. These rules are in form of abstract methods in the interface.<\/p>\n<p>All implementing classes ( such as <a title=\"How hashmap works in java\" href=\"https:\/\/howtodoinjava.com\/java\/collections\/hashmap\/how-hashmap-works-in-java\/\">HashMap<\/a>, HashTable, TreeMap or <a title=\"WeakHashMap\" href=\"https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/util\/WeakHashMap.html\">WeakHashMap<\/a>) implements all methods differently and thus exhibit different  features from rest.<\/p>\n<p>Also, interfaces can be used in defining the separation of responsibilities. For example, <code>HashMap<\/code> implements 3 interfaces: <code>Map<\/code>, <a href=\"https:\/\/howtodoinjava.com\/java\/serialization\/java-serialization\/\">Serializable<\/a> and <a href=\"https:\/\/howtodoinjava.com\/java\/cloning\/cloneable-interface-is-broken-in-java\/\">Cloneable<\/a>. Each interface defines separate responsibilities and thus an implementing class choose what it want to implement, and so will provide that much limited functionality.<\/p>\n<p><a id=\"default-methods\"><\/a><\/p>\n<h2>5. Java 8 default methods in interfaces<\/h2>\n<p>With Java 8, now you can define methods in interfaces. These are called default methods. Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.<\/p>\n<p>As the name implies, default methods in Java 8 simply default. If you do not override them, they are the methods which will be invoked by caller classes. <\/p>\n<pre class=\"brush: java; title: Default methods; notranslate\" title=\"Default methods\">\r\npublic interface Moveable {\r\n    default void move(){\r\n        System.out.println(&amp;quot;I am moving&amp;quot;);\r\n    }\r\n}\r\n<\/pre>\n<p>In above example, <code>Moveable<\/code> interface defines a method <code>move()<\/code> and provided a default implementation as well. If any class implements this interface then it need not to implement it\u2019s own version of <code>move()<\/code> method. It can directly call <code>instance.move()<\/code>.<\/p>\n<pre class=\"brush: java; title: Animal.java; notranslate\" title=\"Animal.java\">\r\npublic class Animal implements Moveable{\r\n    public static void main(String[] args){\r\n        Animal tiger = new Animal();\r\n        tiger.move();\t\t\/\/I am moving\r\n    }\r\n}\r\n<\/pre>\n<p>And if class willingly wants to customize the behavior then it can provide its own custom implementation and override the method. Now it\u2019s own custom method will be called.<\/p>\n<pre class=\"brush: java; title: Animal.java; notranslate\" title=\"Animal.java\">\r\npublic class Animal implements Moveable{\r\n     \r\n    public void move(){\r\n        System.out.println(&amp;quot;I am running&amp;quot;);\r\n    }\r\n     \r\n    public static void main(String[] args){\r\n        Animal tiger = new Animal();\r\n        tiger.move();\t\t\/\/I am running\r\n    }\r\n}\r\n<\/pre>\n<h4>5.1) Difference between abstract class and interface in Java 8<\/h4>\n<p>If you see we are now able to provide a partial implementation with interfaces as well, just like abstract classes. So essentially the line between interfaces and abstract classes has become very thin. They provide almost the same capabilities now.<\/p>\n<p>Now, only one big difference remains that <strong>you cannot extend multiple classes whereas you can implement multiple interfaces<\/strong>. Apart from this difference, you can achieve any possible functionality from interfaces which abstract classes can make possible, and vice-versa is also true.<\/p>\n<p>Hope you found enough information on <strong>interfaces and abstract classes in java<\/strong>. <\/p>\n<p>Happy learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Learn about java abstract classes vs interfaces in details. Also learn about when to use interface and when to use abstract class in solving design issues.<\/p>\n","protected":false},"author":2,"featured_media":8453,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[30],"tags":[1454],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",427,200,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",150,70,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",300,141,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",427,200,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",427,200,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",427,200,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",427,200,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2012\/10\/Java-Abstract-Class-Vs-Interface.png",120,56,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":16,"uagb_excerpt":"Learn about java abstract classes vs interfaces in details. Also learn about when to use interface and when to use abstract class in solving design issues.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/98"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=98"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/98\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/8453"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=98"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=98"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=98"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}