{"id":21563,"date":"2022-06-26T23:49:29","date_gmt":"2022-06-26T18:19:29","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=21563"},"modified":"2022-06-26T23:49:30","modified_gmt":"2022-06-26T18:19:30","slug":"jmockit-tutorial","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/library\/jmockit-tutorial\/","title":{"rendered":"Complete Guide to Mocking with JMockit"},"content":{"rendered":"\n<p>Learn to create and inject mocks, creating expectations and verifications using <strong>JMockit<\/strong> library in JUnit tests. We will begin with the basic concepts of JMockit with an example, and later dig deeper into the advance concepts.<\/p>\n\n\n\t\t\t\t<div class=\"wp-block-uagb-table-of-contents uagb-toc__align-left uagb-toc__columns-1   uagb-block-eab11ce0 \" \n\t\t\t\t\tdata-scroll= \"1\"\n\t\t\t\t\tdata-offset= \"30\"\n\t\t\t\t\tdata-delay= \"800\"\n\t\t\t\t>\n\t\t\t\t<div class=\"uagb-toc__wrap\">\n\t\t\t\t\t<div class=\"uagb-toc__title-wrap\">\n\t\t\t\t\t\t<div class=\"uagb-toc__title\">\n\t\t\t\t\t\t\tTable Of Contents\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"uagb-toc__list-wrap\">\n\t\t\t\t\t\t<ol class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#1-jmockits-core-concepts\">1. JMockit&#8217;s Core Concepts<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#11-core-features\">1.1. Core Features<\/a><li class=\"uagb-toc__list\"><a href=\"#12-test-stages\">1.2. Test Stages<\/a><li class=\"uagb-toc__list\"><a href=\"#13-declarative-expectations-and-verifications\">1.3. Declarative Expectations and Verifications<\/a><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#2-a-simple-jmockit-test-example\">2. A Simple JMockit Test Example<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#21-maven-dependency\">2.1. Maven Dependency<\/a><li class=\"uagb-toc__list\"><a href=\"#22-system-under-test\">2.2. System Under Test<\/a><li class=\"uagb-toc__list\"><a href=\"#23-test-demo\">2.3. Test Demo<\/a><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#3-creating-and-injecting-mocks\">3. Creating and Injecting Mocks<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#31-mocking-related-annotations\">3.1. Mocking Related Annotations<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#311-mocked-and-capturing\">3.1.1. @Mocked and @Capturing<\/a><li class=\"uagb-toc__list\"><a href=\"#312-injectable-and-tested\">3.1.2. @Injectable and @Tested<\/a><\/li><\/ul><li class=\"uagb-toc__list\"><a href=\"#32-test-class-and-method-scoped-mocks\">3.2. Test Class and Method Scoped Mocks<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#4-recording-expectations\">4. Recording Expectations<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#41-matching-method-invocations\">4.1. Matching Method Invocations<\/a><li class=\"uagb-toc__list\"><a href=\"#42-matching-arguments\">4.2. Matching Arguments<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#421-any-fields\">4.2.1. any Fields<\/a><li class=\"uagb-toc__list\"><a href=\"#422-with-methods\">4.2.2. with Methods<\/a><\/li><\/ul><li class=\"uagb-toc__list\"><a href=\"#43-matching-return-values\">4.3. Matching Return Values<\/a><li class=\"uagb-toc__list\"><a href=\"#43-matching-invocation-count\">4.3. Matching Invocation Count<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#5-writing-verifications\">5. Writing Verifications<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#51-verifications\">5.1. Verifications<\/a><li class=\"uagb-toc__list\"><a href=\"#52-verificationsinorder\">5.2. VerificationsInOrder<\/a><li class=\"uagb-toc__list\"><a href=\"#53-fullverifications\">5.3. FullVerifications<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#6-conclusion\">6. Conclusion<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/ol>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\n\n\n<h2>1. JMockit&#8217;s Core Concepts<\/h2>\n\n\n\n<h3>1.1. Core Features<\/h3>\n\n\n\n<p><strong>JMockit is open-source software that contains support for mocking, faking, and integration testing, and a code coverage tool. <\/strong>It is used for mocking the external dependencies outside the test boundary, similar to <a href=\"https:\/\/howtodoinjava.com\/mockito\/junit-mockito-example\/\">Mockito<\/a> and other such <a href=\"https:\/\/howtodoinjava.com\/guides\/mock-testing-frameworks\/\">mocking libraries<\/a>.<\/p>\n\n\n\n<p>The most important feature of JMockit is that it lets us mock anything, even the things that are hard to mock with other libraries such as <em>private<\/em> methods, <em>constructors<\/em>, <em>static<\/em> and <em>final<\/em> methods. It even allows mocking the <em>member fields<\/em> and <em>initialization blocks<\/em> as well.<\/p>\n\n\n\n<h3>1.2. Test Stages<\/h3>\n\n\n\n<p>Similar to <a href=\"https:\/\/howtodoinjava.com\/java\/library\/easymock-tutorial\/\">EasyMock<\/a>, JMockit also uses the <strong>Record-Replay-Verify<\/strong> model in a test after the mocks and SUT (<strong>System Under Test<\/strong>) have been defined.<\/p>\n\n\n\n<ul><li><strong>Record<\/strong>: In this step, we <strong>record the expectations from the mock objects<\/strong>. We define the behavior of mock objects i.e. method to be invoked, the return value and how many times we expect it to be invoked.<\/li><li><strong>Replay<\/strong>: In this step, we <strong>execute the actual test code as written in SUT<\/strong> (<em>System Under Test<\/em>).<\/li><li><strong>Verify<\/strong>: In this step, we <strong>verify that all the expectations were executed or not<\/strong>.<\/li><\/ul>\n\n\n\n<p>A typical JMockit test will look like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public class TestClass {\r\n\r\n\t@Tested\r\n\tprivate Service service;\r\n\r\n\t@Injectable\r\n\tprivate Dao dao;\r\n\r\n\t@Mock\r\n\tprivate Component component;\r\n\r\n\t@Test\r\n\tpublic void testSUT() {\r\n\t   \/\/ Test data initialization, if any\r\n\r\n\t   new Expectations() {{ \r\n\t       \/\/ define expected behaviour for mocks and injectables\r\n\t   }};\r\n\r\n\t   \/\/ test service operations\r\n\r\n\t   new Verifications() {{ \r\n\t       \/\/ verify mocks and injectables\r\n\t   }};\r\n\r\n\t   \/\/ assertions\r\n\t}\t\r\n}<\/code><\/pre>\n\n\n\n<h3>1.3. Declarative Expectations and Verifications<\/h3>\n\n\n\n<p>JMockit allows defining the expectations and verifications in a very elaborative and declarative manner. These are very easy to distinguish from the rest of the test code.<\/p>\n\n\n\n<p>Other mocking libraries, in general, provide <code>static<\/code> methods such as <code>expect()<\/code>, <code>andThenReturn()<\/code> and <code>times()<\/code> to specify the expectations, and <code>verify()<\/code> for verifying the expectations after the test execution.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">MockAPI.expect(mock.method(argumentMatcher)).andThenReturn(value).times(1);<\/code><\/pre>\n\n\n\n<p>In contrast, JMockit expresses them using the following classes:<\/p>\n\n\n\n<ul><li><strong>Expectations<\/strong>: An <em>Expectations<\/em> block represents a set of invocations to a specific mocked method\/constructor that is relevant for a given test.<\/li><li><strong>Verifications<\/strong>: A regular unordered block to check that at least one matching invocation occurred during replay.<\/li><li><strong>VerificationsInOrder<\/strong>: It should be used when we want to test the actual relative order of invocations during the replay phase.<\/li><li><strong>FullVerfications<\/strong>: If we want to have all invocations to the mocked types\/instances involved in a test verified. It will make sure that no invocations are left unverified.<\/li><\/ul>\n\n\n\n<p>We will revisit these classes again later in this tutorial.<\/p>\n\n\n\n<h2>2. A Simple JMockit Test Example<\/h2>\n\n\n\n<h3>2.1. Maven Dependency<\/h3>\n\n\n\n<p>Start with including the JMockit dependency in the application. If not included already, add JUnit dependencies as well.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"xml\" class=\"language-xml\">&lt;dependency>\r\n    &lt;groupId>org.jmockit&lt;\/groupId>\r\n    &lt;artifactId>jmockit&lt;\/artifactId>\r\n    &lt;version>1.49&lt;\/version>\r\n&lt;\/dependency><\/code><\/pre>\n\n\n\n<h3>2.2. System Under Test<\/h3>\n\n\n\n<p>To demo the JMockit syntax, we have created a typical usecase where a <em>RecordService<\/em> invokes <em>RecordDao<\/em> to save a <em>Record<\/em>, and send a notification to using <em>NotificationService<\/em>. The <em>RecordService<\/em> uses a <em>SequenceGenerator<\/em> class to get the next record id.<\/p>\n\n\n\n<p>You can browse the code in the GitHub repository whose link is present at the end of this tutorial.<\/p>\n\n\n\n<h3>2.3. Test Demo<\/h3>\n\n\n\n<p>To test <em>RecordService.saveRecord()<\/em> method, we need to inject <em>RecordDao<\/em> and <em>SequenceGenerator<\/em> as dependencies in it. The <em>RecordService<\/em> gets <em>NotificationService<\/em> instance in runtime so we can simply mock it and let runtime replace it with a mock.<\/p>\n\n\n\n<p>Next, we will create some <em>Expectations<\/em>, execute the test code and, finally, execute <em>Verifications<\/em> to conclude the test. We can use additional <a href=\"https:\/\/howtodoinjava.com\/junit5\/junit-5-assertions-examples\/\">JUnit assertions<\/a> to verify additional test outcomes.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public class JMockitDemoTests {\r\n\r\n  @Injectable\r\n  RecordDao mockDao;\t\/\/ Dependency\r\n\r\n  @Injectable\r\n  SequenceGenerator mockGenerator; \/\/ Dependency\r\n\r\n  @Tested\r\n  RecordService service;\t\/\/System Under Test\r\n\r\n  \/\/ NotificationService can be mocked in test scope\r\n  @Test\r\n  public void testSaveRecord(@Mocked NotificationService notificationService) {\r\n\r\n    Record record = new Record();\r\n    record.setName(\"Test Record\");\r\n\r\n    \/\/Register Expectations\r\n    new Expectations() {{\r\n      mockGenerator.getNext();\r\n      result = 100L;\r\n      times = 1;\r\n    }};\r\n\r\n    new Expectations() {{\r\n      mockDao.saveRecord(record);\r\n      result = record;\r\n      times = 1;\r\n    }};\r\n\r\n    new Expectations() {{\r\n      notificationService.sendNotification(anyString);\r\n      result = true;\r\n      times = 1;\r\n    }};\r\n\r\n\r\n    \/\/Test code\r\n    Record savedRecord = service.saveRecord(record);\r\n\r\n    \/\/ Verifications\r\n    new Verifications() {{ \/\/ a \"verification block\"\r\n      mockGenerator.getNext();\r\n      times = 1;\r\n    }};\r\n\r\n    new Verifications() {{\r\n      mockDao.saveRecord(record);\r\n      times = 1;\r\n    }};\r\n\r\n    new Verifications() {{\r\n      notificationService.sendNotification(anyString);\r\n      times = 1;\r\n    }};\r\n\r\n    \/\/Additional assertions\r\n    assertEquals(\"Test Record\", savedRecord.getName());\r\n    assertEquals(100L, savedRecord.getId());\r\n  }\r\n}<\/code><\/pre>\n\n\n\n<h2>3. Creating and Injecting Mocks<\/h2>\n\n\n\n<p>It is worth remembering that JMockit allows having different mock objects in different phases on the <strong>record-replay-verify<\/strong> flow. For example, <strong>we can have two mocks for a dependency and use them separately in expectations and verifications<\/strong>.<\/p>\n\n\n\n<p>Differently from other mocking APIs, these mocked objects don&#8217;t have to be the ones used by the code under test when it calls instance methods on its dependencies.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">@Mocked Dependency mockDependency;\r\n\r\n@Test\r\npublic void testCase(@Mocked Dependency anotherMockDependency)\r\n{\r\n\tnew Expectations() {{ \r\n      mockDependency.operation();\r\n   }};\r\n\r\n   \/\/ Call the code under test\r\n\r\n   new Verifications() {{ \r\n      anotherMockDependency.operation();\r\n   }};\r\n}<\/code><\/pre>\n\n\n\n<p>JMockit allows different ways to create and inject mocks for SUT. Let&#8217;s learn about them.<\/p>\n\n\n\n<h3>3.1. Mocking Related Annotations<\/h3>\n\n\n\n<p>The primary annotations for mocking the dependencies are as follows.<\/p>\n\n\n\n<h4>3.1.1. @Mocked and @Capturing<\/h4>\n\n\n\n<p>When used on a field, <strong><em>@Mocked<\/em> will create mocked instances of each and every new object of that particular class<\/strong> during the test execution. Internally, it will mock all methods and constructors on all instances of a mocked class.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">@Mocked Dependency mockDependency;<\/code><\/pre>\n\n\n\n<p><code>@Capturing<\/code> behaves similar to <em>@Mocked<\/em>, but additionally, <strong><em>@Capturing<\/em> mocks every subclass extending<\/strong> or implementing the annotated field&#8217;s type.<\/p>\n\n\n\n<p>In the following example, JMockit will mock all the instances of <em>Dependency<\/em> as well as any subclasses of it. If <em>Dependency<\/em> is an interface then JMockit will mock all its implementing classes.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">@Capturing Dependency mockDependency;<\/code><\/pre>\n\n\n\n<p>Note that the <strong>mock fields annotated only with <em>@Mocked<\/em> or <em>@Capturing<\/em> are not considered for injection.<\/strong><\/p>\n\n\n\n<h4>3.1.2. @Injectable and @Tested<\/h4>\n\n\n\n<p>The <strong><em>@Tested<\/em> annotation triggers the automatic instantiation and injection of other mocks and injectables<\/strong>, just before the execution of a test method. An instance will be created using a suitable constructor of the tested class, while making sure its internal <em>@Injectable<\/em> dependencies get properly injected (when applicable).<\/p>\n\n\n\n<p>As opposed to <em>@Mocked<\/em> and <em>@Capturing<\/em>, <strong><em>@Injectable<\/em> creates only one mocked instance<\/strong>.<\/p>\n\n\n\n<p>Note that while initializing the tested classes, JMockit supports two forms of injection: i.e. <strong>constructor injection<\/strong> and <strong>field injection<\/strong>. <\/p>\n\n\n\n<p>In the following example, <em>dep1<\/em> and <em>dep2<\/em> will be injected into <em>SUT<\/em>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public class TestClass {\r\n\r\n   @Tested SUT tested;\r\n\r\n   @Injectable Dependency dep1;\r\n   @Injectable AnotherDependency dep2;\r\n}<\/code><\/pre>\n\n\n\n<h3>3.2. Test Class and Method Scoped Mocks<\/h3>\n\n\n\n<p>JMockit allows creating mocks at the class level as well as at the test method level by passing the mocks as test parameters.  Method level mocks help in creating a mock just for one test and thus help in further limiting the test boundaries.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public class TestClass {\r\n\r\n\t\/\/Class scoped mock\r\n  @Mocked Dependency mock;\r\n\r\n  \/\/Method scoped mock\r\n  @Test\r\n\tpublic void testCase(@Mocked AnotherDependency anotherMock)\r\n\t{\r\n\t\t\/\/test code\r\n\t}\r\n}<\/code><\/pre>\n\n\n\n<h2>4. Recording Expectations<\/h2>\n\n\n\n<h3>4.1. Matching Method Invocations<\/h3>\n\n\n\n<p>JMockit is very flexible in recording the expectations. We can record multiple method invocations in a single <em>Expectations<\/em> block and also, and we can record multiple <em>Expectations<\/em> blocks in a single test method.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public TestClass {\r\n\r\n\tnew Expectations() {{\r\n\t\tmock.method1();\r\n\t\tmock.method2();\r\n\t\tanotherMock.method3();\r\n\t}};\r\n\r\n\tnew Expectations() {{\r\n\t\tsomeOtherMock.method();\r\n\t}};\r\n}<\/code><\/pre>\n\n\n\n<h3>4.2. Matching Arguments<\/h3>\n\n\n\n<p>Using the exact arguments in method invocations will match the exact argument values in the replay phase. The <strong>object-type<\/strong> arguments are checked equal using the <code>equals()<\/code> method. Similarly, <strong>arrays<\/strong> and <strong>lists<\/strong> type arguments are treated as equals if both arrays or lists are of the same size and contain similar elements.<\/p>\n\n\n\n<p>For <em>flexible argument matching<\/em>, we can use one of the following two approaches:<\/p>\n\n\n\n<h4>4.2.1. <code>any<\/code> Fields<\/h4>\n\n\n\n<p>JMockit provides a range of <em>any<\/em> argument matching fields. They support one for each primitive type (and the corresponding wrapper class), one for strings, and one for all Objects.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">new Expectations() {{\r\n\r\n  mock.method1(anyInt);\r\n  mock.method2(anyString);\r\n  mock.method3(anyInt);\r\n  mock.method4((List&lt;?>) any);\r\n  mockDao.saveRecord((Record) any);\r\n}};<\/code><\/pre>\n\n\n\n<h4>4.2.2. <code>with<\/code> Methods<\/h4>\n\n\n\n<p>We can use a <em>withXYZ()<\/em> method from a range of such methods for specific usages. These methods are <em>withEqual()<\/em>, <em>withNotEqual()<\/em>, <em>withNull()<\/em>, <em>withNotNull()<\/em>, <em>withSubstring()<\/em>, <em>withPrefix()<\/em>, <em>withSuffix()<\/em>, <em>withMatch(regex)<\/em>, <em>withSameInstance()<\/em>, <em>withInstanceLike()<\/em> and <em>withInstanceOf()<\/em> etc.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">new Expectations() {{\r\n\r\n  mock.method1(withSubstring(\"xyz\"));\r\n  mock.method2(withSameInstance(record));\r\n  mock.method3(withAny(1L));\t\/\/Any long value will match\r\n  mock.method4((List&lt;?>) withNotNull());\r\n}};<\/code><\/pre>\n\n\n\n<h3>4.3. Matching Return Values<\/h3>\n\n\n\n<p>If <em>non-void<\/em> mock methods, we can record the return values in <code>result<\/code> field. The <strong>assignment to result should appear right after the invocation that identifies the recorded expectation<\/strong>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">new Expectations() {{\r\n\tmock.method1();\r\n\tresult = value1;\r\n\r\n\tmock.method2();\r\n\tresult = value2;\r\n}};<\/code><\/pre>\n\n\n\n<p>If we are invoking a method in a loop then we can expect <strong>multiple return values<\/strong> either using <em>returns(v1, v2, \u2026)<\/em> method or assigning a list of values to <em>result<\/em> field.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">new Expectations() {{\r\n\tmock.method();\r\n\treturns(value1, value2, value3);\r\n}};<\/code><\/pre>\n\n\n\n<p>If the test instead needs <strong>an exception or error to be thrown<\/strong> when the method is invoked, simply assign the desired throwable instance to <em>result<\/em>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">new Expectations() {{\r\n\r\n\tmock.method();\r\n\tresult = new ApplicationException();\r\n}};<\/code><\/pre>\n\n\n\n<h3>4.3. Matching Invocation Count<\/h3>\n\n\n\n<p>JMockit provides three special fields just matching the invocation counts. Any invocations less or more than the expected lower or upper limit, respectively, and the test execution will automatically fail.<\/p>\n\n\n\n<ul><li><code>times<\/code><\/li><li><code>minTimes<\/code><\/li><li><code>maxTimes<\/code><\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">new Expectations() {{\r\n\tmock.method();\r\n\tresult = value;\r\n\ttimes = 1;\r\n}};<\/code><\/pre>\n\n\n\n<h2>5. Writing Verifications<\/h2>\n\n\n\n<h3>5.1. <em>Verifications<\/em><\/h3>\n\n\n\n<p>Inside a <em>Verifications<\/em> blocks, we can <strong>use the same steps that are available in a <em>Expectations<\/em> blocks except for the return values and thrown exceptions<\/strong>. We can reuse the method invocations and count from the expectations.<\/p>\n\n\n\n<p>So, the syntax to write verifications is the same as expectations and you can refer to previous sections for the same.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">new Verifications() {{\r\n\tmock.method();\r\n\ttimes = 1;\r\n}};<\/code><\/pre>\n\n\n\n<h3>5.2. <em>VerificationsInOrder<\/em><\/h3>\n\n\n\n<p>As mentioned in section 1.3, this helps <strong>to test the actual relative order of invocations during the replay phase<\/strong>. Inside this block, simply write the invocations to one or more mocks in the order they are expected to have occurred.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">@Test\r\npublic void testCase() {\r\n\t\/\/Expectation\r\n\r\n\t\/\/Test code\r\n\tmock.firstInvokeThis();\r\n\tmock.thenInvokeThis();\r\n\tmock.finallyInvokeThis();\r\n\r\n\t\/\/Verification\r\n\tnew VerificationsInOrder() {{\r\n\t  mock.firstInvokeThis();\r\n\t  mock.thenInvokeThis();\r\n\t  mock.finallyInvokeThis();\r\n\t}};\r\n}<\/code><\/pre>\n\n\n\n<h3>5.3. FullVerifications<\/h3>\n\n\n\n<p>In the previous verification modes, JMockit verifies that all invocations in the Verifications block must be executed at least once during the test replay phase. It does not complain about those invocations that happened in the replay phase but were not added in the <em>Verifications<\/em> block.<\/p>\n\n\n\n<p>In the following example, <em>method3()<\/em> has been executed in the test but not verified in the verification phase. The test will PASS.<\/p>\n\n\n\n<pre title=\"Normal Verification - Test PASS\" class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">@Test\r\npublic void testCase() {\r\n\r\n\t\/\/Test code\r\n\tmock.method1();\r\n\tmock.method2();\r\n\tmock.method3();\r\n\r\n\t\/\/Verification\r\n\tnew VerificationsInOrder() {{\r\n\t\tmock.method1();\r\n\t\tmock.method2();\r\n\t}};\r\n}<\/code><\/pre>\n\n\n\n<p>If we want to take total control of the mock interactions then we can <em>FullVerifications<\/em>. It helps in preventing any method to be executed that we are not verifying.<\/p>\n\n\n\n<pre title=\"Full Verification\" class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">@Test\r\npublic void testCase() {\r\n\r\n\t\/\/Test code\r\n\tmock.method1();\r\n\tmock.method2();\r\n\tmock.method3();\r\n\r\n\t\/\/Verification\r\n\tnew FullVerifications() {{\r\n\t\tmock.method1();\r\n\t\tmock.method2();\r\n\t\tmock.method3();\t\t\/\/If we remove this, the test will FAIL\r\n\t}};\r\n}<\/code><\/pre>\n\n\n\n<h2>6. Conclusion<\/h2>\n\n\n\n<p>In this tutorial, we learned to use the mocking functionality provided by JMockit, in detail. We learned about the <em>record-replay-verify<\/em> phases in-depth and with examples.<\/p>\n\n\n\n<p>We also learned the advance concepts such as flexible argument matching and invocation counts.<\/p>\n\n\n\n<p>Happy Learning !!<\/p>\n\n\n\n<blockquote class=\"wp-block-quote is-style-default download\"><p><a href=\"https:\/\/github.com\/lokeshgupta1981\/Spring-Boot-Examples\/tree\/master\/Testing-Libraries\">Sourcecode on Github<\/a><\/p><\/blockquote>\n","protected":false},"excerpt":{"rendered":"<p>Learn to create and inject mocks, record expectations, verifications, and argument matching using the JMockit in JUnit tests with examples.<\/p>\n","protected":false},"author":2,"featured_media":20207,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[2],"tags":[1567,1471],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA.jpg",750,425,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA-150x150.jpg",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA-300x170.jpg",300,170,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA.jpg",750,425,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA.jpg",750,425,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA.jpg",750,425,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA.jpg",750,425,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/03\/JAVA-120x120.jpg",120,120,true]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"Learn to create and inject mocks, record expectations, verifications, and argument matching using the JMockit in JUnit tests with examples.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/21563"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=21563"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/21563\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/20207"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=21563"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=21563"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=21563"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}