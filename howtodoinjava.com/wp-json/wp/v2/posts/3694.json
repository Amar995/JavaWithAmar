{"id":3694,"date":"2014-03-29T20:24:44","date_gmt":"2014-03-29T14:54:44","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=3694"},"modified":"2020-12-26T00:52:24","modified_gmt":"2020-12-25T19:22:24","slug":"default-methods-in-java-8","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java8\/default-methods-in-java-8\/","title":{"rendered":"Java Default Methods Tutorial"},"content":{"rendered":"<p>In previous post, we learned about <strong><a href=\"https:\/\/howtodoinjava.com\/java8\/lambda-expressions\/\" title=\"Complete lambda expressions tutorial\">Lambda expressions and functional interfaces<\/a><\/strong>. Now, let&#8217;s move on the discussion and talk about another related feature i.e. <strong>default methods<\/strong>. Well, this is truly revolutionary for java developers. Till java 7, we have learned a lot of things about interfaces and all those things have been in our mind whenever we wrote code or designed the applications. Some of these concepts are going to change drastically from java 8, after introduction of default methods.<\/p>\n<pre>\r\n<strong>I will discuss following points in this post:<\/strong>\r\n\r\nWhat are default methods in java 8?\r\nWhy default methods were needed in java 8?\r\nHow conflicts are resolved while calling default methods?\r\n<\/pre>\n<h3>What are default methods in java 8?<\/h3>\n<div class=\"noticeboxesde bluenoticebox\"><br \/>\nDefault methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.<br \/>\n<\/div>\n<p>As name implies, default methods in java 8 are simply default. If you do not override them, they are the methods which will be invoked by caller classes. They are defined in interfaces.<\/p>\n<p>Let&#8217;s understand with an example:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic interface Moveable {\r\n    default void move(){\r\n        System.out.println(\"I am moving\");\r\n    }\r\n}\r\n<\/pre>\n<p>Moveable interface defines a method move(); and provided a default implementation as well. If any class implements this interface then it need not to implement it&#8217;s own version of move() method. It can directly call instance.move();<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class Animal implements Moveable{\r\n    public static void main(String[] args){\r\n        Animal tiger = new Animal();\r\n        tiger.move();\r\n    }\r\n}\r\n\r\nOutput: I am moving\r\n\r\n<\/pre>\n<p>And if class willingly wants to customize the behavior then it can provide it&#8217;s own custom implementation and override the method. Now it&#8217;s own custom method will be called.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class Animal implements Moveable{\r\n    \r\n    public void move(){\r\n        System.out.println(\"I am running\");\r\n    }\r\n    \r\n    public static void main(String[] args){\r\n        Animal tiger = new Animal();\r\n        tiger.move();\r\n    }\r\n}\r\n\r\nOutput: I am running\r\n<\/pre>\n<p>This is not all done here. Best part comes as following benefits:<\/p>\n<ol>\n<li>Static default methods: You can define static default methods in interface which will be available to all instances of class which implement this interface. This makes it easier for you to organize helper methods in your libraries; you can keep static methods specific to an interface in the same interface rather than in a separate class. This enables you to define methods out of your class and yet share with all child classes.<\/li>\n<li>They provide you an highly desired capability of adding a capability to number of classes without even touching their code. Simply add a default method in interface which they all implement.<\/li>\n<\/ol>\n<h3>Why default methods were needed in java 8?<\/h3>\n<p>This is a good candidate for your next <strong><a href=\"https:\/\/howtodoinjava.com\/java-interview-questions\/\" title=\"Java Interview Questions\">interview question<\/a><\/strong>. <strong>Simplest answer is to enable the functionality of lambda expression in java.<\/strong> Lambda expression are essentially of type of functional interface. To support lambda expressions seamlessly, all core classes have to be modified. But these core classes like java.util.List are implemented not only in JDK classes, but also in thousands of client code as well. Any incompatible change in core classes will back fire for sure and will not be accepted at all.<\/p>\n<p>Default methods break this deadlock and allow adding support for functional interface in core classes. Let&#8217;s see an example. Below is a method which has been added to java.lang.Iterable.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\ndefault void forEach(Consumer&lt;? super T&gt; action) {\r\n\tObjects.requireNonNull(action);\r\n\tfor (T t : this) {\r\n\t\taction.accept(t);\r\n\t}\r\n}\r\n<\/pre>\n<p>Before java 8, if you had to iterate on a java collection then your would get an iterator instance and call it&#8217;s next method until hasNext() returns false. This is common code and have been used thousands of time in day to day programming by us. Syntax is also always same. So can we make it compact so that it takes only single line of code and still do the job for us as before. Above function does that.<\/p>\n<p>Now to iterate and perform some simple operation on every item in list, all you need to do is:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class Animal implements Moveable{\r\n    public static void main(String[] args){\r\n        List&lt;Animal&gt; list = new ArrayList();\r\n        list.add(new Animal());\r\n        list.add(new Animal());\r\n        list.add(new Animal());\r\n        \r\n        \/\/Iterator code reduced to one line\r\n        list.forEach((Moveable p) -&gt; p.move());\r\n    }\r\n}\r\n<\/pre>\n<p>So here, an additional method has been added to List without breaking any custom implementations of it. It has been very desired feature in java since long. Now it&#8217;s with us.<\/p>\n<h3>How conflicts are resolved while calling default methods?<\/h3>\n<p>So far so good. We have got all basics well. Now move to complicated things. In java, a class can implement N number of interface. Additionally, a interface can also extend another interface as well. An if any default method is declared in two such interfaces which are implemented by single class. then obviously class will get confused which method to call.<\/p>\n<p><strong>Rules for this conflict resolution are as follows:<\/strong><\/p>\n<p><strong>1)<\/strong> Most preferred are the overridden methods in classes. They will be matched and called if found before matching anything.<br \/>\n<strong>2)<\/strong> The method with the same signature in the &#8220;most specific default-providing interface&#8221; is selected. This means if class Animal implements two interfaces i.e. Moveable and Walkable such that Walkable extends Moveable. Then Walkable is here most specific interface and default method will be chosen from here if method signature is matched.<br \/>\n<strong>3)<\/strong> If Moveable and Walkable are independent interfaces then a serious conflict condition happen, and compiler will complain then it is unable to decide. The you have to help compiler by providing extra info that from which interface the default method should be called. e.g.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n\tWalkable.super.move();\r\n\t\/\/or \r\n\tMoveable.super.move();\r\n<\/pre>\n<p>That&#8217;s all for this topic here. I will more on this next time when something interesting comes into my mind. DO not forget to drop your comments\/thoughts or questions.<\/p>\n<p><strong>Happy Learning !!<br \/>\n<\/strong><\/p>\n","protected":false},"excerpt":{"rendered":"<p>In previous post, we learned about Lambda expressions and functional interfaces. Now, let&#8217;s move on the discussion and talk about another related feature i.e. default methods. Well, this is truly revolutionary for java developers. Till java 7, we have learned a lot of things about interfaces and all those things have been in our mind &#8230; <a title=\"Java Default Methods Tutorial\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java8\/default-methods-in-java-8\/\" aria-label=\"More on Java Default Methods Tutorial\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[18],"tags":[577,1409],"uagb_featured_image_src":{"full":false,"thumbnail":false,"medium":false,"medium_large":false,"large":false,"1536x1536":false,"2048x2048":false,"yarpp-thumbnail":false},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":14,"uagb_excerpt":"In previous post, we learned about Lambda expressions and functional interfaces. Now, let&#8217;s move on the discussion and talk about another related feature i.e. default methods. Well, this is truly revolutionary for java developers. Till java 7, we have learned a lot of things about interfaces and all those things have been in our mind&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3694"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=3694"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3694\/revisions"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=3694"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=3694"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=3694"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}