{"id":13305,"date":"2020-05-18T23:23:51","date_gmt":"2020-05-18T17:53:51","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=13305"},"modified":"2021-08-22T13:41:57","modified_gmt":"2021-08-22T08:11:57","slug":"java14-new-features","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java14\/java14-new-features\/","title":{"rendered":"Java 14 &#8211; New Features and Improvements"},"content":{"rendered":"<p>Java 14 reached general availability on 17 March 2020. In this post, we will go through some features from the list of <strong>16 new features added in Java<\/strong> programming language. <\/p>\n<p>We can find the <a href=\"https:\/\/jdk.java.net\/14\/\" target=\"_blank\" rel=\"noopener noreferrer\">JDK 14 binaries here<\/a>.<\/p>\n<h2>1. JEP 305 &#8211; Pattern Matching for instanceof (Preview)<\/h2>\n<p>In Java 14, <code>instanceof<\/code> operator has been modified to have <strong>type test pattern<\/strong>. A type test pattern (used in <code>instanceof<\/code>) consists of a predicate that specifies a type, along with a single binding variable.<\/p>\n<p>In the code below, the phrase <code>String s<\/code> is the type test pattern:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nif (obj instanceof String s) {\r\n    \/\/ can use s here\r\n} else {\r\n    \/\/ can't use s here\r\n}\r\n<\/pre>\n<p>In above example, the <code>instanceof<\/code> operator \u201cmatches\u201d the target <code>obj<\/code> to the type test pattern if <code>obj<\/code> is an instance of <code>String<\/code>, then it is cast to <code>String<\/code> and assigned to the binding variable <code>s<\/code>.<\/p>\n<p>Note that the pattern will only match, and <code>s<\/code> will only be assigned, if <code>obj<\/code> is <strong>not null<\/strong>.<\/p>\n<blockquote><p>Read More : <a href=\"https:\/\/howtodoinjava.com\/java14\/pattern-matching-instanceof\/\">Java \u2013 Pattern Matching for instanceof<\/a>\n<\/p><\/blockquote>\n<h2>2. JEP 368 &#8211; Text Blocks (Second Preview)<\/h2>\n<p>In Java, a text block is a <strong>multi-line string literal<\/strong>. It means we do not need to get into mess of explicit line terminators, string concatenations, and delimiters otherwise used for writing the normal string literals.<\/p>\n<p>Text blocks comprise multiple lines of text and uses three double-quote characters (<code>\"\"\"<\/code>) as its opening and closing delimiter.<\/p>\n<p>The instance produced from a text block is of type <code>java.lang.String<\/code> with the same characteristics as a traditional double quoted string. This includes object representation and interning into <strong>string pool<\/strong>.<\/p>\n<p>Also, Text blocks can be used anywhere a string literal can be used. For example, we can use it for string concatenation.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nString string = &quot;Hello&quot;;\r\nString textBlock = &quot;&quot;&quot;\r\n                    World&quot;&quot;&quot;;\r\n \r\nString joinedString =  string + textBlock;\r\n \r\nSystem.out.println(joinedString);\r\n<\/pre>\n<blockquote><p>Read More : <a href=\"https:\/\/howtodoinjava.com\/java14\/java-text-blocks\/\">Java \u2013 Text blocks<\/a><\/p><\/blockquote>\n<h2>3. JEP 358 &#8211; Helpful NullPointerExceptions<\/h2>\n<p>Java 14 improves the usability of <code>NullPointerException<\/code> generated by the JVM by describing precisely which variable was <code>null<\/code>. <\/p>\n<p>First, we need to pass <code>-XX:+ShowCodeDetailsInExceptionMessages<\/code> JVM flag to enable this feature while running the application. Make sure, you are passing it.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class HelpfulNullPointerException \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n        Employee e = null;\r\n         \r\n        System.out.println(e.getName());\r\n    }\r\n}\r\n<\/pre>\n<pre class=\"brush: java; title: Console - Error message with improved details; notranslate\" title=\"Console - Error message with improved details\">\r\nException in thread &quot;main&quot; java.lang.NullPointerException: \r\n    Cannot invoke &quot;com.howtodoinjava.core.basic.Employee.getName()&quot; because &quot;e&quot; is null\r\n    at com.howtodoinjava.core.basic.HelpfulNullPointerException.main \r\n    (HelpfulNullPointerException.java:9)\r\n<\/pre>\n<p>Only NPEs that are created and thrown directly by the JVM will include the null-detail message (messages we generally pass in the constructor when we create the exception in the program). NPEs that are explicitly created and\/or explicitly thrown by programs running on the JVM are not subject to the bytecode analysis.<\/p>\n<blockquote><p>Read More : <a href=\"https:\/\/howtodoinjava.com\/java14\/helpful-nullpointerexception\/\">Java 14 \u2013 Helpful NullPointerException<\/a><\/p><\/blockquote>\n<h2>4. JEP 359 &#8211; Records (Preview)<\/h2>\n<p><code>record<\/code> type has been introduced as preview feature in Java 14 and shall be used as plain immutable data classes for data transfer between classes and applications.<\/p>\n<p>Like <code>enum<\/code>, record is also a special class type in Java. It is intended to be used in places where a class is created only to act as plain data carrier.<\/p>\n<p>The important difference between class and record is that a record aims to eliminate all the boilerplate code needed to set and get the data from instance. Records transfer this responsibility to java compiler which generates the constructor, field getters, hashCode() and equals() as well toString() methods.<\/p>\n<pre class=\"brush: java; title: Syntax; notranslate\" title=\"Syntax\">\r\npublic record EmployeeRecord(Long id, \r\n        String firstName, \r\n        String lastName, \r\n        String email, \r\n        int age) {\r\n     \r\n}\r\n<\/pre>\n<blockquote><p>Read More : <a href=\"https:\/\/howtodoinjava.com\/java14\/java-14-record-type\/\">Java 14 \u2013 record type<\/a><\/p><\/blockquote>\n<h2>5. JEP 361 &#8211; Switch Expressions (Standard)<\/h2>\n<p>A <strong>switch statement<\/strong> allows the application to have multiple possible execution paths based on the value of a given expression in runtime.<\/p>\n<p>In Java 14, with <strong>switch expression<\/strong>, the entire switch block \u201cgets a value\u201d that can then be assigned to a variable in same statement.<\/p>\n<p>It has the support of multiple case labels and using <code>yield<\/code> to return value in place of old <code>return<\/code> keyword.<\/p>\n<p>In case of <code>enum<\/code>, we can skip the <code>default<\/code> case. If there is any missing value not handled in cases, compiler will complain. In all other expression types (int, strings etc), we must provide <code>default<\/code> case as well.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic static Boolean isWeekDay (Day day) \r\n{\r\n    Boolean result = switch(day) {\r\n        case MON, TUE, WED, THUR, FRI -&gt;\r\n        { \r\n            System.out.println(&quot;It is WeekDay&quot;);\r\n            yield true; \r\n        }\r\n        case SAT, SUN -&gt;\r\n        { \r\n            System.out.println(&quot;It is Weekend&quot;);\r\n            yield false; \r\n        }\r\n    };\r\n    return result;\r\n}\r\n<\/pre>\n<blockquote><p>Read More : <a href=\"https:\/\/howtodoinjava.com\/java14\/switch-expressions\/\">Java 14 \u2013 switch expression<\/a><\/p><\/blockquote>\n<h2>6. More Features<\/h2>\n<h4>6.1. JEP 343 &#8211; Packaging Tool (Incubator)<\/h4>\n<p>With JDK 8, a tool called <code>javapackager<\/code> was released as part of the JavaFX kit. However, after JavaFX split from Java with the release of JDK 11, the popular <code>javapackager<\/code> was no longer available.<\/p>\n<p>This JEP create a simple packaging tool, based on the <code>javapackager<\/code> tool which supports native packaging formats to give end users a natural installation experience. These formats include msi and exe on Windows, pkg and dmg on macOS, and deb and rpm on Linux.<\/p>\n<p>The tool can be invoked directly, from the command line, or programmatically, via the <code>ToolProvider API<\/code>.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n$ jpackage --name myapp --input lib --main-jar main.jar\r\n<\/pre>\n<h4>6.2. JEP 345 &#8211; NUMA-Aware Memory Allocation for G1<\/h4>\n<p>In Numa (Non-Uniform Memory Access) memory architecture, each processor core receives a small amount of local memory, but the other cores are granted access to it.<\/p>\n<p>The parallel garbage collector, enabled by <strong>-XX:+UseParallelGC<\/strong>, has been NUMA-aware for many years and has improving the performance of configurations that run a single JVM across multiple sockets.<\/p>\n<p>With this JEP, G1 garbage collector has been enhanced for better memory management under Linux OS.<\/p>\n<h4>6.3. JEP 349 &#8211; JFR Event Streaming<\/h4>\n<p>This JEP exposes JDK Flight Recorder data for continuous monitoring, both for in-process and out-of-process applications.<\/p>\n<p>To consume the data today, a user must start a recording, stop it, dump the contents to disk and then parse the recording file. This works well for application profiling, where typically at least a minute of data is being recorded at a time, but not for monitoring purposes.<\/p>\n<p>The package <code>jdk.jfr.consumer<\/code>, in module <code>jdk.jfr<\/code>, is extended with functionality to subscribe to events asynchronously. Users can read recording data directly, or stream, from the disk repository without dumping a recording file. <\/p>\n<h4>6.4. JEP 352 &#8211; Non-Volatile Mapped Byte Buffers<\/h4>\n<p>This JEP adds a new JDK-specific file mapping modes so that the <code>FileChannel<\/code> API can be used to create <code>MappedByteBuffer<\/code> instances that refer to NVM (non-volatile memory). NVM is also known as persistent memory and is used to store data permanently. <\/p>\n<p>Recent changes to the <code>MappedByteBufer<\/code> API mean that it supports all the behaviours needed to allow direct memory updates and provide the durability guarantees needed for higher level, Java client libraries to implement persistent data types (e.g. block file systems, journaled logs, persistent objects, etc.).<\/p>\n<h4>6.5. JEP 363 &#8211; Remove the Concurrent Mark Sweep (CMS) Garbage Collector<\/h4>\n<p>This JEP aims to remove the CMS garbage collector after it was marked as deprecated in Java 9 (JEP 291). Interested users had two years to take care of the project and maintain it but it didn&#8217;t happened. <\/p>\n<p>So now, CMS GC has been removed from Java 14. Note that CMS garbage collector has not been removed from prior releases and will be available till Java 13.<\/p>\n<h4>6.6. JEP 367 &#8211; Remove the Pack200 Tools and API<\/h4>\n<p>Remove the pack200 and unpack200 tools, and the <code>Pack200<\/code> API (compression scheme for JAR files introduced in Java SE 5.0) in the <code>java.util.jar<\/code> package. These tools and API were deprecated for removal in Java SE 11 with the express intent to remove them in a future release.<\/p>\n<h4>6.7. JEP 370 &#8211; Foreign-Memory Access API (Incubator)<\/h4>\n<p>With this JEP, Java provides an API to allow Java programs to safely and efficiently access foreign memory outside of the Java heap.<\/p>\n<p>Thegoal is that the same API should be able to operate on various kinds of foreign memory (e.g., native memory, persistent memory, managed heap memory, etc.).<\/p>\n<p>It should not be possible for the API to undermine the safety of the JVM, regardless of the kind of memory being operated upon. Also, memory deallocation operations should be explicit in the source code.<\/p>\n<p>Drop me your questions in comments related to <strong>Java 14 new features<\/strong>.<\/p>\n<p>Happy Learning !!<\/p>\n<p>Reference : <a href=\"https:\/\/openjdk.java.net\/projects\/jdk\/14\/\" target=\"_blank\" rel=\"noopener noreferrer\">Java 14 Release<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Java 14 reached general availability on 17 March 2020. In this post, we will go through some features from the list of 16 new features added in Java programming language. We can find the JDK 14 binaries here. 1. JEP 305 &#8211; Pattern Matching for instanceof (Preview) In Java 14, instanceof operator has been modified &#8230; <a title=\"Java 14 &#8211; New Features and Improvements\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java14\/java14-new-features\/\" aria-label=\"More on Java 14 &#8211; New Features and Improvements\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":13289,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[1295],"tags":[1435],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14-150x150.png",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14-300x169.png",300,169,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14-768x432.png",768,432,true],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",120,68,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"Java 14 reached general availability on 17 March 2020. In this post, we will go through some features from the list of 16 new features added in Java programming language. We can find the JDK 14 binaries here. 1. JEP 305 &#8211; Pattern Matching for instanceof (Preview) In Java 14, instanceof operator has been modified&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/13305"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=13305"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/13305\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/13289"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=13305"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=13305"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=13305"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}