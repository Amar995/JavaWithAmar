{"id":3991,"date":"2014-06-26T11:07:54","date_gmt":"2014-06-26T11:07:54","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=3991"},"modified":"2020-12-26T00:49:47","modified_gmt":"2020-12-25T19:19:47","slug":"complete-java-generics-tutorial","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/","title":{"rendered":"Java Generics Tutorial"},"content":{"rendered":"<p><a title=\"generics\" href=\"https:\/\/docs.oracle.com\/javase\/tutorial\/extra\/generics\/\" target=\"_blank\" rel=\"noopener noreferrer\">Generics<\/a> in java were introduced as one of features in JDK 5. Personally, I find the angular brackets &#8220;<>&#8221; used in generics very fascinating and it always forces me to have another thought where I use it OR see it written in somebody else&#8217;s code. To be very frank, I have been using generics since a long time now but still I feel not fully confident to use it blindly. In this tutorial, I will be covering everything I find useful with <strong>java generics<\/strong>, and things related to them. If you think that I can use more precise words at any part of the tutorial, or an example can be added or simply you do not agree with me; drop me a comment. I will be glad to know your point of view.<\/p>\n<pre>Table of content\r\n\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#why_generics\">1) Why Generics?<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#how_generics_work\">2) How Generics works in Java<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#generic_types\">3) Types of Generics?<\/a>\r\n   <a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#member_types\">i)  Generic Type Class or Interface<\/a>\r\n   <a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#method_types\">ii) Generic Type Method or Constructor<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#generic_arrays\">4) Generic Type Arrays<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#wildcards\">5) Generics with Wildcards<\/a>\r\n    <a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#unbounded_wildcards\">i)  Unbounded Wildcards<\/a>\r\n    <a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#bounded_wildcards\">ii)  Bounded Wildcards<\/a>\r\n        <a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#lower_bounded\">a)  Upper Bounded Wildcards<\/a>\r\n        <a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#upper_bounded\">b)  Lower Bounded Wildcards<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/#things_not_allowed\">6) What is not allowed to do with Generics?<\/a>\r\n<\/pre>\n<p>&#8220;<strong>Java Generics<\/strong>&#8221; is a technical term denoting a set of language features related to the definition and use of generic types and methods . In java, Generic types or methods differ from regular types and methods in that they have type parameters.<\/p>\n<blockquote><p>&#8220;Java Generics are a language feature that allows for definition and use of generic types and methods.&#8221;<\/p><\/blockquote>\n<p>Generic types are instantiated to form parameterized types by providing actual type arguments that replace the formal type parameters. A class like <code>LinkedList&lt;E&gt;<\/code> is a generic type, that has a type parameter E . Instantiations, such as <code>LinkedList&lt;Integer&gt;<\/code> or a <code>LinkedList&lt;String&gt;<\/code>, are called parameterized types, and String and Integer are the respective actual type arguments.<\/p>\n<p><a name=\"why_generics\"><\/a><\/p>\n<h3>1) Why Generics?<\/h3>\n<p>If you closely look at <a title=\"Useful java collection interview questions\" href=\"https:\/\/howtodoinjava.com\/java\/collections\/useful-java-collection-interview-questions\/\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>java collection framework<\/strong><\/a> classes then you will observe that most classes take parameter\/argument of type <code>Object<\/code> and return values from methods as <code>Object<\/code>. Now, in this form, they can take any java type as argument and return the same. They are essentially heterogeneous i.e. not of a particular similar type.<\/p>\n<p>Programmers like us often wanted to specify that a collection contains elements only of a certain type e.g. <code>Integer<\/code> or <code>String<\/code> or <code>Employee<\/code>. In the original collection framework, having homogeneous collections was not possible without adding extra checks before adding some checks in code. Generics were introduced to remove this limitation to be very specific. They add this type checking of parameters in your code at compile-time, automatically. This saves us writing a lot of unnecessary code which actually does not add any value in run-time if written correctly.<\/p>\n<blockquote><p>&#8220;In layman,s term, generics force type safety in java language.&#8221;<\/p><\/blockquote>\n<p>Without this type of safety, your code could have infected by various bugs that get revealed only in runtime. Using generics, makes them highlighted in compile time itself and make you code robust even before you get the bytecode of your java source code files.<\/p>\n<blockquote><p>&#8220;Generics add stability to your code by making more of your bugs detectable at compile time.&#8221;<\/p><\/blockquote>\n<p>So now we have a fair idea of why generics are present in java in the first place. The next step is to get some knowledge about how they work in java. What actually happens when you use generics in your source code.<\/p>\n<p><a name=\"how_generics_work\"><\/a><\/p>\n<h3>2) How Generics works in Java<\/h3>\n<p>In the heart of generics is &#8220;<a title=\"type safety\" href=\"https:\/\/en.wikipedia.org\/wiki\/Type_safety\" target=\"_blank\" rel=\"noopener noreferrer\"><strong>type safety<\/strong><\/a>&#8220;. What exactly is type safety? It\u2019s just a guarantee by compiler that if correct Types are used in correct places then there should not be any <code>ClassCastException<\/code> in runtime. A usecase can be list of <code>Integer<\/code> i.e. <code>List&lt;Integer&gt;<\/code>. If you declare a list in java like <code>List&lt;Integer&gt;<\/code>, then java guarantees that it will detect and report you any attempt to insert any non-integer type into above list.<\/p>\n<p>Another important term in java generics is &#8220;<a title=\"type erasure\" href=\"https:\/\/en.wikipedia.org\/wiki\/Type_erasure\" target=\"_blank\" rel=\"noopener no-referrer noreferrer\"><strong>type erasure<\/strong><\/a>&#8220;. It essentially means that all the extra information added using generics into source code will be removed from bytecode generated from it. Inside bytecode, it will be old java syntax which you will get if you don&#8217;t use generics at all. This necessarily helps in generating and executing code written prior to java 5 when generics were not added in language.<\/p>\n<p>Let&#8217;s understand with an example.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\r\n\r\nlist.add(1000);     \/\/works fine\r\n\r\nlist.add(&quot;lokesh&quot;); \/\/compile time error; \r\n<\/pre>\n<p>When you write above code and compile it, you will get below error: &#8220;<em>The method add(Integer) in the type <code>List&lt;Integer&gt;<\/code> is not applicable for the arguments (String)<\/em>&#8220;. The compiler warned you. This exactly is generics sole purpose i.e. Type Safety.<\/p>\n<p>The second part is getting the byte code after removing the second line from the above example. If you compare the bytecode of the above example with\/without generics, then there will not be any different. Clearly compiler removed all generics information. So, the above code is very much similar to the below code without generics.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nList list = new ArrayList();\r\n\r\nlist.add(1000);     \r\n<\/pre>\n<blockquote><p>&#8220;Precisely, Generics in Java is nothing but a syntactic sugar to your code for Type Safety and all such type information is erased by Type Erasure feature by the compiler.&#8221;<\/p><\/blockquote>\n<p><a name=\"generic_types\"><\/a><\/p>\n<h3>3) Types of Generics?<\/h3>\n<p>Now we have some understanding of what generics are all about. Now start exploring other important concepts revolving around generics. I will start by identifying the various ways, generics can be applied into sourcecode.<\/p>\n<p><a name=\"member_types\"><\/a><\/p>\n<h4>Generic Type Class or Interface<\/h4>\n<p>A class is generic if it declares one or more type variables. These type variables are known as the type parameters of the class. Let&#8217;s understand with an example.<\/p>\n<p><code>DemoClass<\/code> is a simple java class, which has one property <code>t<\/code> (can be more than one also); and type of property is Object.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nclass DemoClass {\r\n   private Object t;\r\n\r\n   public void set(Object t) { this.t = t; }\r\n   \r\n   public Object get() { return t; }\r\n}\r\n<\/pre>\n<p>Here we want that once initialized the class with a certain type, class should be used with that particular type only. e.g. If we want one instance of class to hold value t of type &#8216;<code>String<\/code>&#8216;, then programmer should set and get the only <code>String<\/code> type. Since we have declared property type to <code>Object<\/code>, there is no way to enforce this restriction. A programmer can set any object, and can expect any return value type from get method since all java types are subtypes of <code>Object<\/code> class.<\/p>\n<p>To enforce this type restriction, we can use generics as below:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nclass DemoClass&lt;T&gt; {\r\n   \/\/T stands for &quot;Type&quot;\r\n   private T t;\r\n\r\n   public void set(T t) { this.t = t; }\r\n   \r\n   public T get() { return t; }\r\n}\r\n<\/pre>\n<p>Now we can be assured that class will not be misused with wrong types. A sample usage of <code>DemoClass<\/code> will look like this:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nDemoClass&lt;String&gt; instance = new DemoClass&lt;String&gt;();\r\ninstance.set(&quot;lokesh&quot;);   \/\/Correct usage\r\ninstance.set(1);        \/\/This will raise compile time error\r\n<\/pre>\n<p>The above analogy is true for the interfaces as well. Let&#8217;s quickly look at an example to understand, how generics type information can be used in interfaces in java.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n\/\/Generic interface definition\r\ninterface DemoInterface&lt;T1, T2&gt; \r\n{\r\n   T2 doSomeOperation(T1 t);\r\n   T1 doReverseOperation(T2 t);\r\n}\r\n\r\n\/\/A class implementing generic interface\r\nclass DemoClass implements DemoInterface&lt;String, Integer&gt;\r\n{\r\n   public Integer doSomeOperation(String t)\r\n   {\r\n      \/\/some code\r\n   }\r\n   public String doReverseOperation(Integer t)\r\n   {\r\n      \/\/some code\r\n   }\r\n}\r\n<\/pre>\n<p>I hope, I was enough clear to put some light on generic classes and interfaces. Now it&#8217;s time to look at generic methods and constructors.<\/p>\n<p><a name=\"method_types\"><\/a><\/p>\n<h4>Generic Type Method or Constructor<\/h4>\n<p>Generic methods are much similar to generic classes. They are different only in one aspect that the scope of type information is only inside the method (or constructor). Generic methods are methods that introduce their own type parameters.<\/p>\n<p>Let&#8217;s understand this with an example. Below is a code sample of a generic method that can be used to find all occurrences of a type parameter in a list of variables of that type only.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic static &lt;T&gt; int countAllOccurrences(T[] list, T item) {\r\n   int count = 0;\r\n   if (item == null) {\r\n      for ( T listItem : list )\r\n         if (listItem == null)\r\n            count++;\r\n   }\r\n   else {\r\n      for ( T listItem : list )\r\n         if (item.equals(listItem))\r\n            count++;\r\n   }\r\n   return count;\r\n}   \r\n<\/pre>\n<p>If you pass a list of <code>String<\/code> and another string to search in this method, it will work fine. But if you will try to find an <code>Number<\/code> into list of <code>String<\/code>, it will give compile-time error.<\/p>\n<p>The same as above can be an example of a generic constructor. Let&#8217;s take a separate example for a generic constructor as well.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nclass Dimension&lt;T&gt;\r\n{\r\n   private T length;\r\n   private T width;\r\n   private T height;\r\n\r\n   \/\/Generic constructor\r\n   public Dimension(T length, T width, T height)\r\n   {\r\n      super();\r\n      this.length = length;\r\n      this.width = width;\r\n      this.height = height;\r\n   }\r\n}\r\n<\/pre>\n<p>In this example, <code>Dimension<\/code> class&#8217;s constructor has the type information also. So you can have an instance of dimension with all attributes of a single type only.<\/p>\n<p><a name=\"generic_arrays\"><\/a><\/p>\n<h3>4) Generic Type Arrays<\/h3>\n<p>Array in any language have same meaning i.e. an array is a collection of similar type of elements. In java, pushing any incompatible type in an array on runtime will throw <code>ArrayStoreException<\/code>. It means array preserve their type information in runtime, and generics use type erasure or remove any type of information in runtime. Due to the above conflict, instantiating a generic array in java is not permitted.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class GenericArray&lt;T&gt; {\r\n    \/\/ this one is fine\r\n    public T[] notYetInstantiatedArray;\r\n \r\n    \/\/ causes compiler error; Cannot create a generic array of T\r\n    public T[] array = new T[5];\r\n}\r\n<\/pre>\n<p>In the same line as above generic type classes and methods, we can have generic arrays in java. As we know that an array is a collection of similar type of elements and pushing any incompatible type will throw <code>ArrayStoreException<\/code> in runtime; which is not the case with <code>Collection<\/code> classes.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nObject[] array = new String[10];\r\narray[0] = &quot;lokesh&quot;;\r\narray[1] = 10;      \/\/This will throw ArrayStoreException\r\n<\/pre>\n<p>The above mistake is not very hard to make. It can happen anytime. So it&#8217;s better to provide the type information to array also so that error is caught at compile time itself.<\/p>\n<p>Another reason why arrays do not support generics is that arrays are covariant, which means that an array of supertype references is a supertype of an array of subtype references. That is, <code>Object[]<\/code> is a supertype of <code>String[]<\/code> and a string array can be accessed through a reference variable of type <code>Object[]<\/code>.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nObject[] objArr = new String[10];  \/\/ fine\r\nobjArr[0] = new String(); \r\n<\/pre>\n<p><a name=\"wildcards\"><\/a><\/p>\n<h3>5) Generics with Wildcards<\/h3>\n<p>In generic code, the question mark (?), called the wildcard, represents an unknown type. <strong>A wildcard parameterized type is an instantiation of a generic type where at least one type argument is a wildcard.<\/strong> Examples of wildcard parameterized types are <code>Collection&lt;?&lt;<\/code>, <code>List&lt;? extends Number&lt;<\/code>, <code>Comparator&lt;? super String&gt;<\/code> and <code>Pair&lt;String,?&gt;<\/code>. The wildcard can be used in a variety of situations: as the type of a parameter, field, or local variable; sometimes as a return type (though it is better programming practice to be more specific). The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype.<\/p>\n<p>Having wild cards at difference places have different meanings as well. e.g.<\/p>\n<ul>\n<li><strong>Collection<?><\/strong> denotes all instantiations of the Collection interface regardless of the type argument.<\/li>\n<li><strong>List<? extends Number><\/strong> denotes all list types where the element type is a subtype of Number.<\/li>\n<li><strong><code>Comparator&lt;? super String&lt;<\/code><\/strong> denotes all instantiations of the Comparator interface for type argument types that are supertypes of String.<\/li>\n<\/ul>\n<p>A wildcard parameterized type is not a concrete type that could appear in a new expression. It just hints the rule enforced by java generics that which types are valid in any particular scenario where wild cards have been used.<\/p>\n<p>For example, below are valid declarations involving wild cards:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nCollection&lt;?&gt; coll = new ArrayList&lt;String&gt;(); \r\n\/\/OR\r\nList&lt;? extends Number&gt; list = new ArrayList&lt;Long&gt;(); \r\n\/\/OR\r\nPair&lt;String,?&gt; pair = new Pair&lt;String,Integer&gt;();\r\n<\/pre>\n<p>And below are not valid uses of wildcards, and they will give compile-time error.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nList&lt;? extends Number&gt; list = new ArrayList&lt;String&gt;();  \/\/String is not subclass of Number; so error\r\n\/\/OR\r\nComparator&lt;? super String&gt; cmp = new RuleBasedCollator(new Integer(100)); \/\/Integer is not superclass of String\r\n<\/pre>\n<p>Wildcards in generics can be unbounded as well as bounded. Let&#8217;s identify the difference in various terms.<\/p>\n<p><a name=\"unbounded_wildcards\"><\/a><\/p>\n<h4>Unbounded wildcard parameterized type<\/h4>\n<p>A generic type where all type arguments are the unbounded wildcard <code>\"?<\/code>&#8221; without any restriction on type variables. e.g.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nArrayList&lt;?&gt;  list = new ArrayList&lt;Long&gt;();  \r\n\/\/or\r\nArrayList&lt;?&gt;  list = new ArrayList&lt;String&gt;();  \r\n\/\/or\r\nArrayList&lt;?&gt;  list = new ArrayList&lt;Employee&gt;();  \r\n<\/pre>\n<p><a name=\"bounded_wildcards\"><\/a><\/p>\n<h4>Bounded wildcard parameterized type<\/h4>\n<p>Bounded wildcards put some restrictions over possible types, you can use to instantiate a parametrized type. This restriction is enforced using keywords &#8220;super&#8221; and &#8220;extends&#8221;. To differentiate more clearly, let&#8217;s divide them into upper bounded wildcards and lower bounded wildcards.<\/p>\n<p><a name=\"upper_bounded\"><\/a><\/p>\n<h5>Upper bounded wildcards<\/h5>\n<p>For example, say you want to write a method that works on List&lt;String&gt;, List&lt;Integer&gt;, and List&lt;double&gt; you can achieve this by using an upper bounded wildcard e.g. you would specify List&lt;? extends Number&gt;. Here Integer, Double are subtypes of Number class. In layman&#8217;s terms, if you want the generic expression to accept all subclasses of a particular type, you will use upper bound wildcard using &#8220;<strong>extends<\/strong>&#8221; keyword.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class GenericsExample&lt;T&gt;\r\n{\r\n   public static void main(String[] args)\r\n   {\r\n      \/\/List of Integers\r\n      List&lt;Integer&gt; ints = Arrays.asList(1,2,3,4,5);\r\n      System.out.println(sum(ints));\r\n      \r\n      \/\/List of Doubles\r\n      List&lt;Double&gt; doubles = Arrays.asList(1.5d,2d,3d);\r\n      System.out.println(sum(doubles));\r\n      \r\n      List&lt;String&gt; strings = Arrays.asList(&quot;1&quot;,&quot;2&quot;);\r\n      \/\/This will give compilation error as :: The method sum(List&lt;? extends Number&gt;) in the \r\n      \/\/type GenericsExample&lt;T&gt; is not applicable for the arguments (List&lt;String&gt;)\r\n      System.out.println(sum(strings));\r\n      \r\n   }\r\n   \r\n   \/\/Method will accept \r\n   private static Number sum (List&lt;? extends Number&gt; numbers){\r\n      double s = 0.0;\r\n      for (Number n : numbers)\r\n         s += n.doubleValue();\r\n      return s;\r\n   }\r\n}\r\n<\/pre>\n<p><a name=\"lower_bounded\"><\/a><\/p>\n<h5>Lower bounded wildcards<\/h5>\n<p>If you want a generic expression to accept all types which are &#8220;super&#8221; type of a particular type OR parent class of a particular class then you will use a lower bound wildcard for this purpose, using &#8216;super&#8217; keyword.<\/p>\n<p>In below given example, I have created three classes i.e. <code>SuperClass<\/code>, <code>ChildClass<\/code> and <code>GrandChildClass<\/code>. There relationship is shown in code below. Now, we have to create a method which somehow get a <code>GrandChildClass<\/code> information (e.g. from DB) and create an instance of it. And we want to store this new <code>GrandChildClass<\/code> in an already existing list of <code>GrandChildClasses<\/code>.<\/p>\n<p>Here problem is that <code>GrandChildClass<\/code> is subtype of <code>ChildClass<\/code> and <code>SuperClass<\/code> as well. So any generic list of SuperClasses and ChildClasses is capable of holding GrandChildClasses as well. Here we must take help of lower bound wildcard using &#8216;<strong>super<\/strong>&#8216; keyword.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npackage test.core;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class GenericsExample&lt;T&gt;\r\n{\r\n   public static void main(String[] args)\r\n   {\r\n      \/\/List of grand children\r\n      List&lt;GrandChildClass&gt; grandChildren = new ArrayList&lt;GrandChildClass&gt;();\r\n      grandChildren.add(new GrandChildClass());\r\n      addGrandChildren(grandChildren);\r\n      \r\n      \/\/List of grand childs\r\n      List&lt;ChildClass&gt; childs = new ArrayList&lt;ChildClass&gt;();\r\n      childs.add(new GrandChildClass());\r\n      addGrandChildren(childs);\r\n      \r\n      \/\/List of grand supers\r\n      List&lt;SuperClass&gt; supers = new ArrayList&lt;SuperClass&gt;();\r\n      supers.add(new GrandChildClass());\r\n      addGrandChildren(supers);\r\n   }\r\n   \r\n   public static void addGrandChildren(List&lt;? super GrandChildClass&gt; grandChildren) \r\n   {\r\n      grandChildren.add(new GrandChildClass());\r\n      System.out.println(grandChildren);\r\n   }\r\n}\r\n\r\nclass SuperClass{\r\n   \r\n}\r\nclass ChildClass extends SuperClass{\r\n   \r\n}\r\nclass GrandChildClass extends ChildClass{\r\n   \r\n}\r\n<\/pre>\n<p><a name=\"things_not_allowed\"><\/a><\/p>\n<h3>6) What is not allowed to do with Generics?<\/h3>\n<p>So far we have learned about a number of things which you can do with generics in java to avoid many <code>ClassCastException<\/code> instances in your application. We also saw the usage of wildcards as well. Now it&#8217;s time to identify some tasks which are not allowed to do in java generics.<\/p>\n<h4>a) You can&#8217;t have static field of type<\/h4>\n<p>You can not define a static generic parameterized member in your class. Any attempt to do so will generate compile-time error: Cannot make a static reference to the non-static type T.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class GenericsExample&lt;T&gt;\r\n{\r\n   private static T member; \/\/This is not allowed\r\n}\r\n<\/pre>\n<h4>b) You can not create an instance of T<\/h4>\n<p>Any attempt to create an instance of T will fail with error: Cannot instantiate the type T.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class GenericsExample&lt;T&gt;\r\n{\r\n   public GenericsExample(){\r\n      new T();\r\n   }\r\n}\r\n<\/pre>\n<h4>c) Generics are not compatible with primitives in declarations<\/h4>\n<p>Yes, it&#8217;s true. You can&#8217;t declare generic expression like List or Map&lt;String, double&gt;. Definitely you can use the wrapper classes in place of primitives and then use primitives when passing the actual values. These value primitives are accepted by using auto-boxing to convert primitives to respective wrapper classes.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nfinal List&lt;int&gt; ids = new ArrayList&lt;&gt;();    \/\/Not allowed\r\n\r\nfinal List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); \/\/Allowed\r\n<\/pre>\n<h4>d) You can&#8217;t create Generic exception class<\/h4>\n<p>Sometimes, the programmer might be in need of passing an instance of generic type along with exception being thrown. This is not possible to do in Java.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n\/\/ causes compiler error\r\npublic class GenericException&lt;T&gt; extends Exception {}\r\n<\/pre>\n<p>When you try to create such an exception, you will end up with message like this: The generic class <code>GenericException<\/code> may not subclass <code>java.lang.Throwable<\/code>.<\/p>\n<p>That&#8217;s all for now closing the discussion on <strong>java generics<\/strong> this time. I will come up with more interesting facts and features related to generics in the coming posts.<\/p>\n<p>Drop me a comment if something is unclear \/OR you have any other questions.<\/p>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Generics in java were introduced as one of features in JDK 5. Personally, I find the angular brackets &#8220;&#8221; used in generics very fascinating and it always forces me to have another thought where I use it OR see it written in somebody else&#8217;s code. To be very frank, I have been using generics since &#8230; <a title=\"Java Generics Tutorial\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java\/generics\/complete-java-generics-tutorial\/\" aria-label=\"More on Java Generics Tutorial\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":13289,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[787],"tags":[10],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14-150x150.png",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14-300x169.png",300,169,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14-768x432.png",768,432,true],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",1024,576,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2020\/05\/Java-14.png",120,68,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":29,"uagb_excerpt":"Generics in java were introduced as one of features in JDK 5. Personally, I find the angular brackets &#8220;&#8221; used in generics very fascinating and it always forces me to have another thought where I use it OR see it written in somebody else&#8217;s code. To be very frank, I have been using generics since&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3991"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=3991"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3991\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/13289"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=3991"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=3991"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=3991"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}