{"id":12538,"date":"2019-05-15T21:35:29","date_gmt":"2019-05-15T16:05:29","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=12538"},"modified":"2022-01-25T15:23:49","modified_gmt":"2022-01-25T09:53:49","slug":"new-features-enhancements","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java12\/new-features-enhancements\/","title":{"rendered":"Java 12 &#8211; New features and enhancements"},"content":{"rendered":"<p>Java 12 (released on March 19, 2019) is latest version available for JDK. Let&#8217;s see the new features and improvements, it brings for developers and architects.<\/p>\n<h2>1. Collectors.teeing() in Stream API<\/h2>\n<p>A teeing collector has been exposed as a static method <strong>Collectors::teeing<\/strong>. This collector forwards its input to two other collectors before merging their results with a function.<\/p>\n<p><code>teeing(Collector, Collector, BiFunction)<\/code> accepts two collectors and a function to merge their results. Every element passed to the resulting collector is processed by both downstream collectors, then their results are merged using the specified merge function into the final result.<\/p>\n<p>For example, in a given list of employees, if we want to find out the employee with maximum salary and minimum salary, we can do it in single statement using teeing collector.<\/p>\n<pre class=\"brush: java; title: Collector.teeing() Example; notranslate\" title=\"Collector.teeing() Example\">\r\nSalaryRange salaryRange = Stream\r\n            .of(56700, 67600, 45200, 120000, 77600, 85000)\r\n            .collect(teeing(\r\n                    minBy(Integer::compareTo), \r\n                    maxBy(Integer::compareTo), \r\n                    SalaryRange::fromOptional));\r\n<\/pre>\n<p>Read More : <a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/12\/docs\/api\/java.base\/java\/util\/stream\/Collectors.html#teeing(java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction)\" target=\"_blank\" rel=\"noopener noreferrer\">Collectors.teeing()<\/a><\/p>\n<h2>2. String API Changes<\/h2>\n<h4>2.1. String.indent()<\/h4>\n<p>The indent method helps with changing the indentation of a String. We can either pass a positive value or a negative value depending on whether we want to add more white spaces or remove existing white spaces.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nString result = &quot;foo\\nbar\\nbar2&quot;.indent(4);\r\n\r\nSystem.out.println(result);\r\n\r\n\/\/    foo\r\n\/\/    bar\r\n\/\/    bar2\r\n<\/pre>\n<p>Please note that the <a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/12\/docs\/api\/java.base\/java\/lang\/String.html#indent(int)\">indent()<\/a> method automatically adds a newline character if it hasn\u2019t been provided yet. That\u2019s to be expected and is a feature of the new method.<\/p>\n<blockquote><p>Each white space character is treated as a single character. In particular, the tab character <code>\"\\t\" (U+0009<\/code>) is considered a single character; it is not expanded.<\/p><\/blockquote>\n<h4>2.2. String.transform()<\/h4>\n<p>The <code>transform()<\/code> method takes a <code><a href=\"https:\/\/howtodoinjava.com\/java-string\/\">String<\/a><\/code> and transforms it into a new String with the help of a <code>Function<\/code>.<\/p>\n<p>In given example, we have a list of names. We are performing two operations (trimming white spaces and making all names camel-case) using <code>transform()<\/code> method.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n List&lt;String&gt; names = List.of(\r\n\t\t            \t&quot;   Alex&quot;,\r\n\t\t            \t&quot;brian&quot;);\r\n\r\nList&lt;String&gt; transformedNames = new ArrayList&lt;&gt;();\r\n\r\nfor (String name : names) \r\n{\r\n    String transformedName = name.transform(String::strip)\r\n            \t\t\t\t\t.transform(StringUtils::toCamelCase);\r\n\r\n    transformedNames.add(transformedName);\r\n}\r\n<\/pre>\n<h4>2.3. String constants<\/h4>\n<p>Since Java 12, <code>String<\/code> class implements two additional interfaces <strong>java.lang.constant.Constable<\/strong> and <strong >java.lang.constant.ConstantDesc<\/strong>. <\/p>\n<p><code>String<\/code> class also introduces two additional low-level methods <code>describeConstable()<\/code> and <code>resolveConstantDesc(MethodHandles.Lookup)<\/code>.<\/p>\n<p>They are low-level APIs meant for libraries and tools providing bytecode parsing and generation functionality, for example, Byte Buddy.<\/p>\n<p>Just to note, a <code>Constable<\/code> type is one whose values are constants that can be represented in the constant pool of a Java class file as described in <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.4\">JVMS 4.4<\/a>, and whose instances can describe themselves nominally as a <code>ConstantDesc<\/code>.<\/p>\n<p><code>resolveConstantDesc()<\/code> is similar to <code>describeConstable()<\/code> with the difference being that this method returns an instance of C<code>onstantDesc<\/code> instead.<\/p>\n<h2>3. Files.mismatch(Path, Path)<\/h2>\n<p>Sometimes, we want to determine whether two files have the same content. This API helps in comparing the content of files.<\/p>\n<p><code>mismatch()<\/code> method compares two file paths and return a <code>long<\/code> value. The long indicates the <strong>position of the first mismatched byte<\/strong> in the content of the two files. The return value will be <code>'\u20131'<\/code> if the files are \u201cequal.\u201d<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nPath helloworld1 = tempDir.resolve(&quot;helloworld1.txt&quot;);\r\n\r\nPath helloworld2 = tempDir.resolve(&quot;helloworld2.txt&quot;);\r\n\r\nlong diff = Files.mismatch(helloworld1, helloworld2);\t\/\/returns long value\r\n<\/pre>\n<h2>4. Compact Number Formatting<\/h2>\n<p>Large numbers rendered by a user interface or a command-line tool are always difficult to parse. It is far more common to use the abbreviated form of a number. Compact number representations are much easier to read and require less space on the screen without losing the original meaning. <\/p>\n<p>E.g. <strong>3.6 M<\/strong>  is very much easier to read than <strong>3,600,000<\/strong>.<\/p>\n<p>Java 12 introduces a convenient method called <strong>NumberFormat.getCompactNumberInstance(Locale, NumberFormat.Style)<\/strong> for creating a compact number representation.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nNumberFormat formatter = NumberFormat.getCompactNumberInstance(Locale.US,\r\n            \t\t\t\t\t\t\t\t\t\t\tNumberFormat.Style.SHORT);\r\n\r\nString formattedString = formatter.format(25000L);\t\t\/\/25K\r\n<\/pre>\n<h2>5. Support for Unicode 11<\/h2>\n<p>In a time in which emojis play a crucial role in communicating on social media channels, it\u2019s more important than ever to support the latest Unicode specification. Java 12 has kept pace and supports Unicode 11.<\/p>\n<p>Unicode 11 adds 684 characters, for a total of 137,374 characters &#8211; and seven new scripts, for a total of 146 scripts. <\/p>\n<h2>6. Switch Expressions (Preview)<\/h2>\n<p>This change extends the <strong><a href=\"https:\/\/howtodoinjava.com\/java\/flow-control\/switch-statement-in-java\/\">switch statement<\/a><\/strong> so that it can be used as either a statement or an expression. <\/p>\n<p>Instead of having to define a <code><a href=\"https:\/\/howtodoinjava.com\/java\/basics\/break-keyword\/\">break<\/a><\/code> statement per case block, we can simply use the <strong>arrow syntax<\/strong>. The arrow syntax semantically looks like a lambda and separates the case label from the expression. <\/p>\n<p>With the new switch expressions, we can directly assign the switch statement to a variable.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nboolean isWeekend = switch (day) \r\n{\r\n\tcase MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; false;\r\n\r\n\tcase SATURDAY, SUNDAY -&gt; true;\r\n\r\n\tdefault -&gt; throw new IllegalStateException(&quot;Illegal day entry :: &quot; + day);\r\n};\r\n\r\nSystem.out.println(isWeekend); \t\/\/true or false - based on current day\r\n<\/pre>\n<blockquote><p>To use this preview feature, remember that we have to explicitly instruct the JVM during application startup using <strong>&#8211;enable-preview<\/strong> flag.<\/p><\/blockquote>\n<p>Drop me your questions related to these new <strong>API changes in Java 12<\/strong>.<\/p>\n<p>Happy Learning !! <\/p>\n","protected":false},"excerpt":{"rendered":"<p>Java 12 (released on March 19, 2019) is latest version available for JDK. Let\u2019s see the new features and improvements, it brings for developers and architects.<\/p>\n","protected":false},"author":2,"featured_media":12539,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[1247],"tags":[1435],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",657,428,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",150,98,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",300,195,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",657,428,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",657,428,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",657,428,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",657,428,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-12.jpeg",120,78,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":1,"uagb_excerpt":"Java 12 (released on March 19, 2019) is latest version available for JDK. Let\u2019s see the new features and improvements, it brings for developers and architects.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/12538"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=12538"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/12538\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/12539"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=12538"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=12538"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=12538"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}