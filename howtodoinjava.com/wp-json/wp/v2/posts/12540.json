{"id":12540,"date":"2019-05-15T21:46:46","date_gmt":"2019-05-15T16:16:46","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=12540"},"modified":"2022-01-25T15:22:02","modified_gmt":"2022-01-25T09:52:02","slug":"features-enhancements","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java11\/features-enhancements\/","title":{"rendered":"Java 11 new features and enhancements"},"content":{"rendered":"<p>Java 11 (released on September 2018) includes many important and useful updates. Let&#8217;s see the new features and improvements, it brings for developers and architects.<\/p>\n<h2>1. HTTP Client API<\/h2>\n<p>Java had <code>HttpURLConnection<\/code> class for long time for HTTP communication. But over the time, requirements have gone complex and more demanding in applications. Before Java 11, developers had to resort to feature-rich libraries like <em>Apache HttpComponents<\/em> or <em>OkHttp<\/em> etc.<\/p>\n<p>We saw <a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/\">Java 9<\/a> release to include an <code>HttpClient<\/code> implementation as an experimental feature. It has grown over time and now a final feature of Java 11. Now the Java applications can make HTTP communications without the need to any external dependency.<\/p>\n<h4>1.1. How to use HttpClient<\/h4>\n<p>A typical HTTP interaction with the <code>java.net.http<\/code> module looks like-<\/p>\n<ul>\n<li>Create an instance of <strong>HttpClient<\/strong> and configure it as needed.<\/li>\n<li>Create an instance of <strong>HttpRequest<\/strong> and populate the information.<\/li>\n<li>Pass the request to the client, perform the request, and retrieve an instance of <strong>HttpResponse<\/strong>.<\/li>\n<li>Process the information contained in the <code>HttpResponse<\/code>.<\/li>\n<\/ul>\n<p>HTTP API can handle synchronous and asynchronous communication. Let&#8217;s see a quick example.<\/p>\n<h4>1.2. Synchronous request example<\/h4>\n<p>Notice how the http client API uses <strong>builder pattern<\/strong> for creating complex objects.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nimport java.io.IOException;\r\nimport java.net.URI;\r\nimport java.net.http.HttpClient;\r\nimport java.net.http.HttpRequest;\r\nimport java.net.http.HttpResponse;\r\nimport java.time.Duration;\r\n\r\nHttpClient httpClient = HttpClient.newBuilder()\r\n\t\t\t\t        .connectTimeout(Duration.ofSeconds(10))\r\n\t\t\t\t        .build();                                  \r\n\r\ntry \r\n{\r\n    String urlEndpoint = &quot;https:\/\/postman-echo.com\/get&quot;;\r\n    URI uri = URI.create(urlEndpoint + &quot;?foo1=bar1&amp;foo2=bar2&quot;);\r\n    HttpRequest request = HttpRequest.newBuilder()\r\n\t\t\t\t\t\t            .uri(uri)\r\n\t\t\t\t\t\t            .build();                              \r\n    HttpResponse&lt;String&gt; response = httpClient.send(request,\r\n            \t\t\t\t\t\t\tHttpResponse.BodyHandlers.ofString()); \r\n} catch (IOException | InterruptedException e) {\r\n    throw new RuntimeException(e);\r\n}\r\n\r\nSystem.out.println(&quot;Status code: &quot; + response.statusCode());                            \r\nSystem.out.println(&quot;Headers: &quot; + response.headers().allValues(&quot;content-type&quot;));               \r\nSystem.out.println(&quot;Body: &quot; + response.body()); \r\n<\/pre>\n<h4>1.2. Asynchronous request example<\/h4>\n<p>Asynchronous communication is useful if we don\u2019t want to wait for the response. We provide callback handler, which gets executed when response is available.<\/p>\n<p>Notice the use of <strong>sendAsync()<\/strong> method to send asynchronous request.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nimport java.io.IOException;\r\nimport java.net.URI;\r\nimport java.net.http.HttpClient;\r\nimport java.net.http.HttpRequest;\r\nimport java.net.http.HttpResponse;\r\nimport java.time.Duration;\r\nimport java.util.List;\r\nimport java.util.concurrent.CompletableFuture;\r\nimport java.util.stream.Stream;\r\nimport static java.util.stream.Collectors.toList;\r\n\r\nfinal List&lt;URI&gt; uris = Stream.of(\r\n\t\t\t\t        &quot;https:\/\/www.google.com\/&quot;,\r\n\t\t\t\t        &quot;https:\/\/www.github.com\/&quot;,\r\n\t\t\t\t        &quot;https:\/\/www.yahoo.com\/&quot;\r\n\t\t\t\t        ).map(URI::create).collect(toList());      \r\n\r\nHttpClient httpClient = HttpClient.newBuilder()\r\n\t\t\t\t        .connectTimeout(Duration.ofSeconds(10))\r\n\t\t\t\t        .followRedirects(HttpClient.Redirect.ALWAYS)\r\n\t\t\t\t        .build();\r\n\r\nCompletableFuture[] futures = uris.stream()\r\n\t\t\t\t\t        .map(uri -&gt; verifyUri(httpClient, uri))\r\n\t\t\t\t\t        .toArray(CompletableFuture[]::new);     \r\n\r\nCompletableFuture.allOf(futures).join();           \r\n\r\nprivate CompletableFuture&lt;Void&gt; verifyUri(HttpClient httpClient, \r\n                                          URI uri) \r\n{\r\n    HttpRequest request = HttpRequest.newBuilder()\r\n\t\t\t\t\t\t            .timeout(Duration.ofSeconds(5))\r\n\t\t\t\t\t\t            .uri(uri)\r\n\t\t\t\t\t\t            .build();\r\n\r\n    return httpClient.sendAsync(request,HttpResponse.BodyHandlers.ofString())\r\n\t\t\t            .thenApply(HttpResponse::statusCode)\r\n\t\t\t            .thenApply(statusCode -&gt; statusCode == 200)\r\n\t\t\t            .exceptionally(ex -&gt; false)\r\n\t\t\t            .thenAccept(valid -&gt; \r\n\t\t\t            {\r\n\t\t\t                if (valid) {\r\n\t\t\t                    System.out.println(&quot;[SUCCESS] Verified &quot; + uri);\r\n\t\t\t                } else {\r\n\t\t\t                    System.out.println(&quot;[FAILURE] Could not &quot; + &quot;verify &quot; + uri);\r\n\t\t\t                }\r\n\t\t\t            });                                    \r\n}\r\n<\/pre>\n<h2>2. Launch Single-File Programs Without Compilation<\/h2>\n<p>Traditionally, for every program that we\u2019d like to execute, we need to first compile it. It seems unnecessarily lengthy process for small programs for testing purposes.<\/p>\n<p>Java 11 changes it and now we can execute Java source code contained in a single file without the need to compile it first.<\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld {\r\n    public static void main(String[] args) {\r\n        System.out.println(&quot;Hello World!&quot;);\r\n    }\r\n}\r\n<\/pre>\n<p>To execute above class, run it directly with <code>java<\/code> command.<\/p>\n<pre class=\"brush: java; title: Console; notranslate\" title=\"Console\">\r\n$ java HelloWorld.java\r\n\r\nHello World!\r\n<\/pre>\n<blockquote><p>Note that the program <strong>cannot use any external dependencies<\/strong> other than the <code>java.base module<\/code>. And program can be only <strong>single-file program<\/strong>.<\/p><\/blockquote>\n<h2>3. String API Changes<\/h2>\n<h4>3.1. String.repeat(Integer)<\/h4>\n<p>This method simply repeats a <a href=\"https:\/\/howtodoinjava.com\/java-string\/\">string<\/a> <code>n<\/code> times. It returns a string whose value is the concatenation of given string repeated N times. <\/p>\n<p>If this string is empty or count is zero then the empty string is returned.<\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n    \tString str = &quot;1&quot;.repeat(5);\r\n\r\n        System.out.println(str);\t\/\/11111\r\n    }\r\n}\r\n<\/pre>\n<h4>3.2. String.isBlank()<\/h4>\n<p>This method indicates whether a string is empty or contains only white-spaces. Previously, we have been using it from Apache&#8217;s <code>StringUtils.java<\/code>.<\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n    \t&quot;1&quot;.isBlank();\t\/\/false\r\n\r\n        &quot;&quot;.isBlank();\t\/\/true\r\n\r\n        &quot;    &quot;.isBlank();\t\/\/true\r\n    }\r\n}\r\n<\/pre>\n<h4>3.3. String.strip()<\/h4>\n<p>This method takes care of removing leading and trailing white-spaces. We can be even more specific by removing just the leading characters by using <strong>String.stripLeading()<\/strong> or just the trailing characters by using <strong>String.stripTrailing()<\/strong>.<\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n    \t&quot;   hi  &quot;.strip();\t\/\/&quot;hi&quot;\r\n\r\n       &quot;   hi  &quot;.stripLeading();\t\/\/&quot;hi   &quot;\r\n\r\n       &quot;   hi  &quot;.stripTrailing();\t\/\/&quot;   hi&quot;\r\n    }\r\n}\r\n<\/pre>\n<h4>3.4. String.lines()<\/h4>\n<p>This method helps in processing multi-line texts as a <strong><a href=\"https:\/\/howtodoinjava.com\/java\/stream\/java-streams-by-examples\/\">Stream<\/a><\/strong>.<\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n    \tString testString = &quot;hello\\nworld\\nis\\nexecuted&quot;;\r\n\r\n\t    List&lt;String&gt; lines = new ArrayList&lt;&gt;();\r\n\r\n\t    testString.lines().forEach(line -&gt; lines.add(line));\r\n\r\n\t    assertEquals(List.of(&quot;hello&quot;, &quot;world&quot;, &quot;is&quot;, &quot;executed&quot;), lines);\r\n    }\r\n}\r\n<\/pre>\n<h2>4. Collection.toArray(IntFunction<T[]>)<\/h2>\n<p>Before Java 11, converting a collection to array was not straightforward. Java 11 makes the conversion more convenient. <\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n    \tList&lt;String&gt; names = new ArrayList&lt;&gt;();\r\n\t    names.add(&quot;alex&quot;);\r\n\t    names.add(&quot;brian&quot;);\r\n\t    names.add(&quot;charles&quot;);\r\n\r\n\t    String[] namesArr1 = names.toArray(new String[names.size()]);\t\t\/\/Before Java 11\r\n\r\n\t    String[] namesArr2 = names.toArray(String[]::new);\t\t\t\t\t\/\/Since Java 11\r\n    }\r\n}\r\n<\/pre>\n<h2>5. Files.readString() and Files.writeString()<\/h2>\n<p>Using these overloaded methods, Java 11 aims to reduce a lot of boilerplate code which makes much easier to read and write files.<\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n    \t\/\/Read file as string\r\n    \tURI txtFileUri = getClass().getClassLoader().getResource(&quot;helloworld.txt&quot;).toURI();\r\n\r\n    \tString content = Files.readString(Path.of(txtFileUri),Charset.defaultCharset());\r\n\r\n    \t\/\/Write string to file\r\n    \tPath tmpFilePath = Path.of(File.createTempFile(&quot;tempFile&quot;, &quot;.tmp&quot;).toURI());\r\n\r\n    \tPath returnedFilePath = Files.writeString(tmpFilePath,&quot;Hello World!&quot;, \r\n    \t\t\t\t\t\t\t\tCharset.defaultCharset(), StandardOpenOption.WRITE);\r\n    }\r\n}\r\n<\/pre>\n<h2>6. Optional.isEmpty()<\/h2>\n<p><a href=\"https:\/\/howtodoinjava.com\/java8\/java-8-optionals-complete-reference\/\">Optional<\/a> is a container object which may or may not contain a non-null value. If no value is present, the object is considered empty. <\/p>\n<p>Previously existing method <strong>isPresent()<\/strong> returns <code>true<\/code> if a value is present, otherwise <code>false<\/code>. Sometimes, it forces us to write negative conditions which are not readable.<\/p>\n<p><strong>isEmpty()<\/strong> method is reverse of <code>isPresent()<\/code> method and returns <code>false<\/code> if a value is present, otherwise <code>true<\/code>.<\/p>\n<p>So we do not to write negative conditions in any case. Use any of these two methods when appropriate.<\/p>\n<pre class=\"brush: java; title: HelloWorld.java; notranslate\" title=\"HelloWorld.java\">\r\npublic class HelloWorld \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n    \tString currentTime = null;\r\n\r\n\t    assertTrue(!Optional.ofNullable(currentTime).isPresent());\t\/\/It's negative condition\r\n\t    assertTrue(Optional.ofNullable(currentTime).isEmpty());\t\t\/\/Write it like this\r\n\r\n\t    currentTime = &quot;12:00 PM&quot;;\r\n\r\n\t    assertFalse(!Optional.ofNullable(currentTime).isPresent());\t\/\/It's negative condition\r\n\t    assertFalse(Optional.ofNullable(currentTime).isEmpty());\t\/\/Write it like this\r\n    }\r\n}\r\n<\/pre>\n<p>Drop me your questions related to these <strong>new API changes in Java 11<\/strong>.<\/p>\n<p>Happy Learning !!<\/p>\n<p>Ref : <a href=\"https:\/\/docs.oracle.com\/en\/java\/javase\/11\/\" rel=\"noopener noreferrer\" target=\"_blank\">Java 11 release doc<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Java 11 (released on September 2018) includes many important and useful updates. Let&#8217;s see the new features and improvements, it brings for developers and architects. 1. HTTP Client API Java had HttpURLConnection class for long time for HTTP communication. But over the time, requirements have gone complex and more demanding in applications. Before Java 11, &#8230; <a title=\"Java 11 new features and enhancements\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java11\/features-enhancements\/\" aria-label=\"More on Java 11 new features and enhancements\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":12541,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[1226],"tags":[1435],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",800,450,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",150,84,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",300,169,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",768,432,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",800,450,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",800,450,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",800,450,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/05\/Java-11.png",120,68,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"Java 11 (released on September 2018) includes many important and useful updates. Let&#8217;s see the new features and improvements, it brings for developers and architects. 1. HTTP Client API Java had HttpURLConnection class for long time for HTTP communication. But over the time, requirements have gone complex and more demanding in applications. Before Java 11,&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/12540"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=12540"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/12540\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/12541"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=12540"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=12540"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=12540"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}