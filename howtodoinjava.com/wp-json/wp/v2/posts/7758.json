{"id":7758,"date":"2016-09-20T18:32:38","date_gmt":"2016-09-20T13:02:38","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=7758"},"modified":"2020-12-26T00:44:41","modified_gmt":"2020-12-25T19:14:41","slug":"microservices-definition-principles-benefits","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/microservices\/microservices-definition-principles-benefits\/","title":{"rendered":"Microservices &#8211; Definition, Principles and Benefits"},"content":{"rendered":"<p>Microservices is the latest buzzword in the industry and everyone seems to be talking about it, in one way or another. Let&#8217;s understand <strong>what are microservices<\/strong>? In this tutorial, we will try to understand the definition, concepts and <strong>principles of microservices<\/strong>. <\/p>\n<pre>Table of Contents\r\n\r\n<a href=\"#definition\">1. Definition of Microservices<\/a>\r\n<a href=\"#principles\">2. Principles of Microservices<\/a>\r\n<a href=\"#benefits\">3. Benefits of Microservices<\/a>\r\n<a href=\"#summary\">4. Conclusion<\/a><\/pre>\n<p><a name=\"definition\"><\/a><\/p>\n<h2>1. Definition of Microservices<\/h2>\n<p>Today, microservices are one of the increasingly popular architecture patterns next to SOA (<a href=\"https:\/\/en.wikipedia.org\/wiki\/Service-oriented_architecture\" rel=\"noopener noreferrer\" target=\"_blank\">Services Oriented Architecture<\/a>). If you are following industry trends, then you realize that today business houses are no longer interested in developing large applications to manage their end-to-end business functions as they did a few years ago, rather they opt for quick and agile applications which cost them less money as well.<\/p>\n<p>Microservices help in breaking the boundaries of large applications and build logically independent smaller systems inside the system. E.g. using <a href=\"https:\/\/aws.amazon.com\/\" target=\"_blank\" rel=\"noopener noreferrer\">Amazon AWS<\/a> you can build a cloud application with minimum effort. It&#8217;s a good example of what microservices can do.<\/p>\n<figure id=\"attachment_7759\" aria-describedby=\"caption-attachment-7759\" style=\"width: 600px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png\" alt=\"Monolithic vs MicroServices Architecture\" width=\"610\" height=\"311\" class=\"size-full wp-image-7759\" srcset=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png 610w, https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture-300x153.png 300w\" sizes=\"(max-width: 610px) 100vw, 610px\" \/><figcaption id=\"caption-attachment-7759\" class=\"wp-caption-text\">Monolithic vs MicroServices Architecture<\/figcaption><\/figure>\n<p>As you can see in the above diagram, each microservice has it&#8217;s own business layer and database. By doing so, changes to one microservice do not impact others. <\/p>\n<p>In general, <strong>microservices communicate with each other using widely adopted lightweight protocols<\/strong>, such as HTTP and REST, or messaging protocols, such as <a href=\"https:\/\/howtodoinjava.com\/jms\/jms-java-message-service-tutorial\/\" rel=\"noopener noreferrer\" target=\"_blank\">JMS<\/a> or AMQP. In specific scenarios, they can go for more specialized protocols as well.<\/p>\n<p><a name=\"principles\"><\/a><\/p>\n<h2>2. Principles of Microservices<\/h2>\n<p>Now let&#8217;s examine the &#8220;must-have&#8221; principles of a microservice.<\/p>\n<ol>\n<li>\n<h4>Single responsibility principle<\/h4>\n<p>The single responsibility principle is one of the principles defined as part of the <a href=\"https:\/\/howtodoinjava.com\/best-practices\/solid-principles\/#SRP\">SOLID design pattern<\/a>. It implies that a unit, either a class, a function, or a microservice, should have one and only one responsibility. <\/p>\n<p>At no point in time, one microservice should have more than one responsibility.\n<\/li>\n<li>\n<h4>Built around business capabilities<\/h4>\n<p><strong>Microservices should focus on certain business functions<\/strong> and ensure that it helps in getting things done. A microservice shall never restrict itself from adopting appropriate technology stack or backend database storage which is most suitable for solving the business purpose. <\/p>\n<p>This is often the constraint when we design monolithic applications where we try to solve multiple business solutions with some compromises in some areas. Microservices enable you to choose what&#8217;s best for the problem at hand.\n<\/li>\n<li>\n<h4>You build it, you own it!<\/h4>\n<p>Another important aspect of such design is related to responsibilities pre-and-post development. In a large organization, usually one team develops the app location, and after some knowledge transfer sessions it hand over the project to the maintenance team. In microservices, the team which builds the service &#8211; owns it, and is responsible for maintaining it in the future.<\/p>\n<blockquote><p><a href=\"http:\/\/aronatkins.github.io\/2014\/12\/23\/you-build-it-you-own-it.html\">You build it, you own it !!<\/a><\/p><\/blockquote>\n<p>This ownership brings developers into contact with the day-to-day operation of their software and they better understand how their built product is used by customers in the real world.\n<\/li>\n<li>\n<h4>Infrastructure Automation<\/h4>\n<p>Preparing and building infrastructure for microservices is another very important need. <strong>A service shall be independently deployable<\/strong> and shall bundle all dependencies, including library dependencies, and even execution environments such as web servers and containers or virtual machines that abstract physical resources.<\/p>\n<p>One of the major <strong>differences between microservices and SOA<\/strong> is in their level of autonomy. While most SOA implementations provide service-level abstraction, microservices go further and abstract the realization and execution environment.<\/p>\n<p>In traditional application developments, we build a WAR or an EAR, then deploy it into a JEE application server, such as with JBoss, WebLogic, WebSphere, and so on. We may deploy multiple applications into the same JEE container. In an ideal scenario, in the microservices approach, each microservice will be built as a <a href=\"\/\/howtodoinjava.com\/maven\/maven-shade-plugin-create-uberfat-jar-example\/\">fat Jar<\/a>, embedding all dependencies and run as a standalone Java process.\n<\/li>\n<li>\n<h4>Design for Failure<\/h4>\n<p>A microservice shall be designed with failure cases in mind. What if the service fails, or go down for some time. These are very important questions and must be solved before actual coding starts &#8211; to clearly estimate <strong>how service failures will affect the user experience<\/strong>. <\/p>\n<p>Fail fast is another concept used to build fault-tolerant, resilient systems. This philosophy advocates systems that expect failures versus building systems that never fail. Since services can fail at any time, it&#8217;s important to be able to detect the failures quickly and, if possible, automatically restore service. <\/p>\n<p>Microservice applications put a lot of <strong>emphasis on real-time monitoring<\/strong> of the application, checking both architectural elements (how many requests per second is the database getting) and business relevant metrics (such as how many orders per minute are received). Semantic monitoring can provide an early warning system of something going wrong that triggers development teams to follow up and investigate.\n<\/li>\n<\/ol>\n<p><a name=\"benefits\"><\/a><\/p>\n<h2>3. Benefits of Microservices<\/h2>\n<p>Microservices offer a number of <em>benefits over the traditional multi-tier, monolithic architectures<\/em>. Let&#8217;s list down them:<\/p>\n<ul>\n<li>With microservices, architects and developers can choose <strong>fit for purpose architectures and technologies<\/strong> for each microservice (<a href=\"https:\/\/www.infoq.com\/articles\/paradigm-based-polyglot-prog\/\" target=\"_blank\" rel=\"noopener noreferrer\">polyglot architecture<\/a>). This gives the flexibility to design better-fit solutions in a more cost-effective way.<\/li>\n<li>As services are <strong>fairly simple and smaller in size<\/strong>, enterprises can afford to experiment with new processes, algorithms, business logic, and so on. It enables enterprises to do disruptive innovation by offering the ability to experiment and fail fast.<\/li>\n<li>Microservices enable to implement <strong>selective scalability<\/strong> i.e. each service could be independently scaled up or down and cost of scaling is comparatively less than monolithic approach.<\/li>\n<li>Microservices are <strong>self-contained, independent deployment modules<\/strong> enabling the substitution of one microservice with another similar microservice, when the second one is not performing as per our need. It helps in taking right buy-versus-build decisions which are often the challenge for many enterprises.<\/li>\n<li>Microservices help us <strong>build systems that are organic in nature<\/strong> (Organic systems are systems that grow laterally over a period of time by adding more and more functions to it). Because microservices are all about independently manageable services &#8211; it enables to add more and more services as the need arises with minimal impact on the existing services.<\/li>\n<li>Technology changes are one of the barriers in software development. With microservices, it is possible to <strong>change or upgrade technology for each service individually<\/strong> rather than upgrading an entire application.<\/li>\n<li>As microservices <strong>package the service runtime environment along with the service itself<\/strong>, this enables having multiple versions of the service to coexist in the same environment.<\/li>\n<li>And finally, microservices also enable <strong>smaller, focused agile teams<\/strong> for development. Teams will be organized based on the boundaries of microservices.<\/li>\n<\/ul>\n<p><a name=\"summary\"><\/a><\/p>\n<h2>4. Conclusion<\/h2>\n<div class=\"noticeboxesde bluenoticebox\">Often the true consequences of your architectural decisions are only evident several years after you made them.<\/div>\n<p>In this article, I have only listed down some positives about microservices which have been seen in many organizations in my limited knowledge. A monolithic application, backed by strong design and brilliant coders, can also prove a good decision and the product can stay long enough to support the decision.<\/p>\n<p>Similarily with microservices, poor design decisions will be proved costly. They may seem to be simplifying the components, but they may add complexity in communication between them and that is harder to control and manage.<\/p>\n<p>Finally, <strong>it&#8217;s good design and skilled team is what will bring win for you<\/strong>. A less skilled team will always create a poor system and it&#8217;s very hard to tell if microservices reduce the mess in this case or make it worse. <\/p>\n<p>I will suggest starting with monolithic application design, and when you feel that it is making the system complex &#8211; try microservices to check if they make the application less complex. In this way, you will have a more informed and better decision.<\/p>\n<p>Happy Learning !!<\/p>\n<p>Resources:<\/p>\n<p><a href=\"https:\/\/martinfowler.com\/articles\/microservices.html\">Martin Fowler on Microservices<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Learn what is a microservice? Architectures, principles and benefits of the microservices? Also learn the differences between microservices and SOA.<\/p>\n","protected":false},"author":2,"featured_media":7759,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[975],"tags":[933,934],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png",610,311,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture-150x150.png",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture-300x153.png",300,153,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png",610,311,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png",610,311,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png",610,311,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png",610,311,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2016\/09\/Monolithic-vs-MicroServices-Architecture.png",120,61,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":6,"uagb_excerpt":"Learn what is a microservice? Architectures, principles and benefits of the microservices? Also learn the differences between microservices and SOA.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/7758"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=7758"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/7758\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/7759"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=7758"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=7758"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=7758"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}