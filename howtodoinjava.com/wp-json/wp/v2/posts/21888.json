{"id":21888,"date":"2022-07-13T10:56:22","date_gmt":"2022-07-13T05:26:22","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=21888"},"modified":"2022-07-18T15:22:24","modified_gmt":"2022-07-18T09:52:24","slug":"virtual-threads","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/multi-threading\/virtual-threads\/","title":{"rendered":"Java Virtual Threads &#8211; Project Loom"},"content":{"rendered":"\n<p>In Java, Virtual threads (<a href=\"https:\/\/openjdk.org\/jeps\/425\" target=\"_blank\" rel=\"noreferrer noopener\">JEP-425<\/a>) are <strong>JVM-managed lightweight threads<\/strong> that will <strong>help in writing high throughput concurrent applications<\/strong> (<em>throughput<\/em> means how many units of information a system can process in a given amount of time).<\/p>\n\n\n\t\t\t\t<div class=\"wp-block-uagb-table-of-contents uagb-toc__align-left uagb-toc__columns-1   uagb-block-55e11b21 \" \n\t\t\t\t\tdata-scroll= \"1\"\n\t\t\t\t\tdata-offset= \"30\"\n\t\t\t\t\tdata-delay= \"800\"\n\t\t\t\t>\n\t\t\t\t<div class=\"uagb-toc__wrap\">\n\t\t\t\t\t<div class=\"uagb-toc__title-wrap\">\n\t\t\t\t\t\t<div class=\"uagb-toc__title\">\n\t\t\t\t\t\t\tTable Of Contents\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"uagb-toc__list-wrap\">\n\t\t\t\t\t\t<ol class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#1-java-thread-model-and-virtual-threads\">1. Java Thread Model and Virtual Threads<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#11-classic-threads-or-platform-threads\">1.1. Classic Threads or Platform Threads<\/a><li class=\"uagb-toc__list\"><a href=\"#12-scalability-issues-with-platform-threads\">1.2. Scalability Issues with Platform Threads<\/a><li class=\"uagb-toc__list\"><a href=\"#13-issues-with-reactive-programming\">1.3. Issues with Reactive Programming<\/a><li class=\"uagb-toc__list\"><a href=\"#14-virtual-threads-look-promising\">1.4. Virtual Threads look Promising<\/a><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#2-difference-between-platform-threads-and-virtual-threads\">2. Difference between Platform Threads and Virtual Threads<\/a><li class=\"uagb-toc__list\"><a href=\"#3-comparing-performance-of-platform-threads-and-virtual-threads\">3. Comparing Performance of Platform Threads and Virtual Threads<\/a><li class=\"uagb-toc__list\"><a href=\"#4-how-to-create-virtual-threads\">4. How to Create Virtual Threads<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#41-using-threadstartvirtualthread\">4.1. Using Thread.startVirtualThread()<\/a><li class=\"uagb-toc__list\"><a href=\"#42-using-threadbuilder\">4.2. Using Thread.Builder<\/a><li class=\"uagb-toc__list\"><a href=\"#43-using-executorsnewvirtualthreadpertaskexecutor\">4.3. Using Executors.newVirtualThreadPerTaskExecutor()<\/a><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#5-best-practices\">5. Best Practices<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#51-do-not-pool-the-virtual-threads\">5.1. DO NOT Pool the Virtual Threads<\/a><li class=\"uagb-toc__list\"><a href=\"#52-avoid-using-thread-local-variables\">5.2. Avoid using Thread-local Variables<\/a><li class=\"uagb-toc__list\"><a href=\"#53-use-reentrantlock-instead-of-synchronized-blocks\">5.3. Use ReentrantLock instead of Synchronized Blocks<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#6-conclusion\">6. Conclusion<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/ol>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\n\n\n<h2 id=\"h-1-java-thread-model-and-virtual-threads\">1. Java Thread Model and Virtual Threads<\/h2>\n\n\n\n<h3 id=\"h-1-1-classic-threads-or-platform-threads\">1.1. Classic Threads or Platform Threads<\/h3>\n\n\n\n<p>In Java, a classic thread is an instance of <code>java.lang.Thread<\/code> class. Moving forward, we will call them <strong>platform threads<\/strong>, as well.<\/p>\n\n\n\n<p>Traditionally, <strong>Java has treated the platform threads as thin wrappers around operating system (OS) threads<\/strong>. Creating such platform threads has always been costly (due to a large stack and other resources that are maintained by the operating system), so Java has been using the <a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/java-thread-pool-executor-example\/\">thread pools<\/a> to avoid the overhead in thread creation.<\/p>\n\n\n\n<p>The number of platform threads also has to be limited because these resource-hungry threads can affect the performance of the whole machine. This is mainly because platform threads are mapped <code>1:1<\/code> to OS threads.<\/p>\n\n\n\n<h3 id=\"h-1-2-scalability-issues-with-platform-threads\">1.2. Scalability Issues with Platform Threads<\/h3>\n\n\n\n<p>Platform threads have always been easy to model, program and debug because they use the platform&#8217;s unit of concurrency to represent the application&#8217;s unit of concurrency. It is called <strong>thread-per-request<\/strong> pattern.<\/p>\n\n\n\n<p>But this pattern limits the throughput of the server because the <strong>number of concurrent requests <em>(that server can handle)<\/em> becomes directly proportional to the server&#8217;s hardware performance<\/strong>. So, the number of available threads has to be limited even in multi-core processors. <\/p>\n\n\n\n<p>Apart from the number of threads, <strong>latency<\/strong> is also a big concern. If you watch closely, in today&#8217;s world of <a href=\"https:\/\/howtodoinjava.com\/microservices\/microservices-definition-principles-benefits\/\">microservices<\/a>, a request is served by fetching\/updating data on multiple systems and servers. <strong>While the application waits for the information from other servers, the current platform thread remains in an idle state.<\/strong> This is a waste of computing resources and a major hurdle in achieving a high throughput application.<\/p>\n\n\n\n<h3 id=\"h-1-3-issues-with-reactive-programming\">1.3. Issues with Reactive Programming<\/h3>\n\n\n\n<p><a href=\"https:\/\/howtodoinjava.com\/tag\/reactive-programming\/\">Reactive style programming<\/a> solved the problem of platform threads waiting for responses from other systems. The asynchronous APIs do not wait for the response, rather they work through the callbacks. Whenever a thread invokes an async API, the platform thread is returned to the pool until the response comes back from the remote system or database. Later, when the response arrives, the JVM will allocate another thread from the pool that will handle the response and so on. This way, <strong>multiple threads are involved in handling a single async request<\/strong>.<\/p>\n\n\n\n<p>In async programming, the latency is removed but the number of platform threads are still limited due to hardware limitations, so we have a limit on scalability. Another big issue is that such <strong>async programs are executed in different threads so it is very hard to debug or profile them<\/strong>.<\/p>\n\n\n\n<p>Also, we have to adopt a new programming style away from <a href=\"https:\/\/howtodoinjava.com\/java\/flow-control\/enhanced-for-each-loop-in-java\/\">typical loops<\/a> and <a href=\"https:\/\/howtodoinjava.com\/java\/flow-control\/control-flow-statements\/\">conditional statements<\/a>. The new <a href=\"https:\/\/howtodoinjava.com\/java8\/lambda-expressions\/\">lambda-style syntax<\/a> makes it hard to understand the existing code and write programs because we must now break our program into multiple smaller units that can be run independently and asynchronously. <\/p>\n\n\n\n<p>So we can say that <strong>virtual threads also improve the code quality<\/strong> by adapting the traditional syntax while having the benefits of reactive programming.<\/p>\n\n\n\n<h3 id=\"h-1-4-virtual-threads-look-promising\">1.4. Virtual Threads look Promising<\/h3>\n\n\n\n<p>Similar to traditional threads, <strong>a virtual thread is also an instance of <code><em>java.lang.Thread<\/em><\/code><\/strong> that runs its code on an underlying OS thread, but it <strong>does not block the OS thread for the code&#8217;s entire lifetime<\/strong>. Keeping the OS threads free means that many virtual threads can run their Java code on the same OS thread, effectively sharing it.<\/p>\n\n\n<div class=\"wp-block-image\">\n<figure class=\"aligncenter size-full is-resized\"><a href=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg\" alt=\"\" class=\"wp-image-21889\" width=\"683\" height=\"290\" srcset=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg 878w, https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-300x127.jpg 300w, https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-768x326.jpg 768w\" sizes=\"(max-width: 683px) 100vw, 683px\" \/><\/a><\/figure><\/div>\n\n\n<p>It is worth mentioning that we can create a very high number of virtual threads (<em>millions<\/em>) in an application without depending on the number of platform threads. These <strong>virtual threads are managed by JVM<\/strong>, so they do not add extra context-switching overhead as well because they are stored in RAM as normal Java objects.<\/p>\n\n\n\n<p>Similar to traditional threads, the application&#8217;s code runs in a virtual thread for the entire duration of a request (in <em>thread-per-request<\/em> style) but the <strong>virtual thread consumes an OS thread only when it performs the calculations on the CPU<\/strong>. They do not block the OS thread while they are waiting or sleeping.<\/p>\n\n\n\n<p>Virtual threads help in achieving the same high scalability and throughput as the asynchronous APIs with the same hardware configuration, without adding the syntax complexity.<\/p>\n\n\n\n<blockquote class=\"wp-block-quote is-style-default\"><p>Virtual threads&nbsp;are best suited to executing code that spends most of its time blocked, waiting for data to arrive on a network socket or waiting for an element in queue for example.<\/p><\/blockquote>\n\n\n\n<h2 id=\"h-2-difference-between-platform-threads-and-virtual-threads\">2. Difference between Platform Threads and Virtual Threads<\/h2>\n\n\n\n<ul><li><strong>Virtual threads are always daemon threads<\/strong>. The <code>Thread.setDaemon(false)<\/code> method cannot change a virtual thread to be a non-daemon thread. Note that JVM terminates when all started non-daemon threads have terminated. This means JVM will not wait for virtual threads to complete before exiting.<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Thread virtualThread = ...; \/\/Create virtual thread\n\n\/\/virtualThread.setDaemon(true);  \/\/It has no effect<\/code><\/pre>\n\n\n\n<ul><li><strong>Virtual threads always have the normal priority<\/strong> and the priority cannot be changed, even with <code>setPriority(n)<\/code> method. Calling this method on a virtual thread has no effect.<\/li><\/ul>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Thread virtualThread = ...; \/\/Create virtual thread\n\n\/\/virtualThread.setPriority(Thread.MAX_PRIORITY);  \/\/It has no effect<\/code><\/pre>\n\n\n\n<ul><li><strong>Virtual threads are not active members of thread groups<\/strong>. When invoked on a virtual thread, <code>Thread.getThreadGroup()<\/code> returns a placeholder thread group with the name &#8220;<em>VirtualThreads<\/em>&#8220;.<\/li><li><strong>Virtual threads do not support the <em>stop()<\/em>, <em>suspend()<\/em>, or <em>resume()<\/em> methods<\/strong>. These methods throw an <em>UnsupportedOperationException<\/em> when invoked on a virtual thread.<\/li><\/ul>\n\n\n\n<h2>3. Comparing Performance of Platform Threads and Virtual Threads<\/h2>\n\n\n\n<p>Let us understand the difference between both kinds of threads when they are submitted with the same executable code.<\/p>\n\n\n\n<p>To demo it, we have a very simple task that waits for <code>1<\/code> second before printing a message in the console. We are creating this task to keep the example simple so we can focus on the concept.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">final AtomicInteger atomicInteger = new AtomicInteger();\n\nRunnable runnable = () -&gt; {\n  try {\n    Thread.sleep(Duration.ofSeconds(1));\n  } catch(Exception e) {\n      System.out.println(e);\n  }\n  System.out.println(\"Work Done - \" + atomicInteger.incrementAndGet());\n};<\/code><\/pre>\n\n\n\n<p>Now we will create 10,000 threads from this <em><a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/java-runnable-vs-thread\/\">Runnable<\/a><\/em> and execute them with virtual threads and platform threads to compare the performance of both. We will use the <em><a href=\"https:\/\/howtodoinjava.com\/java\/date-time\/calculate-difference-between-two-dates-in-java\/\">Duration.between()<\/a><\/em> api to <a href=\"https:\/\/howtodoinjava.com\/java\/date-time\/execution-elapsed-time\/\">measure the elapsed time<\/a> in executing all the tasks.<\/p>\n\n\n\n<p><strong>First, we are using a pool of 100 platform threads.<\/strong> In this way, <em><a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/executor-service-example\/\">Executor<\/a><\/em> will be able to run 100 tasks at a time and other tasks will need to wait. As we have 10,000 tasks so the total time to finish the execution will be approximately 100 seconds.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Instant start = Instant.now();\n\ntry (var executor = Executors.newFixedThreadPool(100)) {\n  for(int i = 0; i &lt; 10_000; i++) {\n    executor.submit(runnable);\n  }\n}\n\nInstant finish = Instant.now();\nlong timeElapsed = Duration.between(start, finish).toMillis();  \nSystem.out.println(\"Total elapsed time : \" + timeElapsed);\t<\/code><\/pre>\n\n\n\n<pre title=\"Output\" class=\"wp-block-code\"><code lang=\"log\" class=\"language-log\">Total elapsed time : 101152 \/\/Approx 101 seconds<\/code><\/pre>\n\n\n\n<blockquote class=\"wp-block-quote is-style-default info\"><p>As of today, virtual threads are a preview API and disabled by default. Use <code>$ java --source 19 --enable-preview Main.java<\/code> to run the code.<\/p><\/blockquote>\n\n\n\n<p>Next, we will replace the <em>Executors.newFixedThreadPool(100)<\/em> with <em><strong>Executors.newVirtualThreadPerTaskExecutor()<\/strong><\/em>. This will <strong>execute all the tasks in virtual threads<\/strong> instead of platform threads.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Instant start = Instant.now();\n\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n  for(int i = 0; i &lt; 10_000; i++) {\n    executor.submit(runnable);\n  }\n}\n\nInstant finish = Instant.now();\nlong timeElapsed = Duration.between(start, finish).toMillis();  \nSystem.out.println(\"Total elapsed time : \" + timeElapsed);\t<\/code><\/pre>\n\n\n\n<pre title=\"Output\" class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Total elapsed time : 1589 \/\/Approx 1.5 seconds<\/code><\/pre>\n\n\n\n<p>Notice the blazing fast performance of virtual threads that brought down the execution time from 100 seconds to 1.5 seconds with no change in the <em>Runnable<\/em> code.<\/p>\n\n\n\n<h2>4. How to Create Virtual Threads<\/h2>\n\n\n\n<h3>4.1. Using <em>Thread.startVirtualThread()<\/em><\/h3>\n\n\n\n<p>This method creates a new virtual thread to execute a given <em>Runnable<\/em> task and schedules it to execute.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Runnable runnable = () -&gt; System.out.println(\"Inside Runnable\");\nThread.startVirtualThread(runnable);\n\n\/\/or\n\nThread.startVirtualThread(() -&gt; {\n\t\/\/Code to execute in virtual thread\n\tSystem.out.println(\"Inside Runnable\");\n});<\/code><\/pre>\n\n\n\n<h3>4.2. Using <em>Thread.Builder<\/em><\/h3>\n\n\n\n<p>If we want to explicitly start the thread after creating it, we can use <code>Thread.ofVirtual()<\/code> that returns a <em>VirtualThreadBuilder<\/em> instance. Its <code>start()<\/code> method starts a virtual thread.<\/p>\n\n\n\n<p>It is worth noting that <em>Thread.ofVirtual().start(runnable)<\/em> is equivalent to <em>Thread.startVirtualThread(runnable)<\/em>.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Runnable runnable = () -&gt; System.out.println(\"Inside Runnable\");\nThread virtualThread = Thread.ofVirtual().start(runnable);<\/code><\/pre>\n\n\n\n<p>We can use the <em>Thread.Builder<\/em> reference to create and start multiple threads.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Runnable runnable = () -&gt; System.out.println(\"Inside Runnable\");\n\nThread.Builder builder = Thread.ofVirtual().name(\"JVM-Thread\");\n\nThread t1 = builder.start(runnable); \nThread t2 = builder.start(runnable);<\/code><\/pre>\n\n\n\n<p>A similar API <code>Thread.ofPlatform()<\/code> exists for creating platform threads as well.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">Thread.Builder builder = Thread.ofPlatform().name(\"Platform-Thread\");\n\nThread t1 = builder.start(() -&gt; {...}); \nThread t2 = builder.start(() -&gt; {...});<\/code><\/pre>\n\n\n\n<h3>4.3. Using <em>Executors.newVirtualThreadPerTaskExecutor()<\/em><\/h3>\n\n\n\n<p>This method <strong>creates one new virtual thread per task<\/strong>. The number of threads created by the <em>Executor<\/em> is unbounded. <\/p>\n\n\n\n<p>In the following example, we are submitting 10,000 tasks and waiting for all of them to complete. The code will create 10,000 virtual threads to complete these 10,000 tasks.<\/p>\n\n\n\n<p>Note that the following syntax is part of <a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/structured-concurrency\/\">structured concurrency<\/a>, another new feature proposed in <strong><em>Project Loom<\/em><\/strong>. We will discuss it in a separate post.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    IntStream.range(0, 10_000).forEach(i -&gt; {\n        executor.submit(() -&gt; {\n            Thread.sleep(Duration.ofSeconds(1));\n            return i;\n        });\n    });\n}<\/code><\/pre>\n\n\n\n<h2>5. Best Practices<\/h2>\n\n\n\n<h3>5.1. DO NOT Pool the Virtual Threads<\/h3>\n\n\n\n<p>Java thread pool was designed to avoid the overhead of creating new OS threads because creating them was a costly operation. But creating virtual threads is not expensive, so, there is never a need to pool them. It is advised to create a new virtual thread everytime we need one.<\/p>\n\n\n\n<p>Note that after using the virtual threads, our application may be able to handle millions of threads, but other systems or platforms handle only a few requests at a time. For example, we can have only a few database connections or network connections to other servers.<\/p>\n\n\n\n<p>In these cases also, do not use the thread pool. Instead, use <a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/throttling-task-submission-rate-using-threadpoolexecutor-and-semaphore\/\">semaphores<\/a> to make sure only a specified number of threads are accessing that resource.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">private static final Semaphore SEMAPHORE = new Semaphore(50);\n\nSEMAPHORE.acquire();\n\ntry {\n  \/\/ semaphore limits to 50 concurrent access requests\n  \/\/Access the database or resource\n} finally {\n  SEMAPHORE.release();\n}<\/code><\/pre>\n\n\n\n<h3>5.2. Avoid using Thread-local Variables<\/h3>\n\n\n\n<p>Virtual threads support thread-local behavior the same way as platform threads, but because the virtual threads can be created in millions, thread-local variables should be used only after careful consideration.<\/p>\n\n\n\n<p>For example, if we scale a million virtual threads in the application, there will be a million <em><a href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/when-and-how-to-use-thread-local-variables\/\">ThreadLocal<\/a><\/em> instances along with the data they refer to. Such a large number of instances can put enough burden on the physical memory and it should be avoided.<\/p>\n\n\n\n<p><a href=\"https:\/\/openjdk.org\/jeps\/8263012\" target=\"_blank\" rel=\"noreferrer noopener\">Extent-Local variables<\/a>, if included in Java, may prove a better alternative.<\/p>\n\n\n\n<h3>5.3. Use <em>ReentrantLock<\/em> instead of <em>Synchronized<\/em> Blocks<\/h3>\n\n\n\n<p>There are two specific scenarios in which a virtual thread can block the platform thread (called <strong>pinning of OS threads<\/strong>).<\/p>\n\n\n\n<ul><li>When it executes code inside a <a href=\"https:\/\/howtodoinjava.com\/java\/keywords\/java-synchronized\/\">synchronized<\/a> block or method, or<\/li><li>When it executes a <em>native method<\/em> or a <em>foreign function<\/em>.<\/li><\/ul>\n\n\n\n<p>Such <code>synchronized<\/code> block does not make the application incorrect, but it limits the scalability of the application similar to platform threads.<\/p>\n\n\n\n<p>As a best practice, if a method is used very frequently and it uses a <em>synchronized<\/em> block then consider replacing it with the <em>ReentrantLock<\/em> mechanism.<\/p>\n\n\n\n<p>So instead of using <code>synchronized<\/code> block like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public synchronized void m() {\n\ttry {\n\t \t\/\/ ... access resource\n\t} finally {\n\t \t\/\/\n\t}\n}<\/code><\/pre>\n\n\n\n<p>use <code>ReentrantLock<\/code> like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">private final ReentrantLock lock = new ReentrantLock();\n\npublic void m() {\n\tlock.lock();  \/\/ block until condition holds\n\ttry {\n\t \t\/\/ ... access resource\n\t} finally {\n\t \tlock.unlock();\n\t}\n}<\/code><\/pre>\n\n\n\n<p>It is suggested that <strong>there is no need to replace <em>synchronized<\/em> blocks and methods that are used infrequently<\/strong> (e.g., only performed at startup) or that guard in-memory operations.<\/p>\n\n\n\n<h2>6. Conclusion<\/h2>\n\n\n\n<p>Traditional Java threads have served very well for a long time. With the growing demand of scalability and high throughput in the world of microservices, virtual threads will prove a milestone feature in Java history.<\/p>\n\n\n\n<p>With virtual thread, a program can handle millions of threads with a small amount of physical memory and computing resources, otherwise not possible with traditional platform threads. It will also lead to better-written programs when combined with structured concurrency.<\/p>\n\n\n\n<p>Happy Learning !!<\/p>\n\n\n\n<blockquote class=\"wp-block-quote is-style-default download\"><p><a href=\"https:\/\/github.com\/lokeshgupta1981\/Core-Java\/tree\/master\/src\/main\/java\/com\/howtodoinjava\/loom\">Sourcecode on Github<\/a><\/p><\/blockquote>\n","protected":false},"excerpt":{"rendered":"<p>In Java, Virtual threads (JEP-425) are JVM managed light-weight threads that will help in writing high throughput concurrent applications.<\/p>\n","protected":false},"author":2,"featured_media":21889,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[789],"tags":[28,1571,1572],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-150x150.jpg",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-300x127.jpg",300,127,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-768x326.jpg",768,326,true],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads.jpg",878,373,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2022\/07\/Java-Virtual-Threads-120x120.jpg",120,120,true]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"In Java, Virtual threads (JEP-425) are JVM managed light-weight threads that will help in writing high throughput concurrent applications.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/21888"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=21888"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/21888\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/21889"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=21888"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=21888"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=21888"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}