{"id":2768,"date":"2013-07-22T16:34:05","date_gmt":"2013-07-22T11:04:05","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=2768"},"modified":"2022-01-25T15:05:54","modified_gmt":"2022-01-25T09:35:54","slug":"how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/java-security\/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples\/","title":{"rendered":"Java &#8211; Create a Secure Password Hash"},"content":{"rendered":"\n<p>Learn Java hashing algorithms in-depth for hashing the passwords. A secure password hash is an encrypted sequence of characters obtained after applying specific algorithms and manipulations on user-provided passwords, which are generally very weak and easy to guess.<\/p>\n\n\n\n<p>There are many such hashing algorithms in Java that can prove effective for <strong>password security<\/strong>.<\/p>\n\n\n\n<div class=\"wp-block-uagb-inline-notice uagb-inline_notice__outer-wrap uagb-inline_notice__align-left uagb-block-ad38f22e\"><h4 class=\"uagb-notice-title\">Important<\/h4><div class=\"uagb-notice-text\"><p>Please remember that once the password hash has been generated, we can not convert the hash back to the original password.<\/p><\/div><\/div>\n\n\n\n<p>Each time a user login into the application, we must generate the password hash again and match it with the hash stored in the database. <\/p>\n\n\n\n<p>So, if a user forgets his\/her password, we will have to send him a temporary password; or ask him to reset the password. It&#8217;s common nowadays, right?<\/p>\n\n\n\t\t\t\t<div class=\"wp-block-uagb-table-of-contents uagb-toc__align-left uagb-toc__columns-1 uagb-toc__collapse uagb-block-c260a86e \" \n\t\t\t\t\tdata-scroll= \"1\"\n\t\t\t\t\tdata-offset= \"30\"\n\t\t\t\t\tdata-delay= \"800\"\n\t\t\t\t>\n\t\t\t\t<div class=\"uagb-toc__wrap\">\n\t\t\t\t\t<div class=\"uagb-toc__title-wrap\">\n\t\t\t\t\t\t<div class=\"uagb-toc__title\">\n\t\t\t\t\t\t\tTable Of Contents\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"uag-toc__collapsible-wrap\">\t\t\t<svg xmlns=\"https:\/\/www.w3.org\/2000\/svg\" viewBox= \"0 0 320 512\"><path d=\"M143 352.3L7 216.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.2 9.4-24.4 9.4-33.8 0z\"><\/path><\/svg>\n\t\t\t<\/span>\n\t\t\t\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"uagb-toc__list-wrap\">\n\t\t\t\t\t\t<ol class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#1-simplest-password-hash-with-md5-algorithm\">1. Simplest password hash with MD5 Algorithm<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#11-java-md5-hashing-example\">1.1. Java MD5 Hashing Example<\/a><li class=\"uagb-toc__list\"><a href=\"#12-disadvatanges\">1.2. Disadvatanges<\/a><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#2-making-md5-more-secure-using-salt\">2. Making MD5 More Secure using Salt<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#21-how-to-generate-salt\">2.1. How to generate Salt<\/a><li class=\"uagb-toc__list\"><a href=\"#22-generate-md5-with-salt\">2.2. Generate MD5 with Salt<\/a><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#3-better-password-security-using-sha-algorithms\">3. Better Password Security using SHA Algorithms<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#31-java-sha-hashing-example\">3.1. Java SHA Hashing Example<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#4-more-strong-hashes-using-pbkdf2withhmacsha1-algorithm\">4. More Strong Hashes using PBKDF2WithHmacSHA1 Algorithm<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#41-java-pbkdf2withhmacsha1-hash-example\">4.1. Java PBKDF2WithHmacSHA1 Hash Example<\/a><li class=\"uagb-toc__list\"><a href=\"#42-verifying-passwords\">4.2. Verifying Passwords<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#5-hashes-using-bcrypt-and-scrypt\">5. Hashes using Bcrypt and Scrypt<\/a><ul class=\"uagb-toc__list\"><li class=\"uagb-toc__list\"><a href=\"#51-creating-hash-using-bcrypt-with-salt\">5.1. Creating Hash using Bcrypt with Salt<\/a><li class=\"uagb-toc__list\"><a href=\"#52-creating-hash-using-scrypt-with-salt\">5.2. Creating Hash using Scrypt with Salt<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><li class=\"uagb-toc__list\"><a href=\"#6-conclusion\">6. Conclusion<\/a><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/li><\/ul><\/ol>\t\t\t\t\t<\/div>\n\t\t\t\t\t\t\t\t\t<\/div>\n\t\t\t\t<\/div>\n\t\t\t\n\n\n<h2>1. Simplest password hash with MD5 Algorithm<\/h2>\n\n\n\n<p>The <a title=\"md5\" href=\"https:\/\/en.wikipedia.org\/wiki\/MD5\"><strong>MD5 Message-Digest Algorithm<\/strong><\/a> is a widely used <a title=\"hash function\" href=\"https:\/\/en.wikipedia.org\/wiki\/Cryptographic_hash_function\"><strong>cryptographic hash function<\/strong><\/a> that produces a 128-bit (16-byte) hash value. It&#8217;s very simple and straightforward; the <strong>basic idea is to map data sets of variable length to data sets of a fixed size<\/strong>.<\/p>\n\n\n\n<p>To do this, the input message is split into chunks of 512-bit blocks. Padding is added to the end so that its length can be divided by 512. <\/p>\n\n\n\n<p>These blocks are processed by the <a href=\"https:\/\/howtodoinjava.com\/java\/java-security\/sha-md5-file-checksum-hash\/\">MD5 algorithm<\/a>, which operates in a 128-bit state, and the result will be a 128-bit hash value. After applying MD5, the generated hash is typically a 32-digit hexadecimal number.<\/p>\n\n\n\n<p>Here, the password to be encoded is often called the &#8220;<strong>message<\/strong>&#8221; and the generated hash value is called the <strong>message digest<\/strong> or simply &#8220;<strong>digest&#8221;<\/strong>.<\/p>\n\n\n\n<h3>1.1. Java MD5 Hashing Example<\/h3>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\n\r\npublic class SimpleMD5Example \n{\r\n  public static void main(String[] args) \n  {\r\n    String passwordToHash = \"password\";\r\n    String generatedPassword = null;\r\n\r\n    try \n    {\r\n      \/\/ Create MessageDigest instance for MD5\r\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n\r\n      \/\/ Add password bytes to digest\r\n      md.update(passwordToHash.getBytes());\r\n\r\n      \/\/ Get the hash's bytes\r\n      byte[] bytes = md.digest();\r\n\r\n      \/\/ This bytes[] has bytes in decimal format. Convert it to hexadecimal format\r\n      StringBuilder sb = new StringBuilder();\r\n      for (int i = 0; i &lt; bytes.length; i++) {\r\n        sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16).substring(1));\r\n      }\r\n\r\n      \/\/ Get complete hashed password in hex format\r\n      generatedPassword = sb.toString();\r\n    } catch (NoSuchAlgorithmException e) {\r\n      e.printStackTrace();\r\n    }\r\n    System.out.println(generatedPassword);\r\n  }\r\n}<\/code><\/pre>\n\n\n\n<pre title=\"Output\" class=\"wp-block-code\"><code lang=\"bash\" class=\"language-bash\">5f4dcc3b5aa765d61d8327deb882cf99 <\/code><\/pre>\n\n\n\n<h3>1.2. Disadvatanges<\/h3>\n\n\n\n<ul><li>Although MD5 is a widely spread hashing algorithm, is far from being secure, MD5 generates fairly weak hashes. Its main advantages are that it is fast, and easy to implement. But it also means that it is <strong>susceptible to<\/strong> <a title=\"brute force attack\" href=\"https:\/\/en.wikipedia.org\/wiki\/Brute-force_attack\"><strong>brute-force<\/strong><\/a> and <a title=\"dictionary attacks\" href=\"https:\/\/en.wikipedia.org\/wiki\/Dictionary_attack\"><strong>dictionary attacks<\/strong><\/a>.<\/li><li><a title=\"rainbow tables\" href=\"https:\/\/en.wikipedia.org\/wiki\/Rainbow_table\"><strong>Rainbow tables<\/strong><\/a> with words and hashes allow searching very quickly for a known hash and guessing the original password.<\/li><li>MD5 is <strong>not collision resistant<\/strong> which means that different passwords can eventually result in the same hash.<\/li><\/ul>\n\n\n\n<p>If you are using MD5 hash in your application, consider adding some <strong>salt<\/strong> to your security.<a name=\"md5-salt\"><\/a><\/p>\n\n\n\n<h2>2. Making MD5 More Secure using Salt<\/h2>\n\n\n\n<p>Keep in mind, adding salt is not specific to MD5. We can add a Salt to every other algorithm also. So, please focus on how it is applied rather than its relation with MD5.<\/p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>Wikipedia defines salt as random data that are used as an additional input to a one-way function that hashes a password or pass-phrase. <\/p><p>In more simple words, salt is some randomly generated text, which is appended to the password before obtaining hash.<\/p><\/blockquote>\n\n\n\n<p>The <strong>original intent of salting was primarily to defeat pre-computed rainbow table attacks<\/strong> that could otherwise be used to significantly improve the efficiency of cracking the hashed password database. <\/p>\n\n\n\n<p>A more significant benefit is to slow down parallel operations that compare the hash of a password guess against many password hashes at once.<\/p>\n\n\n\n<div class=\"wp-block-uagb-inline-notice uagb-inline_notice__outer-wrap uagb-inline_notice__align-left uagb-block-08f00c58\"><h4 class=\"uagb-notice-title\">Important<\/h4><div class=\"uagb-notice-text\"><p>We always need to use a <a href=\"https:\/\/docs.oracle.com\/javase\/6\/docs\/api\/java\/security\/SecureRandom.html\"><strong>SecureRandom<\/strong><\/a> to create good salts. The Java <em>SecureRandom<\/em> class supports the &#8220;<em><strong>SHA1PRNG<\/strong><\/em>&#8221; pseudo-random number generator algorithm, and we can take advantage of it.<\/p><\/div><\/div>\n\n\n\n<h3>2.1. How to generate Salt<\/h3>\n\n\n\n<p>Let&#8217;s see how we should generate salt.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">private static String getSalt() \r\n    throws NoSuchAlgorithmException, NoSuchProviderException \r\n{\r\n    \/\/ Always use a SecureRandom generator\r\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\", \"SUN\");\r\n\r\n    \/\/ Create array for salt\r\n    byte[] salt = new byte[16];\r\n\r\n    \/\/ Get a random salt\r\n    sr.nextBytes(salt);\r\n\r\n    \/\/ return salt\r\n    return salt.toString();\r\n}<\/code><\/pre>\n\n\n\n<p><strong>SHA1PRNG<\/strong> algorithm is used as a cryptographically strong pseudo-random number generator based on the SHA-1 message-digest algorithm. <\/p>\n\n\n\n<p>Note that if a <strong>seed<\/strong> is not provided, it will generate a seed from a true random number generator (<strong>TRNG<\/strong>).<\/p>\n\n\n\n<h3>2.2. Generate MD5 with Salt<\/h3>\n\n\n\n<p>Now, let&#8217;s look at the modified MD5 hashing example:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.NoSuchProviderException;\r\nimport java.security.SecureRandom;\r\n\r\npublic class SaltedMD5Example \r\n{\r\n    public static void main(String[] args)\r\n            throws NoSuchAlgorithmException, NoSuchProviderException \r\n    {\r\n        String passwordToHash = \"password\";\r\n        String salt = getSalt();\r\n        \r\n        String securePassword = getSecurePassword(passwordToHash, salt);\r\n\r\n        System.out.println(securePassword);\r\n\r\n        String regeneratedPassowrdToVerify =\r\n                getSecurePassword(passwordToHash, salt);\r\n\r\n        System.out.println(regeneratedPassowrdToVerify);\r\n    }\r\n\r\n    private static String getSecurePassword(String passwordToHash,\r\n            String salt) {\r\n        String generatedPassword = null;\r\n        try {\r\n            \/\/ Create MessageDigest instance for MD5\r\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\r\n            \r\n            \/\/ Add password bytes to digest\r\n            md.update(salt.getBytes());\r\n            \r\n            \/\/ Get the hash's bytes\r\n            byte[] bytes = md.digest(passwordToHash.getBytes());\r\n            \r\n            \/\/ This bytes[] has bytes in decimal format;\r\n            \/\/ Convert it to hexadecimal format\r\n            StringBuilder sb = new StringBuilder();\r\n            \r\n            for (int i = 0; i &lt; bytes.length; i++) {\r\n                sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16)\r\n                        .substring(1));\r\n            }\r\n            \r\n            \/\/ Get complete hashed password in hex format\r\n            generatedPassword = sb.toString();\r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return generatedPassword;\r\n    }\r\n\r\n    \/\/ Add salt\r\n    private static String getSalt()\r\n            throws NoSuchAlgorithmException, NoSuchProviderException \r\n    {\r\n        \/\/ Always use a SecureRandom generator\r\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\", \"SUN\");\r\n\r\n        \/\/ Create array for salt\r\n        byte[] salt = new byte[16];\r\n\r\n        \/\/ Get a random salt\r\n        sr.nextBytes(salt);\r\n\r\n        \/\/ return salt\r\n        return salt.toString();\r\n    }\r\n}\r<\/code><\/pre>\n\n\n\n<p>Please note that now you have to store this salt value for every password you hash. Because when user login back into the system, we must use only originally generated salt to create again the hash to match with the stored hash. If a different salt is used (we are generating random salt), then generated hash will be different.<\/p>\n\n\n\n<p>Also, you might hear of the terms <strong>crazy hashing and salting<\/strong>. It generally refers to creating custom combinations.<\/p>\n\n\n\n<blockquote class=\"wp-block-quote is-style-large\"><p>alt + password + salt =&gt; Generated hash<\/p><\/blockquote>\n\n\n\n<p>Do not practice these crazy things. They do not help in making hashes further secure anyhow. If you want more security, choose a better algorithm.<a name=\"sha\"><\/a><\/p>\n\n\n\n<h2>3. Better Password Security using SHA Algorithms<\/h2>\n\n\n\n<p>The <a title=\"sha algorithm\" href=\"https:\/\/en.wikipedia.org\/wiki\/Secure_Hash_Algorithm\"><strong>SHA (Secure Hash Algorithm)<\/strong><\/a> is a family of cryptographic hash functions. It is very similar to MD5, except it <strong>generates more strong hashes<\/strong>. <\/p>\n\n\n\n<p>However, SHA hashes are not always unique, and it means that we could have equal hashes for two different inputs. When this happens, it&#8217;s called a &#8220;collision&#8221;. The chances of collision in SHA are less than MD5. But, do not worry about these collisions because they are very rare.<\/p>\n\n\n\n<p>Java has four implementations of the SHA algorithm. They generate the following length hashes in comparison to MD5 (128-bit hash):<\/p>\n\n\n\n<ul><li><strong>SHA-1<\/strong> (Simplest one \u2013 160 bits Hash)<\/li><li><strong>SHA-256<\/strong> (Stronger than SHA-1 \u2013 256 bits Hash)<\/li><li><strong>SHA-384<\/strong> (Stronger than SHA-256 \u2013 384 bits Hash)<\/li><li><strong>SHA-512<\/strong> (Stronger than SHA-384 \u2013 512 bits Hash)<\/li><\/ul>\n\n\n\n<p>A longer hash is more challenging to break. That&#8217;s the core idea.<\/p>\n\n\n\n<p>To get any implementation of the algorithm, pass it as a parameter to <code>MessageDigest<\/code>. e.g.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">MessageDigest md = MessageDigest.getInstance(\"SHA-512\");\n\n\/\/OR\n\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");<\/code><\/pre>\n\n\n\n<h3>3.1. Java SHA Hashing Example<\/h3>\n\n\n\n<p>Let&#8217;s create a test program to demonstrate SHA hash generation:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.SecureRandom;\r\n\r\npublic class SHAExample {\r\n\r\n    public static void main(String[] args) throws NoSuchAlgorithmException {\r\n        String passwordToHash = \"password\";\r\n        String salt = getSalt();\r\n\r\n        String securePassword = get_SHA_1_SecurePassword(passwordToHash, salt);\r\n        System.out.println(securePassword);\r\n\r\n        securePassword = get_SHA_256_SecurePassword(passwordToHash, salt);\r\n        System.out.println(securePassword);\r\n\r\n        securePassword = get_SHA_384_SecurePassword(passwordToHash, salt);\r\n        System.out.println(securePassword);\r\n\r\n        securePassword = get_SHA_512_SecurePassword(passwordToHash, salt);\r\n        System.out.println(securePassword);\r\n    }\r\n\r\n    private static String get_SHA_1_SecurePassword(String passwordToHash,\r\n            String salt) {\r\n        String generatedPassword = null;\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\r\n            md.update(salt.getBytes());\r\n            byte[] bytes = md.digest(passwordToHash.getBytes());\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int i = 0; i &lt; bytes.length; i++) {\r\n                sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16)\r\n                        .substring(1));\r\n            }\r\n            generatedPassword = sb.toString();\r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return generatedPassword;\r\n    }\r\n\r\n    private static String get_SHA_256_SecurePassword(String passwordToHash,\r\n            String salt) {\r\n        String generatedPassword = null;\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\r\n            md.update(salt.getBytes());\r\n            byte[] bytes = md.digest(passwordToHash.getBytes());\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int i = 0; i &lt; bytes.length; i++) {\r\n                sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16)\r\n                        .substring(1));\r\n            }\r\n            generatedPassword = sb.toString();\r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return generatedPassword;\r\n    }\r\n\r\n    private static String get_SHA_384_SecurePassword(String passwordToHash,\r\n            String salt) {\r\n        String generatedPassword = null;\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"SHA-384\");\r\n            md.update(salt.getBytes());\r\n            byte[] bytes = md.digest(passwordToHash.getBytes());\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int i = 0; i &lt; bytes.length; i++) {\r\n                sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16)\r\n                        .substring(1));\r\n            }\r\n            generatedPassword = sb.toString();\r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return generatedPassword;\r\n    }\r\n\r\n    private static String get_SHA_512_SecurePassword(String passwordToHash,\r\n            String salt) {\r\n        String generatedPassword = null;\r\n        try {\r\n            MessageDigest md = MessageDigest.getInstance(\"SHA-512\");\r\n            md.update(salt.getBytes());\r\n            byte[] bytes = md.digest(passwordToHash.getBytes());\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int i = 0; i &lt; bytes.length; i++) {\r\n                sb.append(Integer.toString((bytes[i] &amp; 0xff) + 0x100, 16)\r\n                        .substring(1));\r\n            }\r\n            generatedPassword = sb.toString();\r\n        } catch (NoSuchAlgorithmException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return generatedPassword;\r\n    }\r\n\r\n    \/\/ Add salt\r\n    private static String getSalt() throws NoSuchAlgorithmException {\r\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\r\n        byte[] salt = new byte[16];\r\n        sr.nextBytes(salt);\r\n        return salt.toString();\r\n    }\r\n}\r\n<\/code><\/pre>\n\n\n\n<pre title=\"Output\" class=\"wp-block-code\"><code lang=\"bash\" class=\"language-bash\">e4c53afeaa7a08b1f27022abd443688c37981bc4\n\n87adfd14a7a89b201bf6d99105b417287db6581d8aee989076bb7f86154e8f32\n\nbc5914fe3896ae8a2c43a4513f2a0d716974cc305733847e3d49e1ea52d1ca50e2a9d0ac192acd43facfb422bb5ace88\n\n529211542985b8f7af61994670d03d25d55cc9cd1cff8d57bb799c4b586891e112b197530c76744bcd7ef135b58d47d65a0bec221eb5d77793956cf2709dd012<\/code><\/pre>\n\n\n\n<p>Very quickly, we can say that SHA-512 generates the most robust Hash.<a name=\"PBKDF2WithHmacSHA1\"><\/a><\/p>\n\n\n\n<h2>4. More Strong Hashes using PBKDF2WithHmacSHA1 Algorithm<\/h2>\n\n\n\n<p>So far, we have learned about creating secure hashes for passwords and using salt to make it even more secure. But the problem today is that hardwares have become so fast than any brute force attack using dictionary and rainbow tables, a bad actor can crack any password in less or more time.<\/p>\n\n\n\n<p>To solve this problem, the <strong>general idea is to make brute force attacks slower<\/strong> to minimize damage. Our following algorithm works on this very concept. <\/p>\n\n\n\n<p>The goal is to make the hash function slow enough to impede attacks but still fast enough to not cause a noticeable delay for the user.<\/p>\n\n\n\n<p>This feature is essentially implemented using some <strong>CPU-intensive algorithms<\/strong> such as <strong>PBKDF2, <a title=\"Bcrypt\" href=\"https:\/\/en.wikipedia.org\/wiki\/Bcrypt\">Bcrypt <\/a><\/strong>or <a title=\"Scrypt\" href=\"https:\/\/en.wikipedia.org\/wiki\/Scrypt\"><strong>Scrypt<\/strong><\/a>. These algorithms take a <em>work factor<\/em> (also known as security factor) or iteration count as an argument. <\/p>\n\n\n\n<p><em>Iteration count<\/em> determines how slow the hash function will be. When computers become faster next year, we can increase the work factor to balance it out.<\/p>\n\n\n\n<p>Java has implemented &#8220;<a title=\"PBKDF2\" href=\"https:\/\/en.wikipedia.org\/wiki\/PBKDF2\"><strong>PBKDF2<\/strong><\/a>&#8221; algorithm as &#8220;<a href=\"https:\/\/docs.oracle.com\/javase\/7\/docs\/technotes\/guides\/security\/StandardNames.html#SecretKeyFactory\"><strong>PBKDF2WithHmacSHA1<\/strong><\/a>&#8220;.<\/p>\n\n\n\n<h3>4.1. Java PBKDF2WithHmacSHA1 Hash Example<\/h3>\n\n\n\n<p>Let&#8217;s look at the example of how to use <em>PBKDF2WithHmacSHA1<\/em> algorithm.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public static void main(String[] args) \n    throws NoSuchAlgorithmException, InvalidKeySpecException\n{\n    String  originalPassword = \"password\";\n\n    String generatedSecuredPasswordHash \n        = generateStorngPasswordHash(originalPassword);\n    System.out.println(generatedSecuredPasswordHash);\n}\nprivate static String generateStorngPasswordHash(String password) \n    throws NoSuchAlgorithmException, InvalidKeySpecException\n{\n    int iterations = 1000;\n    char[] chars = password.toCharArray();\n    byte[] salt = getSalt();\n\n    PBEKeySpec spec = new PBEKeySpec(chars, salt, iterations, 64 * 8);\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n\n    byte[] hash = skf.generateSecret(spec).getEncoded();\n    return iterations + \":\" + toHex(salt) + \":\" + toHex(hash);\n}\n\nprivate static byte[] getSalt() throws NoSuchAlgorithmException\n{\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    byte[] salt = new byte[16];\n    sr.nextBytes(salt);\n    return salt;\n}\n\nprivate static String toHex(byte[] array) throws NoSuchAlgorithmException\n{\n    BigInteger bi = new BigInteger(1, array);\n    String hex = bi.toString(16);\n    \n    int paddingLength = (array.length * 2) - hex.length();\n    if(paddingLength > 0)\n    {\n        return String.format(\"%0\"  +paddingLength + \"d\", 0) + hex;\n    }else{\n        return hex;\n    }\n}<\/code><\/pre>\n\n\n\n<pre title=\"Output\" class=\"wp-block-code\"><code lang=\"bash\" class=\"language-bash\">1000:5b4240333032306164:f38d165fce8ce42f59d366139ef5d9e1ca1247f0e06e503ee1a611dd9ec40876bb5edb8409f5abe5504aab6628e70cfb3d3a18e99d70357d295002c3d0a308a0<\/code><\/pre>\n\n\n\n<h3>4.2. Verifying Passwords<\/h3>\n\n\n\n<p>The next step is to have a function that we can use to validate the password again when the user comes back and login.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public static void main(String[] args) \r\n    throws NoSuchAlgorithmException, InvalidKeySpecException\r\n{\r\n    String  originalPassword = \"password\";\r\n\r\n    String generatedSecuredPasswordHash \r\n        = generateStorngPasswordHash(originalPassword);\r\n    System.out.println(generatedSecuredPasswordHash);\r\n\r\n    boolean matched = validatePassword(\"password\", generatedSecuredPasswordHash);\r\n    System.out.println(matched);\r\n\r\n    matched = validatePassword(\"password1\", generatedSecuredPasswordHash);\r\n    System.out.println(matched);\r\n}\r\n\r\nprivate static boolean validatePassword(String originalPassword, String storedPassword) \r\n    throws NoSuchAlgorithmException, InvalidKeySpecException\r\n{\r\n    String[] parts = storedPassword.split(\":\");\r\n    int iterations = Integer.parseInt(parts[0]);\r\n\r\n    byte[] salt = fromHex(parts[1]);\r\n    byte[] hash = fromHex(parts[2]);\r\n\r\n    PBEKeySpec spec = new PBEKeySpec(originalPassword.toCharArray(), \r\n        salt, iterations, hash.length * 8);\r\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\r\n    byte[] testHash = skf.generateSecret(spec).getEncoded();\r\n\r\n    int diff = hash.length ^ testHash.length;\r\n    for(int i = 0; i &lt; hash.length &amp;&amp; i &lt; testHash.length; i++)\r\n    {\r\n        diff |= hash[i] ^ testHash[i];\r\n    }\r\n    return diff == 0;\r\n}\r\nprivate static byte[] fromHex(String hex) throws NoSuchAlgorithmException\r\n{\r\n    byte[] bytes = new byte[hex.length() \/ 2];\r\n    for(int i = 0; i &lt; bytes.length ;i++)\r\n    {\r\n        bytes[i] = (byte)Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);\r\n    }\r\n    return bytes;\r\n}<\/code><\/pre>\n\n\n\n<p>Please refer to functions from the above code samples. If found any difficulty, then download the source code attached at the end of the tutorial.<a name=\"bcrypt-scrypt\"><\/a><\/p>\n\n\n\n<h2>5. Hashes using Bcrypt and Scrypt<\/h2>\n\n\n\n<p>The concepts behind bcrypt is similar to the previous concept as in PBKDF2. It just happened to be that Java does not have any inbuilt support for bcrypt algorithm to make the attack slower but still, you can find one such implementation in the attached source code.<\/p>\n\n\n\n<h3>5.1. Creating Hash using Bcrypt with Salt<\/h3>\n\n\n\n<p>Let&#8217;s look at the sample usage code (<em>BCrypt.java is available in the source code<\/em>).<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public class BcryptHashingExample\n{\n\tpublic static void main(String[] args) throws NoSuchAlgorithmException\n\t{\n\t\tString  originalPassword = \"password\";\n\t\tString generatedSecuredPasswordHash = BCrypt.hashpw(originalPassword, BCrypt.gensalt(12));\n\t\tSystem.out.println(generatedSecuredPasswordHash);\n\n\t\tboolean matched = BCrypt.checkpw(originalPassword, generatedSecuredPasswordHash);\n\t\tSystem.out.println(matched);\n\t}\n}<\/code><\/pre>\n\n\n\n<pre title=\"Ouput\" class=\"wp-block-code\"><code lang=\"bash\" class=\"language-bash\">$2a$12$WXItscQ\/FDbLKU4mO58jxu3Tx\/mueaS8En3M6QOVZIZLaGdWrS.pK\ntrue<\/code><\/pre>\n\n\n\n<h3> 5.2. Creating Hash using Scrypt with Salt <\/h3>\n\n\n\n<p>Like bcrypt, I have downloaded scrypt from github and added the source code of the scrypt algorithm in the sourcecode.<\/p>\n\n\n\n<p>Let&#8217;s see how to use the implementation:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">public class ScryptPasswordHashingDemo\n{\n\tpublic static void main(String[] args) {\n\t\tString originalPassword = \"password\";\n\t\tString generatedSecuredPasswordHash = SCryptUtil.scrypt(originalPassword, 16, 16, 16);\n\t\tSystem.out.println(generatedSecuredPasswordHash);\n\n\t\tboolean matched = SCryptUtil.check(\"password\", generatedSecuredPasswordHash);\n\t\tSystem.out.println(matched);\n\n\t\tmatched = SCryptUtil.check(\"passwordno\", generatedSecuredPasswordHash);\n\t\tSystem.out.println(matched);\n\t}\n}\n<a name=\"summary\"><\/a><\/code><\/pre>\n\n\n\n<pre title=\"Ouput\" class=\"wp-block-code\"><code lang=\"bash\" class=\"language-bash\">$s0$41010$Gxbn9LQ4I+fZ\/kt0glnZgQ==$X+dRy9oLJz1JaNm1xscUl7EmUFHIILT1ktYB5DQ3fZs=\ntrue\nfalse<\/code><\/pre>\n\n\n\n<h2>6. Conclusion<\/h2>\n\n\n\n<ol><li>Storing the text password with hashing is most dangerous thing for application security today.<\/li><li>MD5 provides basic hashing for generating secure password hash. Adding salt make it further stronger.<\/li><li>MD5 generates 128 bit hash. To make ti more secure, use SHA algorithm which generate hashes from 160-bit to 512-bit long. 512-bit is strongest.<\/li><li>Even SHA hashed secure passwords are able to be cracked with today&#8217;s fast hardwares. To beat that, you will need algorithms which can make the brute force attacks slower and minimize the impact. Such algorithms are PBKDF2, BCrypt and SCrypt.<\/li><li>Please take a well considered thought before applying appropriate security algorithm.<\/li><\/ol>\n\n\n\n<p>To download the source code of the above algorithm examples, please follow the below link.<\/p>\n\n\n\n<p>Happy Learning !!<\/p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p><a href=\"https:\/\/github.com\/lokeshgupta1981\/Core-Java\/tree\/master\/src\/main\/java\/com\/howtodoinjava\/hashing\/password\/demo\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Download sourcecode<\/strong><\/a><\/p><\/blockquote>\n","protected":false},"excerpt":{"rendered":"<p>Learn Java Secure Hashing algorithms in-depth. Java examples of MD5, SHA256, SHA512, PBKDF2, BCrypt, SCrypt algorithms with salt to create secure passwords.<\/p>\n","protected":false},"author":2,"featured_media":11289,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[42],"tags":[231,1455,1415],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",468,199,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",150,64,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",300,128,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",468,199,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",468,199,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",468,199,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",468,199,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2013\/07\/Java-Secure-Hash-Algorithms.png",120,51,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":94,"uagb_excerpt":"Learn Java Secure Hashing algorithms in-depth. Java examples of MD5, SHA256, SHA512, PBKDF2, BCrypt, SCrypt algorithms with salt to create secure passwords.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/2768"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=2768"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/2768\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/11289"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=2768"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=2768"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=2768"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}