{"id":10236,"date":"2018-04-12T16:57:38","date_gmt":"2018-04-12T11:27:38","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=10236"},"modified":"2020-12-26T00:39:11","modified_gmt":"2020-12-25T19:09:11","slug":"all-garbage-collection-algorithms","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/garbage-collection\/all-garbage-collection-algorithms\/","title":{"rendered":"Java Garbage Collection Algorithms [till Java 9]"},"content":{"rendered":"<p><strong>Garbage collection<\/strong> (GC) has been one of Java&#8217;s great features behind it&#8217;s popularity. Garbage collection is the mechanism used in Java to deallocate unused memory. Essentially, it is <strong>tracking down all the objects that are still used and marks the rest as garbage<\/strong>. Java&#8217;s garbage collection is considered an automatic memory management schema because programmers do not have to designate objects as ready to be deallocated. The garbage collection runs on low-priority threads.<\/p>\n<p>In this tutorial, we will go through various concepts related to memory allocation\/deallocatation, algorithms run behind the scene and what options you have to customize this behavior.<\/p>\n<pre>Table of Contents\r\n\r\n<a href=\"#object-lifecycle\">Object Life Cycle<\/a>\r\n<a href=\"#gc-algorithms\">Garbage collection algorithms<\/a>\r\n\t<a href=\"#mark-sweep\">Mark and sweep<\/a>\r\n\t<a href=\"#cms\">Concurrent mark sweep (CMS) garbage collection<\/a>\r\n\t<a href=\"#serial-gc\">Serial garbage collection<\/a>\r\n\t<a href=\"#parallel-gn\">Parallel garbage collection<\/a>\r\n\t<a href=\"#g1-gc\">G1 garbage collection<\/a>\r\n<a href=\"#options\">Customization Options<\/a>\r\n<a href=\"#summary\">Summary<\/a><\/pre>\n<h2>Object Life Cycle<\/h2>\n<p>A java&#8217;s object life cycle can be seen in 3 stages:<\/p>\n<ol>\n<li>\n<h4>Object creation<\/h4>\n<p>To <a href=\"https:\/\/howtodoinjava.com\/java\/puzzles\/how-to-create-an-instance-of-any-class-without-using-new-keyword\/\">create an object<\/a>, generally we use <code>new<\/code> keyword. e.g.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">Object obj = new Object();<\/pre>\n<p>When an object is created, a specific amount of memory is allocated for storing that object. The amount of memory allocated can differ based on architecture and JVM.<\/li>\n<li>\n<h4>Object in use<\/h4>\n<p>Till the time, object is used by application&#8217;s other objects (other live objects have references pointing to it). During its usage, object reside in memory and may contain references to other objects.<\/li>\n<li>\n<h4>Object destruction<\/h4>\n<p>The garbage collection system monitors objects and, as feasible, counts the number of references to each object. When there are no references to an object, there is no way to get to it with the currently running code, so it makes perfect sense to deallocate the associated memory.<\/li>\n<\/ol>\n<h2>Garbage collection algorithms<\/h2>\n<p>Object creation is done by code you write; and frameworks you use to use their provided features. As a java developer, we are not required to deallocate the memory or dereference the objects. It&#8217;s done automatically at JVM level by gargabe collector. Since java&#8217;s inception, there have been many updates on algorithms which run behind the scene to free the memory. Let&#8217;s see how they work?<\/p>\n<h4>Mark and sweep<\/h4>\n<p>It is initial and very basic algorithm which runs in two stages:<\/p>\n<ol>\n<li><strong>Marking live objects<\/strong> &#8211; find out all objects that are still alive.<\/li>\n<li><strong>Removing unreachable objects<\/strong> &#8211; get rid of everything else \u2013 the supposedly dead and unused objects.<\/li>\n<\/ol>\n<p>To start with, GC defines some specific objects as <strong>Garbage Collection Roots<\/strong>. e.g. local variable and input parameters of the currently executing methods, active threads, static field of the loaded classes and JNI references. Now GC traverses the whole object graph in your memory, starting from those roots and following references from the roots to other objects. Every object the GC visits is marked as alive.<\/p>\n<blockquote><p>The application threads need to be stopped for the marking to happen as it cannot really traverse the graph if it keeps changing. It is called <strong>Stop The World pause<\/strong>.<\/p><\/blockquote>\n<p>Second stage is for getting rid of unused objects to freeup memory. This can be done in variety of ways e.g. <\/p>\n<ul>\n<li><strong>Normal deletion<\/strong> &#8211; Normal deletion removes unreferenced objects to free space and leave referenced objects and pointers. The memory allocator (kind of hashtable) holds references to blocks of free space where new object can be allocated.\n<p>It is often reffred as <code>mark-sweep<\/code> algorithm.<\/p>\n<figure id=\"attachment_10237\" aria-describedby=\"caption-attachment-10237\" style=\"width: 586px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Normal-Deletion-Mark-and-Sweep.png\" alt=\"Normal Deletion - Mark and Sweep\" width=\"596\" height=\"124\" class=\"size-full wp-image-10237\" \/><figcaption id=\"caption-attachment-10237\" class=\"wp-caption-text\">Normal Deletion &#8211; Mark and Sweep<\/figcaption><\/figure>\n<\/li>\n<li><strong>Deletion with compacting<\/strong> &#8211; Only removing unused objects is not efficient because blocks of free memory is scattered across storage area and cause <a href=\"https:\/\/docs.oracle.com\/javase\/9\/docs\/api\/java\/lang\/OutOfMemoryError.html\">OutOfMemoryError<\/a>, if created object big enough and does not find large enough memory block.\n<p>To solve this issue, after deleting unreferenced objects, compacting is done on the remaining referenced objects. Here compacting refer the process of moving referenced object together. This makes new memory allocation much easier and faster.<\/p>\n<p>It is often reffred as <code>mark-sweep-compact<\/code> algorithm.<\/p>\n<p><figure id=\"attachment_10238\" aria-describedby=\"caption-attachment-10238\" style=\"width: 573px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Deletion-with-compacting.png\" alt=\"Deletion with compacting\" width=\"583\" height=\"156\" class=\"size-full wp-image-10238\" \/><figcaption id=\"caption-attachment-10238\" class=\"wp-caption-text\">Deletion with compacting<\/figcaption><\/figure>\n<\/li>\n<li><strong>Deletion with copying<\/strong> &#8211; It is very similar to mark and compacing approach as they too relocate all live objects. The important difference is that the target of relocation is a different memory region.\n<p>It is often reffred as <code>mark-copy<\/code> algorithm.<\/p>\n<p><figure id=\"attachment_10239\" aria-describedby=\"caption-attachment-10239\" style=\"width: 573px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Deletion-with-copying-Mark-and-Sweep.png\" alt=\"Deletion with copying - Mark and Sweep\" width=\"583\" height=\"131\" class=\"size-full wp-image-10239\" \/><figcaption id=\"caption-attachment-10239\" class=\"wp-caption-text\">Deletion with copying &#8211; Mark and Sweep<\/figcaption><\/figure>\n<\/li>\n<\/ul>\n<div class=\"noticeboxesde bluenoticebox\">Before reading further, I will sincerely advise you to read <a href=\"https:\/\/howtodoinjava.com\/java\/garbage-collection\/revisiting-memory-management-and-garbage-collection-mechanisms-in-java\/\">java memory management<\/a> first. It talks about young generation, old generation and permanent generation in pretty detail.<\/div>\n<h4>Concurrent mark sweep (CMS) garbage collection<\/h4>\n<p>CMS garbage collection is essentially an upgraded mark and sweep method. It scans heap memory <strong>using multiple threads<\/strong>. It was modified to take advantage of faster systems and had performance enhancements.<\/p>\n<p>It attempts to minimize the pauses due to garbage collection by doing most of the garbage collection work <em>concurrently<\/em> with the application threads. It uses the parallel stop-the-world <strong>mark-copy<\/strong> algorithm in the Young Generation and the mostly concurrent <strong>mark-sweep<\/strong> algorithm in the Old Generation.<\/p>\n<p>To use CMS GC, use below JVM argument:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">-XX:+UseConcMarkSweepGC<\/pre>\n<h6>CMS GC Optimization Options<\/h6>\n<table class=\"mtr-table mtr-tr-th\">\n<tr>\n<th data-mtr-content=\"Flag\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Flag<\/div><\/th>\n<th data-mtr-content=\"Description\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Description<\/div><\/th>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+UseCMSInitiating\\OccupancyOnly<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Indicates that you want to solely use occupancy as a criterion for starting a CMS collection operation.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:CMSInitiating\\OccupancyFraction=70<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the percentage CMS generation occupancy to start a CMS collection cycle.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:CMSTriggerRatio=70<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This is the percentage of <code>MinHeapFreeRatio<\/code> in CMS generation that is allocated prior to a CMS cycle starts.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:CMSTriggerPermRatio=90<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the percentage of <code>MinHeapFreeRatio<\/code> in the CMS permanent generation that is allocated before starting a CMS collection cycle.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:CMSWaitDuration=2000<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Use the parameter to specify how long the CMS is allowed to wait for young collection.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+UseParNewGC<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Elects to use the parallel algorithm for young space collection.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+CMSConcurrentMTEnabled<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Enables the use of multiple threads for concurrent phases.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:ConcGCThreads=2<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the number of parallel threads used for the concurrent phases.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:ParallelGCThreads=2<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the number of parallel threads you want used for <em>stop-the-world<\/em> phases.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+CMSIncrementalMode<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Enable the incremental CMS (iCMS) mode.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+CMSClassUnloadingEnabled<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">If this is not enabled, CMS will not clean permanent space.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+ExplicitGCInvokes\\Concurrent<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This allows <code>System.gc()<\/code> to trigger concurrent collection instead of a full garbage collection cycle.<\/div><\/td>\n<\/tr>\n<\/table>\n<h4>Serial garbage collection<\/h4>\n<p>This algorithm uses <em>mark-copy<\/em> for the Young Generation and <em>mark-sweep-compact<\/em> for the Old Generation. It works on a single thread. When executing, it freezes all other threads until garbage collection operations have concluded. <\/p>\n<p>Due to the thread-freezing nature of serial garbage collection, it is only feasible for very small programs.<\/p>\n<p>To use Serial GC, use below JVM argument:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">-XX:+UseSerialGC<\/pre>\n<h4>Parallel garbage collection<\/h4>\n<p>Simimar to serial GC, It uses <code>mark-copy<\/code> in the Young Generation and <code>mark-sweep-compact<\/code> in the Old Generation. Multiple concurrent threads are used for marking and copying \/ compacting phases. You can configure the number of threads using <code>-XX:ParallelGCThreads=N<\/code> option.<\/p>\n<p>Parallel Garbage Collector is suitable on multi-core machines in cases where your primary goal is to increase throughput by efficient usage of existing system resources. Using this approach, GC cycle times can be considerably reduced.<\/p>\n<div class=\"noticeboxesde bluenoticebox\">Till Java 8, we have seen Parallel GC as default garbage collector. Java 9 onwards, G1 is the default garbage collector on 32- and 64-bit server configurations. &#8211; <a href=\"http:\/\/openjdk.java.net\/jeps\/248\">JEP [248]<\/a><\/div>\n<p>To use parallel GC, use below JVM argument:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">-XX:+UseParallelGC<\/pre>\n<h4>G1 garbage collection<\/h4>\n<p>The G1 (Garbage First) garbage collector was available in Java 7 and is designed to be the long term replacement for the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector. <\/p>\n<p>This approach involves segmenting the memory heap into multiple small regions (typically 2048). Each region is marked as either young generation (further devided into eden regions or survivor regions) or old generation. This allows the GC to avoid collecting the entire heap at once, and instead approach the problem incrementally. It means that only a subset of the regions is considered at a time.<\/p>\n<figure id=\"attachment_10241\" aria-describedby=\"caption-attachment-10241\" style=\"width: 510px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png\" alt=\"Memory regions marked - G1\" width=\"520\" height=\"207\" class=\"size-full wp-image-10241\" \/><figcaption id=\"caption-attachment-10241\" class=\"wp-caption-text\">Memory regions marked &#8211; G1<\/figcaption><\/figure>\n<p>G1 keep tracking of the amount of live data that each region contains. This information is used in determining the regions that contain the most garbage; so they are collected first. That&#8217;s why it is name <strong>garbage-first<\/strong> collection.<\/p>\n<p>Just like other algorithms, unfortunately, the compacting operation takes place using the <em>Stop the World<\/em> approach. But as per it&#8217;s design goal, you can set specific performance goals to it. You can configure the pauses duration e.g. no more than 10 milliseconds in any given second.  Garbage-First GC will do its best to meet this goal with high probability (but not with certainty, that would be hard real-time due to OS level thread management).<\/p>\n<p>If you want to use in Java 7 or Java 8 machines, use JVM argument as below:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">-XX:+UseG1GC<\/pre>\n<h6>G1 Optimization Options<\/h6>\n<table class=\"mtr-table mtr-tr-th\">\n<tr>\n<th data-mtr-content=\"Flag\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Flag<\/div><\/th>\n<th data-mtr-content=\"Description\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Description<\/div><\/th>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:G1HeapRegionSize=16m<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Size of the heap region. The value will be a power of two and can range from 1MB to 32MB. The goal is to have around 2048 regions based on the minimum Java heap size.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:MaxGCPauseMillis=200<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets a target value for desired maximum pause time. The default value is 200 milliseconds. The specified value does not adapt to your heap size.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:G1ReservePercent=5<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This determines the minimum reserve in the heap.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:G1ConfidencePercent=75<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This is the confidence coefficient pause prediction heuristics.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:GCPauseIntervalMillis=200<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This is the pause interval time slice per MMU in milliseconds.<\/div><\/td>\n<\/tr>\n<\/table>\n<h2>GC Customization Options<\/h2>\n<h4>GC configuration flags<\/h4>\n<table class=\"mtr-table mtr-tr-th\">\n<tr>\n<th data-mtr-content=\"Flag\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Flag<\/div><\/th>\n<th data-mtr-content=\"Description\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Description<\/div><\/th>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-Xms2048m -Xmx3g<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the initial and maximum heap size (young space plus tenured space).<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+DisableExplicitGC<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This will cause the JVM to ignore any System.gc() method invocations by an application.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+UseGCOverheadLimit<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This is the use policy used to limit the time spent in garbage collection before an OutOfMemory error is thrown.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:GCTimeLimit=95<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This limits the proportion of time spent in garbage collection before an <code>OutOfMemory<\/code> error is thrown. This is used with <code>GCHeapFreeLimit<\/code>.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:GCHeapFreeLimit=5<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This sets the minimum percentage of free space after a full garbage collection before an <code>OutOfMemory<\/code> error is thrown. This is used with <code>GCTimeLimit<\/code>.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:InitialHeapSize=3g<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the initial heap size (young space plus tenured space).<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:MaxHeapSize=3g<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the maximum heap size (young space plus tenured space).<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:NewSize=128m<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the initial size of young space.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:MaxNewSize=128m<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the maximum size of young space.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:SurvivorRatio=15<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the size of single survivor space as a portion of Eden space size.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:PermSize=512m<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the initial size of the permanent space.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:MaxPermSize=512m<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the maximum size of the permanent space.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-Xss512k<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Sets the size of the stack area dedicated to each thread in bytes.<\/div><\/td>\n<\/tr>\n<\/table>\n<h4>GC logging flags<\/h4>\n<table class=\"mtr-table mtr-tr-th\">\n<tr>\n<th data-mtr-content=\"Flag\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Flag<\/div><\/th>\n<th data-mtr-content=\"Description\" class=\"mtr-th-tag\"><div class=\"mtr-cell-content\">Description<\/div><\/th>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-verbose:gc or -XX:+PrintGC<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This prints the basic garbage collection information.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+PrintGCDetails<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This will print more detailed garbage collection information.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+PrintGCTimeStamps<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">You can print timestamps for each garbage collection event. The seconds are sequential and begin from the JVM start time.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+PrintGCDateStamps<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">You can print date stamps for each garbage collection event.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-Xloggc:<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Using this you can redirect garbage collection output to a file instead of the console.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+Print\\TenuringDistribution<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">You can print detailed information regarding young space following each collection cycle.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+PrintTLAB<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">You can use this flag to print TLAB allocation statistics.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+PrintReferenceGC<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">Using this flag, you can print the times for reference processing (that is, weak, soft, and so on) during stop-the-world pauses.<\/div><\/td>\n<\/tr>\n<tr>\n<td data-mtr-content=\"Flag\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">-XX:+HeapDump\\OnOutOfMemoryError<\/div><\/td>\n<td data-mtr-content=\"Description\" class=\"mtr-td-tag\"><div class=\"mtr-cell-content\">This creates a heap dump file in an out-of-memory condition.<\/div><\/td>\n<\/tr>\n<\/table>\n<h2>Summary<\/h2>\n<p>So in this <strong>java garbage collection tutorial<\/strong>, we learned the following &#8211;<\/p>\n<ol>\n<li>Object life cycle is devided into 3 phases i.e. object creation, object in use and object destruction.<\/li>\n<li>How <code>mark-sweep<\/code>, <code>mark-sweep-compact<\/code> and <code>mark-copy<\/code> mechanisms woks.<\/li>\n<li>Different single threaded and concurrent GC algorithms.<\/li>\n<li>Till java 8, parallel GC was default algorithm.<\/li>\n<li>Since java 9, G1 has been set as default GC algorithm.<\/li>\n<li>Also, various flags to control the garbage collection algorithm&#8217;s behavior and log useful information for any application.<\/li>\n<\/ol>\n<p>Drop me your questions in comments section.<\/p>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>In java garbage collection tutorial, we will learn about object life cycle, difference between mark-sweep, mark-sweep-compact and mark-copy mechanisms, different single threaded and concurrent GC algorithms (e.g. G1), and various flags to control the gc algorithm\u2019s behavior and log useful information for applications.<\/p>\n","protected":false},"author":2,"featured_media":10241,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[9],"tags":[222],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",520,207,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",150,60,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",300,119,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",520,207,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",520,207,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",520,207,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",520,207,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2018\/04\/Memory-regions-marked-G1.png",120,48,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":6,"uagb_excerpt":"In java garbage collection tutorial, we will learn about object life cycle, difference between mark-sweep, mark-sweep-compact and mark-copy mechanisms, different single threaded and concurrent GC algorithms (e.g. G1), and various flags to control the gc algorithm\u2019s behavior and log useful information for applications.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/10236"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=10236"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/10236\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/10241"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=10236"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=10236"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=10236"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}