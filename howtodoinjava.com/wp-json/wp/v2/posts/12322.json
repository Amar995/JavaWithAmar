{"id":12322,"date":"2019-02-12T17:40:17","date_gmt":"2019-02-12T12:10:17","guid":{"rendered":"https:\/\/howtodoinjava.com\/?p=12322"},"modified":"2022-01-28T15:01:15","modified_gmt":"2022-01-28T09:31:15","slug":"spring-webflux-tutorial","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/spring-webflux\/spring-webflux-tutorial\/","title":{"rendered":"Building Async REST APIs with Spring WebFlux"},"content":{"rendered":"<p>The reactive-stack web framework, <strong>Spring WebFlux<\/strong>, has been added Spring 5.0. It is fully non-blocking, supports <a href=\"http:\/\/www.reactive-streams.org\/\" target=\"_default\" rel=\"noopener noreferrer\">reactive streams<\/a> back pressure, and runs on such servers as Netty, Undertow, and Servlet 3.1+ containers. In this <strong>spring webflux tutorial<\/strong>, we will learn the basic concepts behind reactive programming, webflux apis and a fully functional hello world example.<\/p>\n<h2>1. Reactive Programming<\/h2>\n<p>Reactive programming is a programming paradigm that promotes an asynchronous, non-blocking, event-driven approach to data processing. Reactive programming involves modeling data and events as observable data streams and implementing data processing routines to react to the changes in those streams. <\/p>\n<p>Before digging deeper into reactive world, first understand the difference between blocking vs non-blocking request processing.<\/p>\n<h4>1.1. Blocking vs non-blocking (async) request processing<\/h4>\n<h6>1.1.1. Blocking request processing<\/h6>\n<p>In traditional MVC applications, when a request come to server, a servlet thread is created. It delegates the request to worker threads for I\/O operations such as database access etc. During the time worker threads are busy, servlet thread (request thread) remain in waiting status and thus it is blocked. It is also called <strong>synchronous request processing<\/strong>.<\/p>\n<figure id=\"attachment_12323\" aria-describedby=\"caption-attachment-12323\" style=\"width: 1226px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Blocking-request-processing.png\" alt=\"Blocking request processing\" width=\"1236\" height=\"412\" class=\"size-full wp-image-12323\" \/><figcaption id=\"caption-attachment-12323\" class=\"wp-caption-text\">Blocking request processing<\/figcaption><\/figure>\n<p>As server can have some finite number of request threads, it limits the server capability to process that number of requests at maximum server load. It may hamper the performance and limit the full utilization of server capability.<\/p>\n<h6>1.1.2. Non-blocking request processing<\/h6>\n<p>In non-blocking or asynchronous request processing, no thread is in waiting state. There is generally only one request thread receiving the request. <\/p>\n<p>All incoming requests come with a event handler and call back information. Request thread delegates the incoming requests to a thread pool (generally small number of threads) which delegate the request to it&#8217;s handler function and immediately start processing other incoming requests from request thread.<\/p>\n<p>When the handler function is complete, one of thread from pool collect the response and pass it to the call back function.<\/p>\n<figure id=\"attachment_12324\" aria-describedby=\"caption-attachment-12324\" style=\"width: 1188px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png\" alt=\"Non-blocking request processing\" width=\"1198\" height=\"438\" class=\"size-full wp-image-12324\" \/><figcaption id=\"caption-attachment-12324\" class=\"wp-caption-text\">Non-blocking request processing<\/figcaption><\/figure>\n<p>Non-blocking nature of threads helps in scaling the performance of the application. Small number of threads means less memory utilization and also less context switching as well.<\/p>\n<h4>1.2. What is reactive programming?<\/h4>\n<p>The term, \u201creactive,\u201d refers to programming models that are built around reacting to changes. It is build around publisher-subscriber pattern (<a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/observer-design-pattern\/\">observer pattern<\/a>). In reactive style of programming, we make a request for resource and start performing other things. When the data is available, we get the notification along with data inform of call back function. In callback function, we handle the response as per application\/user needs.<\/p>\n<p>One important thing to remember is back pressure. In non-blocking code, it becomes important to <strong>control the rate of events<\/strong> so that a fast producer does not overwhelm its destination.<\/p>\n<p>Reactive web programming is great for applications that have streaming data, and clients that consume it and stream it to their users. It is not great for developing traditional CRUD applications. If you\u2019re developing the next <em>Facebook<\/em> or <em>Twitter<\/em> with lots of data, a reactive API might be just what you\u2019re looking for.<\/p>\n<h2>2. Reactive Streams API<\/h2>\n<p>The new Reactive Streams API was created by engineers from Netflix, Pivotal, Lightbend, RedHat, Twitter, and Oracle, among others and is now part of Java 9. It defines four interfaces:<\/p>\n<ul>\n<li><strong><a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm\/blob\/v1.0.2\/api\/src\/main\/java\/org\/reactivestreams\/Publisher.java\" target=\"_default\" rel=\"noopener noreferrer\">Publisher<\/a><\/strong>: Emits a sequence of events to subscribers according to the demand received from its subscribers. A publisher can serve multiple subscribers.\n<p>It has a single method:<\/p>\n<pre class=\"brush: java; title: Publisher.java; notranslate\" title=\"Publisher.java\">\r\npublic interface Publisher&lt;T&gt; \r\n{\r\n\tpublic void subscribe(Subscriber&lt;? super T&gt; s);\r\n}\r\n<\/pre>\n<\/li>\n<li><strong><a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm\/blob\/v1.0.2\/api\/src\/main\/java\/org\/reactivestreams\/Subscriber.java\" target=\"_default\" rel=\"noopener noreferrer\">Subscriber<\/a><\/strong>: Receives and processes events emitted by a Publisher. Please note that no notifications will be received until <code>Subscription#request(long)<\/code> is called to signal the demand.\n<p>It has four methods to handle various kind of responses received.<\/p>\n<pre class=\"brush: java; title: Subscriber.java; notranslate\" title=\"Subscriber.java\">\r\npublic interface Subscriber&lt;T&gt; \r\n{\r\n\tpublic void onSubscribe(Subscription s);\r\n\tpublic void onNext(T t);\r\n\tpublic void onError(Throwable t);\r\n\tpublic void onComplete();\r\n}\r\n<\/pre>\n<\/li>\n<li><strong><a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm\/blob\/v1.0.2\/api\/src\/main\/java\/org\/reactivestreams\/Subscription.java\" target=\"_default\" rel=\"noopener noreferrer\">Subscription<\/a><\/strong>: Defines a one-to-one relationship between a <code>Publisher<\/code> and a <code>Subscriber<\/code>. It can only be used once by a single <code>Subscriber<\/code>. It is used to both signal desire for data and cancel demand (and allow resource cleanup).\n<pre class=\"brush: java; title: Subscription.java; notranslate\" title=\"Subscription.java\">\r\npublic interface Subscription&lt;T&gt; \r\n{\r\n\tpublic void request(long n);\r\n\tpublic void cancel();\r\n}\r\n<\/pre>\n<\/li>\n<li><strong><a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm\/blob\/v1.0.2\/api\/src\/main\/java\/org\/reactivestreams\/Processor.java\" target=\"_default\" rel=\"noopener noreferrer\">Processor<\/a><\/strong>: Represents a processing stage consisting of both a <code>Subscriber<\/code> and a <code>Publisher<\/code> and obeys the contracts of both.\n<pre class=\"brush: java; title: Processor.java; notranslate\" title=\"Processor.java\">\r\npublic interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; \r\n{\r\n}\r\n<\/pre>\n<\/li>\n<\/ul>\n<blockquote><p>Two popular implementations of reactive streams are <a href=\"https:\/\/howtodoinjava.com\/java\/library\/rxjava-tutorial\/\"><strong>RxJava<\/strong><\/a> (https:\/\/github.com\/ReactiveX\/RxJava) and <strong>Project Reactor<\/strong> (https:\/\/projectreactor.io\/).<\/p><\/blockquote>\n<h2>3. What is Spring WebFlux ?<\/h2>\n<p>Spring WebFlux is parallel version of <a href=\"https:\/\/howtodoinjava.com\/spring-mvc-tutorial\/\">Spring MVC<\/a> and supports fully non-blocking reactive streams. It support the back pressure concept and uses <strong><a href=\"https:\/\/netty.io\/\">Netty<\/a><\/strong> as inbuilt server to run reactive applications. If you are familiar with Spring MVC programming style, you can easily work on webflux also.<\/p>\n<p>Spring webflux uses project reactor as reactive library. Reactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure. It is developed in close collaboration with Spring.<\/p>\n<p>Spring WebFlux heavily uses two publishers :<\/p>\n<ul>\n<li><strong>Mono<\/strong>: Returns 0 or 1 element.\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nMono&lt;String&gt; mono = Mono.just(&quot;Alex&quot;);\r\nMono&lt;String&gt; mono = Mono.empty();\r\n<\/pre>\n<\/li>\n<li><strong>Flux<\/strong>: Returns 0&#8230;N elements. A Flux can be endless, meaning that it can keep emitting elements forever. Also it can return a sequence of elements and then send a completion notification when it has returned all of its elements.\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nFlux&lt;String&gt; flux = Flux.just(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);\r\nFlux&lt;String&gt; flux = Flux.fromArray(new String[]{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;});\r\nFlux&lt;String&gt; flux = Flux.fromIterable(Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;));\r\n\r\n\/\/To subscribe call method\r\n\r\nflux.subscribe();\r\n<\/pre>\n<\/li>\n<\/ul>\n<p>In Spring WebFlux, we call reactive APIs\/functions that return monos and fluxes and your controllers will return monos and fluxes. When you invoke an API that returns a mono or a flux, it will return immediately. The results of the function call will be delivered to you through the mono or flux when they become available.<\/p>\n<blockquote><p>To build a truly non-blocking application, we must aim to create\/use all of its components as non-blocking i.e. client, controller, middle services and even the database. If one of them is blocking the requests, our aim will be defeated.<\/p><\/blockquote>\n<h2>4. Spring Boot WebFlux Example<\/h2>\n<p>In this <strong><a href=\"https:\/\/howtodoinjava.com\/spring-boot-tutorials\/\">Spring boot 2<\/a><\/strong> application, I am creating employee management system. I chosen it because, while learning, you can compare it with traditional MVC style application. To make it fully non-blocking, I am using <strong>mongodb<\/strong> as back-end database.<\/p>\n<h4>4.1. Maven dependencies<\/h4>\n<p>Include <code>spring-boot-starter-webflux<\/code>, <code>spring-boot-starter-data-mongodb-reactive<\/code>, <code>spring-boot-starter-test<\/code> and <code>reactor-test<\/code> dependencies.<\/p>\n<pre class=\"brush: xml; title: pom.xml; notranslate\" title=\"pom.xml\">\r\n&lt;project xmlns=&quot;http:\/\/maven.apache.org\/POM\/4.0.0&quot;\r\n\txmlns:xsi=&quot;http:\/\/www.w3.org\/2001\/XMLSchema-instance&quot;\r\n\txsi:schemaLocation=&quot;http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd&quot;&gt;\r\n\t&lt;modelVersion&gt;4.0.0&lt;\/modelVersion&gt;\r\n\r\n\t&lt;parent&gt;\r\n\t\t&lt;groupId&gt;org.springframework.boot&lt;\/groupId&gt;\r\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;\/artifactId&gt;\r\n\t\t&lt;version&gt;2.1.1.RELEASE&lt;\/version&gt;\r\n\t\t&lt;relativePath \/&gt; &lt;!-- lookup parent from repository --&gt;\r\n\t&lt;\/parent&gt;\r\n\r\n\t&lt;groupId&gt;com.howtodoinjava&lt;\/groupId&gt;\r\n\t&lt;artifactId&gt;spring-webflux-demo&lt;\/artifactId&gt;\r\n\t&lt;version&gt;0.0.1-SNAPSHOT&lt;\/version&gt;\r\n\t&lt;packaging&gt;jar&lt;\/packaging&gt;\r\n\r\n\t&lt;name&gt;spring-webflux-demo&lt;\/name&gt;\r\n\t&lt;url&gt;http:\/\/maven.apache.org&lt;\/url&gt;\r\n\r\n\t&lt;properties&gt;\r\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;\/project.build.sourceEncoding&gt;\r\n\t\t&lt;java.version&gt;1.8&lt;\/java.version&gt;\r\n\t&lt;\/properties&gt;\r\n\r\n\t&lt;dependencies&gt;\r\n\t\t&lt;dependency&gt;\r\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;\/groupId&gt;\r\n\t\t\t&lt;artifactId&gt;spring-boot-starter-webflux&lt;\/artifactId&gt;\r\n\t\t&lt;\/dependency&gt;\r\n\t\t&lt;dependency&gt;\r\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;\/groupId&gt;\r\n\t\t\t&lt;artifactId&gt;spring-boot-starter-data-mongodb-reactive&lt;\/artifactId&gt;\r\n\t\t&lt;\/dependency&gt;\r\n\t\t&lt;dependency&gt;\r\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;\/groupId&gt;\r\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;\/artifactId&gt;\r\n\t\t\t&lt;scope&gt;test&lt;\/scope&gt;\r\n\t\t&lt;\/dependency&gt;\r\n\t\t&lt;dependency&gt;\r\n\t\t\t&lt;groupId&gt;io.projectreactor&lt;\/groupId&gt;\r\n\t\t\t&lt;artifactId&gt;reactor-test&lt;\/artifactId&gt;\r\n\t\t\t&lt;scope&gt;test&lt;\/scope&gt;\r\n\t\t&lt;\/dependency&gt;\r\n\r\n\t\t&lt;dependency&gt;\r\n\t\t\t&lt;groupId&gt;javax.xml.bind&lt;\/groupId&gt;\r\n\t\t\t&lt;artifactId&gt;jaxb-api&lt;\/artifactId&gt;\r\n\t\t\t&lt;version&gt;2.3.0&lt;\/version&gt;\r\n\t\t&lt;\/dependency&gt;\r\n\t\t&lt;dependency&gt;\r\n\t\t\t&lt;groupId&gt;javax.servlet&lt;\/groupId&gt;\r\n\t\t\t&lt;artifactId&gt;javax.servlet-api&lt;\/artifactId&gt;\r\n\t\t\t&lt;version&gt;3.1.0&lt;\/version&gt;\r\n\t\t\t&lt;scope&gt;provided&lt;\/scope&gt;\r\n\t\t&lt;\/dependency&gt;\r\n\t&lt;\/dependencies&gt;\r\n\r\n&lt;\/project&gt;\r\n<\/pre>\n<h4>4.2. Configurations<\/h4>\n<p><strong>Webflux Configuration<\/strong><\/p>\n<pre class=\"brush: java; title: WebFluxConfig.java; notranslate\" title=\"WebFluxConfig.java\">\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\n@EnableWebFlux\r\npublic class WebFluxConfig implements WebFluxConfigurer \r\n{\t\r\n}\r\n<\/pre>\n<p><strong>MongoDb Configuration<\/strong><\/p>\n<pre class=\"brush: java; title: MongoConfig.java; notranslate\" title=\"MongoConfig.java\">\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.mongodb.config.AbstractReactiveMongoConfiguration;\r\nimport org.springframework.data.mongodb.core.ReactiveMongoTemplate;\r\nimport org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\n\r\n@Configuration\r\n@EnableReactiveMongoRepositories(basePackages = &quot;com.howtodoinjava.demo.dao&quot;)\r\npublic class MongoConfig extends AbstractReactiveMongoConfiguration \r\n{\t\r\n\t@Value(&quot;${port}&quot;)\r\n\tprivate String port;\r\n\t\r\n\t@Value(&quot;${dbname}&quot;)\r\n\tprivate String dbName;\r\n\r\n\t@Override\r\n\tpublic MongoClient reactiveMongoClient() {\r\n\t\treturn MongoClients.create();\r\n\t}\r\n\r\n\t@Override\r\n\tprotected String getDatabaseName() {\r\n\t\treturn dbName;\r\n\t}\r\n\r\n\t@Bean\r\n\tpublic ReactiveMongoTemplate reactiveMongoTemplate() {\r\n\t\treturn new ReactiveMongoTemplate(reactiveMongoClient(), getDatabaseName());\r\n\t}\r\n}\r\n<\/pre>\n<p><strong>Application Configuration<\/strong><\/p>\n<pre class=\"brush: java; title: AppConfig.java; notranslate\" title=\"AppConfig.java\">\r\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.core.io.ClassPathResource;\r\n\r\n@Configuration\r\npublic class AppConfig \r\n{\r\n\t@Bean\r\n\tpublic static PropertyPlaceholderConfigurer getPropertyPlaceholderConfigurer() \r\n\t{\r\n\t\tPropertyPlaceholderConfigurer ppc = new PropertyPlaceholderConfigurer();\r\n\t\tppc.setLocation(new ClassPathResource(&quot;application.properties&quot;));\r\n\t\tppc.setIgnoreUnresolvablePlaceholders(true);\r\n\t\treturn ppc;\r\n\t}\r\n}\r\n<\/pre>\n<p><strong>Properties file<\/strong><\/p>\n<pre class=\"brush: java; title: application.properties; notranslate\" title=\"application.properties\">\r\nport=27017\r\ndbname=testdb\r\n<\/pre>\n<p><strong>Logging configuration<\/strong><\/p>\n<pre class=\"brush: xml; title: logback.xml; notranslate\" title=\"logback.xml\">\r\n&lt;configuration&gt;\r\n\r\n\t&lt;appender name=&quot;STDOUT&quot;\r\n\t\tclass=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\r\n\t\t&lt;encoder&gt;\r\n\t\t\t&lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{5} - %msg%n\r\n\t\t\t&lt;\/pattern&gt;\r\n\t\t&lt;\/encoder&gt;\r\n\t&lt;\/appender&gt;\r\n\r\n\t&lt;logger name=&quot;org.springframework&quot; level=&quot;DEBUG&quot;\r\n\t\tadditivity=&quot;false&quot;&gt;\r\n\t\t&lt;appender-ref ref=&quot;STDOUT&quot; \/&gt;\r\n\t&lt;\/logger&gt;\r\n\r\n\t&lt;root level=&quot;ERROR&quot;&gt;\r\n\t\t&lt;appender-ref ref=&quot;STDOUT&quot; \/&gt;\r\n\t&lt;\/root&gt;\r\n\r\n&lt;\/configuration&gt;\r\n<\/pre>\n<p><strong>Spring boot application<\/strong><\/p>\n<pre class=\"brush: java; title: WebfluxFunctionalApp.java; notranslate\" title=\"WebfluxFunctionalApp.java\">\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class WebfluxFunctionalApp {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(WebfluxFunctionalApp.class, args);\r\n\t}\r\n}\r\n<\/pre>\n<h4>4.3. REST Controller<\/h4>\n<pre class=\"brush: java; title: EmployeeController.java; notranslate\" title=\"EmployeeController.java\">\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.PathVariable;\r\nimport org.springframework.web.bind.annotation.RequestBody;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.ResponseStatus;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport com.howtodoinjava.demo.model.Employee;\r\nimport com.howtodoinjava.demo.service.EmployeeService;\r\n\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@RestController\r\npublic class EmployeeController {\r\n\t@Autowired\r\n\tprivate EmployeeService employeeService;\r\n\r\n\t@RequestMapping(value = { &quot;\/create&quot;, &quot;\/&quot; }, method = RequestMethod.POST)\r\n\t@ResponseStatus(HttpStatus.CREATED)\r\n\tpublic void create(@RequestBody Employee e) {\r\n\t\temployeeService.create(e);\r\n\t}\r\n\r\n\t@RequestMapping(value = &quot;\/{id}&quot;, method = RequestMethod.GET)\r\n\tpublic ResponseEntity&lt;Mono&lt;Employee&gt;&gt; findById(@PathVariable(&quot;id&quot;) Integer id) {\r\n\t\tMono&lt;Employee&gt; e = employeeService.findById(id);\r\n\t\tHttpStatus status = e != null ? HttpStatus.OK : HttpStatus.NOT_FOUND;\r\n\t\treturn new ResponseEntity&lt;Mono&lt;Employee&gt;&gt;(e, status);\r\n\t}\r\n\r\n\t@RequestMapping(value = &quot;\/name\/{name}&quot;, method = RequestMethod.GET)\r\n\tpublic Flux&lt;Employee&gt; findByName(@PathVariable(&quot;name&quot;) String name) {\r\n\t\treturn employeeService.findByName(name);\r\n\t}\r\n\r\n\t@RequestMapping(method = RequestMethod.GET, produces = MediaType.TEXT_EVENT_STREAM_VALUE)\r\n\tpublic Flux&lt;Employee&gt; findAll() {\r\n\t\tFlux&lt;Employee&gt; emps = employeeService.findAll();\r\n\t\treturn emps;\r\n\t}\r\n\r\n\t@RequestMapping(value = &quot;\/update&quot;, method = RequestMethod.PUT)\r\n\t@ResponseStatus(HttpStatus.OK)\r\n\tpublic Mono&lt;Employee&gt; update(@RequestBody Employee e) {\r\n\t\treturn employeeService.update(e);\r\n\t}\r\n\r\n\t@RequestMapping(value = &quot;\/delete\/{id}&quot;, method = RequestMethod.DELETE)\r\n\t@ResponseStatus(HttpStatus.OK)\r\n\tpublic void delete(@PathVariable(&quot;id&quot;) Integer id) {\r\n\t\temployeeService.delete(id).subscribe();\r\n\t}\r\n\r\n}\r\n<\/pre>\n<h4>4.4. Service classes<\/h4>\n<pre class=\"brush: java; title: IEmployeeService.java; notranslate\" title=\"IEmployeeService.java\">\r\nimport com.howtodoinjava.demo.model.Employee;\r\n\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface IEmployeeService \r\n{\r\n\tvoid create(Employee e);\r\n\t\r\n\tMono&lt;Employee&gt; findById(Integer id);\r\n\r\n\tFlux&lt;Employee&gt; findByName(String name);\r\n\r\n\tFlux&lt;Employee&gt; findAll();\r\n\r\n\tMono&lt;Employee&gt; update(Employee e);\r\n\r\n\tMono&lt;Void&gt; delete(Integer id);\r\n}\r\n<\/pre>\n<pre class=\"brush: java; title: EmployeeService.java; notranslate\" title=\"EmployeeService.java\">\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport com.howtodoinjava.demo.dao.EmployeeRepository;\r\nimport com.howtodoinjava.demo.model.Employee;\r\n\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@Service\r\npublic class EmployeeService implements IEmployeeService {\r\n\t\r\n\t@Autowired\r\n\tEmployeeRepository employeeRepo;\r\n\r\n\tpublic void create(Employee e) {\r\n\t\temployeeRepo.save(e).subscribe();\r\n\t}\r\n\r\n\tpublic Mono&lt;Employee&gt; findById(Integer id) {\r\n\t\treturn employeeRepo.findById(id);\r\n\t}\r\n\r\n\tpublic Flux&lt;Employee&gt; findByName(String name) {\r\n\t\treturn employeeRepo.findByName(name);\r\n\t}\r\n\r\n\tpublic Flux&lt;Employee&gt; findAll() {\r\n\t\treturn employeeRepo.findAll();\r\n\t}\r\n\r\n\tpublic Mono&lt;Employee&gt; update(Employee e) {\r\n\t\treturn employeeRepo.save(e);\r\n\t}\r\n\r\n\tpublic Mono&lt;Void&gt; delete(Integer id) {\r\n\t\treturn employeeRepo.deleteById(id);\r\n\t}\r\n\r\n}\r\n<\/pre>\n<h4>4.5. DAO repository<\/h4>\n<pre class=\"brush: java; title: EmployeeRepository.java; notranslate\" title=\"EmployeeRepository.java\">\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.ReactiveMongoRepository;\r\n\r\nimport com.howtodoinjava.demo.model.Employee;\r\n\r\nimport reactor.core.publisher.Flux;\r\n\r\npublic interface EmployeeRepository extends ReactiveMongoRepository&lt;Employee, Integer&gt; {\r\n\t@Query(&quot;{ 'name': ?0 }&quot;)\r\n\tFlux&lt;Employee&gt; findByName(final String name);\r\n}\r\n<\/pre>\n<h4>4.6. Model<\/h4>\n<pre class=\"brush: java; title: Employee.java; notranslate\" title=\"Employee.java\">\r\nimport org.springframework.context.annotation.Scope;\r\nimport org.springframework.context.annotation.ScopedProxyMode;\r\nimport org.springframework.data.annotation.Id;\r\nimport org.springframework.data.mongodb.core.mapping.Document;\r\n\r\n@Scope(scopeName = &quot;request&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)\r\n@Document\r\npublic class Employee {\r\n\r\n\t@Id\r\n\tint id;\r\n\tString name;\r\n\tlong salary;\r\n\r\n\t\/\/Getters and setters\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn &quot;Employee [id=&quot; + id + &quot;, name=&quot; + name + &quot;, salary=&quot; + salary + &quot;]&quot;;\r\n\t}\r\n}\r\n<\/pre>\n<h2>5. Demo<\/h2>\n<p>Start the application and check requests and responses.<\/p>\n<li>HTTP POST http:\/\/localhost:8080\/create<\/li>\n<pre class=\"brush: java; title: API Request 1; notranslate\" title=\"API Request 1\">\r\n{\r\n\t&quot;id&quot;:1,\r\n\t&quot;name&quot;:&quot;user_1&quot;,\r\n\t&quot;salary&quot;:101\r\n}\r\n<\/pre>\n<pre class=\"brush: java; title: API Request 2; notranslate\" title=\"API Request 2\">\r\n{\r\n\t&quot;id&quot;:2,\r\n\t&quot;name&quot;:&quot;user_2&quot;,\r\n\t&quot;salary&quot;:102\r\n}\r\n<\/pre>\n<li>HTTP PUT http:\/\/localhost:8080\/update<\/li>\n<pre class=\"brush: java; title: API Request; notranslate\" title=\"API Request\">\r\n{\r\n\t&quot;id&quot;:2,\r\n\t&quot;name&quot;:&quot;user_2&quot;,\r\n\t&quot;salary&quot;:103\r\n}\r\n<\/pre>\n<li>HTTP GET http:\/\/localhost:8080\/<\/li>\n<pre class=\"brush: java; title: API Response; notranslate\" title=\"API Response\">\r\ndata:{&quot;id&quot;:1,&quot;name&quot;:&quot;user_1&quot;,&quot;salary&quot;:101}\r\n\r\ndata:{&quot;id&quot;:2,&quot;name&quot;:&quot;user_2&quot;,&quot;salary&quot;:102}\r\n<\/pre>\n<figure id=\"attachment_12325\" aria-describedby=\"caption-attachment-12325\" style=\"width: 1032px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Spring-WebFlux-Demo.png\" alt=\"Spring WebFlux Demo\" width=\"1042\" height=\"413\" class=\"size-full wp-image-12325\" \/><figcaption id=\"caption-attachment-12325\" class=\"wp-caption-text\">Spring WebFlux Demo<\/figcaption><\/figure>\n<p>Notice that I am testing the API with <strong>Postman chrome browser extension<\/strong> which is a blocking client. It will display the result only when It has collected the response for both employees. <\/p>\n<p>To verify the non-blocking response feature, hit the URL in the chrome browser directly. The results will appear one by one, as and when they are available in form of events (<strong>text\/event-stream<\/strong>). To better view the result, consider adding a delay to controller API.<\/p>\n<figure id=\"attachment_12326\" aria-describedby=\"caption-attachment-12326\" style=\"width: 1003px\" class=\"wp-caption aligncenter\"><img loading=\"lazy\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Spring-WebFlux-Demo-Event-Stream.png\" alt=\"Spring WebFlux Demo - Event Stream\" width=\"1013\" height=\"482\" class=\"size-full wp-image-12326\" \/><figcaption id=\"caption-attachment-12326\" class=\"wp-caption-text\">Spring WebFlux Demo &#8211; Event Stream<\/figcaption><\/figure>\n<h2>6. Spring WebFlux Tutorial &#8211; Conclusion<\/h2>\n<p>Both Spring MVC and Spring WebFlux support client-server architecture but there is a key difference in the <a href=\"https:\/\/howtodoinjava.com\/java-concurrency-tutorial\/\">concurrency<\/a> model and the default behavior for blocking nature and threads. In Spring MVC, it is assumed that applications can block the current thread while in webflux, threads are non-blocking by default. It is the main difference between <strong>spring webflux vs mvc<\/strong>.<\/p>\n<p>Reactive and non-blocking generally do not make applications run faster. The expected benefit of reactive and non-blocking is the ability to scale the application with a small, fixed number of threads and lesser memory requirements. It makes applications more resilient under load because they scale in a more predictable manner.<\/p>\n<p>Drop me your questions related to this <strong>spring boot webflux tutorial<\/strong>.<\/p>\n<p>Happy Learning !!<\/p>\n<div class=\"noticeboxesde downgreennoticebox\"><a href=\"https:\/\/howtodoinjava.com\/wp-content\/downloads\/spring-webflux-demo.zip\">Sourcecode Download<\/a><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In this spring webflux tutorial, we will learn the basic concepts behind reactive programming, webflux apis and a fully functional hello world example.<\/p>\n","protected":false},"author":2,"featured_media":12324,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[1230],"tags":[1229],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",1198,438,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",150,55,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",300,110,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",768,281,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",1024,374,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",1198,438,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",1198,438,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2019\/02\/Non-blocking-request-processing.png",120,44,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":34,"uagb_excerpt":"In this spring webflux tutorial, we will learn the basic concepts behind reactive programming, webflux apis and a fully functional hello world example.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/12322"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=12322"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/12322\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/12324"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=12322"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=12322"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=12322"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}