{"id":3158,"date":"2013-10-03T21:57:47","date_gmt":"2013-10-03T16:27:47","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=3158"},"modified":"2020-12-26T00:49:27","modified_gmt":"2020-12-25T19:19:27","slug":"a-birds-eye-view-on-how-web-servers-work","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/","title":{"rendered":"How web servers work?"},"content":{"rendered":"<p>Many times we wonder that <strong>how a web container\/ web-server (e.g. tomcat or jboss) works?<\/strong> How they handle the incoming http requests coming from all over the world? What are the things which make it happen behind the scene? How java servlet API (i.e. classes like ServletContext, ServletRequest, ServletResponse and Session) fit into picture? These are very important questions\/concepts you must know if you are a web-application developer or you aspire to be. In this post, I will try to find out answers for some of above question, if not all. Remain concentrated from here.<\/p>\n<pre style=\"clear: none;\"><strong>Table of Contents:<\/strong>\r\n\r\n<a href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/#webserver-appserver-container\">What are web server, application server and web container?<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/#servlets\">What are Servlets? How they help?<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/#servlet-context\">What is ServletContext? Who creates it?<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/#servletrequest-servletresponse\">Where ServletRequest and ServletResponse fits into life cycle?<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/#session-cookie\">How Session is managed? Know the cookie?<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/#thread-safety\">How thread safety should be ensured?<\/a><\/pre>\n<p><a name=\"webserver-appserver-container\"><\/a><\/p>\n<h2>What are web server, application server and web container?<\/h2>\n<p>I will first talk about <strong>web servers<\/strong> and application servers. Let me say it in one liner,<\/p>\n<div class=\"noticeboxesde bluenoticebox\">&#8220;Historically they were different, but these two previously distinct categories slowly merged, and now should be seen as one entity in most of the cases and uses.&#8221;<\/div>\n<p>In early days of the <a title=\"Mosaic\" href=\"https:\/\/en.wikipedia.org\/wiki\/Mosaic_%28web_browser%29\"><strong>Mosaic<\/strong><\/a> browser (often described as the first graphical web browser) and hyper-linked content, there evolved a new concept &#8220;web server&#8221; that served static web page content and images over <strong><a title=\"http\" href=\"https:\/\/en.wikipedia.org\/wiki\/Hypertext_Transfer_Protocol\">HTTP<\/a><\/strong> protocol. Simple enough. In these days, most of the content was static, and the HTTP 1.0 protocol was just a way to ship files around. But soon the web servers evolved to have <a title=\"cgi\" href=\"http:\/\/www.invir.com\/int-prog-cgi.html\"><strong>CGI<\/strong><\/a> capabilities. It means effectively launching a process on each web request to generate dynamic content. By this time, HTTP protocol also matured and web servers became more sophisticated with additional functionality like caching, security, and session management. As the technology further matured, we got company-specific java-based server-side technology from Kiva and <strong><a href=\"https:\/\/en.wikipedia.org\/wiki\/NetDynamics_Application_Server\">NetDynamics<\/a><\/strong>, which eventually all merged into JSP (java server pages), which we still use in most applications development today.<\/p>\n<p style=\"text-align: center;\"><img loading=\"lazy\" class=\"aligncenter  wp-image-3170\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/web-server-application-server.gif\" alt=\"web server application server\" width=\"400\" height=\"318\" \/><\/p>\n<p>This was about web-servers. Now let&#8217;s talk about <strong>application servers<\/strong>.<\/p>\n<p>In a parallel category, the application servers had evolved and existed for a long time. Some companies delivered products for Unix like <a title=\"Tuxedo\" href=\"https:\/\/en.wikipedia.org\/wiki\/Tuxedo_%28software%29\"><strong>Tuxedo<\/strong><\/a> (transaction-oriented middleware), <strong>TopEnd<\/strong>, <strong>Encina<\/strong> that were philosophically derived from Mainframe application management and monitoring environments like IMS and CICS. Most of these products specified &#8220;closed&#8221; product-specific communications protocols to interconnect &#8220;fat&#8221; clients to servers. In 90&#8217;s, these traditional app server products began to embed basic HTTP communication capability, at first via gateways. And sooner the lines began to blur between these two categories.<\/p>\n<p>By the time, web servers got more and more mature with respect to handling higher loads, more concurrency, and better features; Application servers started delivering more and more HTTP-based communication capability. And all this resulted into very thin line between web-servers and application servers.<\/p>\n<p>At this point the line between &#8220;app server&#8221; and &#8220;web server&#8221; is a fuzzy one. But people continue to use the terms differently, as a matter of emphasis.<\/p>\n<div class=\"noticeboxesde greennoticebox\">When someone says &#8220;web server&#8221; you often think HTTP-centric, web UI oriented applications. When someone says &#8220;Application server&#8221; you may think &#8220;heavier loads, enterprise features, transactions and queuing, multi-channel communication (HTTP + more)&#8221;. But mostly it is the same product that serves both sets of requirements now-a-days.<\/div>\n<p>That&#8217;s all about web servers and application servers. Now move towards third term i.e. web container.<\/p>\n<p><img loading=\"lazy\" class=\"aligncenter size-full wp-image-3168\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/web-server-servlet-container.jpg\" alt=\"web server servlet container\" width=\"535\" height=\"211\" \/><\/p>\n<p><a href=\"https:\/\/en.wikipedia.org\/wiki\/Web_container\"><strong>Web container<\/strong><\/a>, specially in java, should be refer to servlet container. A servlet container is the component of a web server that interacts with java servlets. A web container is responsible for managing the life-cycle of servlets, mapping a URL to a particular servlet and ensuring that the URL requester has the correct access rights and many more such services. Basically, putting together all above facts, <strong>servlet container is the runtime environment where your servlet run<\/strong> and it&#8217;s life cycle is maintained.<\/p>\n<p><a name=\"servlets\"><\/a><\/p>\n<h2>What are Servlets? How they help?<\/h2>\n<p>In java, <strong>servlets enable you to write server side components which help in generating dynamic content<\/strong>, based on request. Factually, Servlet is an interface defined in javax.servlet package. It declares three essential methods for the life cycle of a servlet \u2013 init(), service(), and destroy(). They are implemented by every servlet(either defined in SDK or user-defined) and are invoked at specific times by the server during it&#8217;s life cycle.<\/p>\n<p>Servlet classes are loaded to container by it&#8217;s class loader dynamically either through <strong>lazy-loading or eager loading<\/strong>. <strong>Each request is in its own thread<\/strong>, and a servlet object can serve multiple threads at the same time. When it is no longer being used, it is garbage collected by JVM.<\/p>\n<p><strong>Lazy loading servlet<\/strong><\/p>\n<p><img loading=\"lazy\" class=\"size-full wp-image-3172\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/Lazy-Loaded-Servlet1.png\" alt=\"Lazy Loaded Servlet1\" width=\"302\" height=\"306\" \/><img loading=\"lazy\" class=\"size-full wp-image-3171\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/Lazy-Loaded-Servlet.png\" alt=\"Lazy Loaded Servlet\" width=\"301\" height=\"305\" \/><\/p>\n<p><strong>Eager loading <strong>servlet<\/strong><\/strong><\/p>\n<p><img loading=\"lazy\" class=\"size-full wp-image-3174\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/Eagerly-Loaded-Servlet1.png\" alt=\"Eagerly Loaded Servlet1\" width=\"303\" height=\"306\" \/><img loading=\"lazy\" class=\"size-full wp-image-3173\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/Eagerly-Loaded-Servlet.png\" alt=\"Eagerly Loaded Servlet\" width=\"302\" height=\"305\" \/><\/p>\n<p><a name=\"servlet-context\"><\/a><\/p>\n<h2>What is ServletContext? Who creates it?<\/h2>\n<p>When the servlet container starts up, it will deploy and load all web-applications. When a web application gets loaded, the servlet container will create the <strong>ServletContext once per application<\/strong> and keep in server&#8217;s memory. The webapp&#8217;s web.xml will be parsed and every Servlet, Filter and Listener found in web.xml will be created once and kept in server&#8217;s memory as well. When the servlet container shuts down, it will unload all web applications and the ServletContext and all Servlet, Filter and Listener instances will be trashed.<\/p>\n<p>As per java docs, <strong>ServletContext defines a set of methods that a servlet uses to communicate with its servlet container<\/strong>, for example, to get the MIME type of a file, dispatch requests, or write to a log file. In the case of a web application <strong>marked &#8220;distributed&#8221; in its deployment descriptor<\/strong>, there will be one context instance for each virtual machine. In this situation, the context <strong>cannot be used as a location to share global information<\/strong> (because the information won&#8217;t be truly global). Use an external resource like a database instead.<\/p>\n<p><a name=\"servletrequest-servletresponse\"><\/a><\/p>\n<h2>Where ServletRequest and ServletResponse fits into life cycle?<\/h2>\n<p>The servlet container is attached to a webserver which listens on HTTP requests on a certain port number, which is usually 80. When a client (user with a web-browser) sends a HTTP request, the <strong>servlet container will create new HttpServletRequest<\/strong> <strong>and HttpServletResponse<\/strong> objects and pass it through the methods of the already-created Filter and Servlet instances whose URL-pattern matches the request URL, all in the same thread.<\/p>\n<p>The request object provides access to all information of the HTTP request, such as the request headers and the request body. The response object provides facility to control and send the HTTP response the way you want, such as setting headers and the body (usually with HTML content from a JSP file). When the HTTP response is committed and finished, then both the request and response objects will be trashed.<\/p>\n<p><a name=\"session-cookie\"><\/a><\/p>\n<h2>How Session is managed? Know the cookie?<\/h2>\n<p>When a client visits the web-app for the first time and\/or the HttpSession is to be obtained for the first time by request.getSession(), then the servlet container will create it, generate a long and unique ID (which you can get by session.getId()) and store it in server&#8217;s memory. The servlet container will also set a Cookie in the HTTP response with <strong>JSESSIONID<\/strong> as cookie name and the unique session ID as cookie value.<\/p>\n<p>As per the <a title=\"http cookie\" href=\"http:\/\/www.faqs.org\/rfcs\/rfc2965.html\"><strong>HTTP cookie specification<\/strong><\/a> (a contract a decent web browser and webserver has to adhere), the client (the web browser) is required to send this cookie back in the subsequent requests as long as the cookie is valid. The servlet container will determine every incoming HTTP request header for the presence of the cookie with the name JSESSIONID and use its value to get the associated HttpSession from server&#8217;s memory.<\/p>\n<p>The HttpSession lives until it has not been used for more than the time, a setting you can specify in web.xml, which <strong>defaults to 30 minutes<\/strong>. So when the client doesn&#8217;t visit the web application anymore for over 30 minutes, then the servlet container will trash the session. Every subsequent request, even though with the cookie specified, will not have access to the same session anymore. The servletcontainer will create a new one.<\/p>\n<p><strong>Existing Session<\/strong><\/p>\n<p><img loading=\"lazy\" class=\"aligncenter size-full wp-image-3175\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/Existing-session.png\" alt=\"Existing session\" width=\"302\" height=\"307\" \/><\/p>\n<p><strong>New Session<\/strong><\/p>\n<p><img loading=\"lazy\" class=\"aligncenter size-full wp-image-3176\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/New-session.png\" alt=\"New session\" width=\"606\" height=\"308\" \/><\/p>\n<p>On the other hand, the session cookie <strong>on the client side has a default lifetime which is as long as the browser instance is running<\/strong>. So when the client closes the browser instance (all tabs\/windows), then the session will be trashed at the client side. In a new browser instance the cookie associated with the session won&#8217;t be sent anymore. A new request.getSession() would return a brand new HttpSession and set a cookie with a brand new session ID.<\/p>\n<p><a name=\"thread-safety\"><\/a><\/p>\n<h2>How thread safety should be ensured?<\/h2>\n<p>You should now have learned that Servlets and filters are shared among all requests. That&#8217;s the nice thing of Java, it&#8217;s <a title=\"multi-threading\" href=\"https:\/\/howtodoinjava.com\/java\/multi-threading\/\"><strong>multi-threaded<\/strong><\/a> and different threads (i.e. HTTP requests) can make use of the same instance. It would otherwise have been too expensive to recreate it on every request.<\/p>\n<p><img loading=\"lazy\" class=\"aligncenter size-full wp-image-3177\" src=\"https:\/\/howtodoinjava.com\/wp-content\/uploads\/thread-safety.png\" alt=\"thread-safety\" width=\"303\" height=\"305\" \/><\/p>\n<p>But you should also realize that you should never assign any request or session scoped data as an instance variable of a servlet or filter. It will be shared among all other requests in other sessions. That&#8217;s thread-unsafe! The below example illustrates that:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic class MyServlet extends HttpServlet\r\n{\r\n\tprivate Object thisIsNOTThreadSafe; \/\/Don't to this\r\n\r\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException\r\n\t{\r\n\t\tObject thisIsThreadSafe;\r\n\r\n\t\tthisIsNOTThreadSafe = request.getParameter(&quot;foo&quot;); \/\/ BAD!! Shared among all requests!\r\n\t\tthisIsThreadSafe = request.getParameter(&quot;foo&quot;); \/\/ OK, this is thread safe.\r\n\t}\r\n}\r\n<\/pre>\n<p>Do not do this. It will result in a bug in software.<\/p>\n<p>That&#8217;s all on this topic. Stay tuned for more such posts. Better subscribe the email news letter to get the notification in your inbox.<\/p>\n<p><strong>Happy Learning !!<\/strong><\/p>\n<p><strong>Recommended link(s):<\/strong><\/p>\n<p><a href=\"http:\/\/www.invir.com\/int-prog-cgi.html\">http:\/\/www.invir.com\/int-prog-cgi.html<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Many times we wonder that how a web container\/ web-server (e.g. tomcat or jboss) works? How they handle the incoming http requests coming from all over the world? What are the things which make it happen behind the scene? How java servlet API (i.e. classes like ServletContext, ServletRequest, ServletResponse and Session) fit into picture? These &#8230; <a title=\"How web servers work?\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/tomcat\/a-birds-eye-view-on-how-web-servers-work\/\" aria-label=\"More on How web servers work?\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":3170,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[742],"tags":[1449,1457],"uagb_featured_image_src":{"full":false,"thumbnail":false,"medium":false,"medium_large":false,"large":false,"1536x1536":false,"2048x2048":false,"yarpp-thumbnail":false},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":33,"uagb_excerpt":"Many times we wonder that how a web container\/ web-server (e.g. tomcat or jboss) works? How they handle the incoming http requests coming from all over the world? What are the things which make it happen behind the scene? How java servlet API (i.e. classes like ServletContext, ServletRequest, ServletResponse and Session) fit into picture? These&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3158"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=3158"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/3158\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=3158"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=3158"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=3158"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}