{"id":389,"date":"2012-11-21T10:00:23","date_gmt":"2012-11-21T10:00:23","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=389"},"modified":"2020-12-26T00:37:40","modified_gmt":"2020-12-25T19:07:40","slug":"java-serialization","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/serialization\/java-serialization\/","title":{"rendered":"Java Serialization &#8211; Dos and Don&#8217;ts for Correct Serialization"},"content":{"rendered":"<p><strong>Java serialization<\/strong> enables writing Java objects to file system for permanent storage or on network to transfer to other applications. Serialization in Java is achieved with <strong>Serializable<\/strong> interface. Java <a title=\"Serializable interface\" href=\"https:\/\/docs.oracle.com\/javase\/6\/docs\/api\/java\/io\/Serializable.html\">Serializable interface<\/a> guarantees the ability to <a href=\"https:\/\/howtodoinjava.com\/java\/serialization\/custom-serialization-readobject-writeobject\/\">serialize the objects<\/a>. This interface recommends us to use <strong>serialVersioUID<\/strong> also. <\/p>\n<p>Now, even if you use both in the application classes, do you know <strong>what can break your design<\/strong> even now?? Lets identify the future changes in the class which will be <strong>compatible changes<\/strong> and others which will prove <strong>incompatible changes<\/strong>.<\/p>\n<pre>Table of contents\r\n\r\n1. Java serialization incompatible changes\r\n2. Java serialization compatible changes\r\n3. serialVersionUID\r\n4. readObject() and writeObject() methods\r\n5. More serialization best practices\r\n6. Sample class following serialization best practices\r\n7. Serialization and deserialization example<\/pre>\n<h2>1. Java serialization incompatible changes<\/h2>\n<p>Incompatible changes to classes are those changes for which the guarantee of interoperability cannot be maintained. The incompatible changes that may occur while evolving a class are given below (considering default serialization or <a href=\"https:\/\/howtodoinjava.com\/java\/serialization\/how-deserialization-process-happen-in-java\/\">deserialization<\/a>):<\/p>\n<ol>\n<li><strong>Deleting fields<\/strong> &#8211; If a field is deleted in a class, the stream written will not contain its value. When the stream is read by an earlier class, the value of the field will be set to the default value because no value is available in the stream. However, this default value may adversely impair the ability of the earlier version to fulfill its contract.<\/li>\n<li><strong>Moving classes up or down the hierarchy<\/strong> &#8211; This cannot be allowed since the data in the stream appears in the wrong sequence.<\/li>\n<li><strong>Changing a non-static field to static or a non-transient field to transient<\/strong> &#8211; When relying on default serialization, this change is equivalent to deleting a field from the class. This version of the class will not write that data to the stream, so it will not be available to be read by earlier versions of the class. As when deleting a field, the field of the earlier version will be initialized to the default value, which can cause the class to fail in unexpected ways.<\/li>\n<li><strong>Changing the declared type of a primitive field<\/strong> &#8211; Each version of the class writes the data with its declared type. Earlier versions of the class attempting to read the field will fail because the type of the data in the stream does not match the type of the field.<\/li>\n<li><strong>Changing the writeObject or readObject method so that it no longer writes or reads the default field data<\/strong> or changing it so that it attempts to write it or read it when the previous version did not. The default field data must consistently either appear or not appear in the stream.<\/li>\n<li><strong>Changing a class from Serializable to Externalizable or vice-versa<\/strong> is an incompatible change since the stream will contain data that is incompatible with the implementation of the available class.<\/li>\n<li><strong>Changing a class from a non-enum type to an enum type or vice versa<\/strong> since the stream will contain data that is incompatible with the implementation of the available class.<\/li>\n<li><strong>Removing either <a title=\"Serializable interface\" href=\"https:\/\/docs.oracle.com\/javase\/6\/docs\/api\/java\/io\/Serializable.html\">Serializable<\/a> or Externalizable<\/strong> is an incompatible change since when written it will no longer supply the fields needed by older versions of the class.<\/li>\n<li><strong>Adding the writeReplace or readResolve method to a class<\/strong> is incompatible if the behavior would produce an object that is incompatible with any older version of the class.<\/li>\n<\/ol>\n<h2>2. Java serialization compatible changes<\/h2>\n<ol>\n<li><strong>Adding fields<\/strong> &#8211; When the class being reconstituted has a field that does not occur in the stream, that field in the object will be initialized to the default value for its type. If class-specific initialization is needed, the class may provide a readObject method that can initialize the field to non default values.<\/li>\n<li><strong>Adding classes<\/strong> &#8211; The stream will contain the type hierarchy of each object in the stream. Comparing this hierarchy in the stream with the current class can detect additional classes. Since there is no information in the stream from which to initialize the object, the class&#8217;s fields will be initialized to the default values.<\/li>\n<li><strong>Removing classes<\/strong> &#8211; Comparing the class hierarchy in the stream with that of the current class can detect that a class has been deleted. In this case, the fields and objects corresponding to that class are read from the stream. <a href=\"https:\/\/howtodoinjava.com\/java\/basics\/primitive-data-types-in-java\/\">Primitive fields<\/a> are discarded, but the objects referenced by the deleted class are created, since they may be referred to later in the stream. They will be garbage-collected when the stream is garbage-collected or reset.<\/li>\n<li><strong>Adding writeObject\/readObject methods<\/strong> &#8211; If the version reading the stream has these methods then readObject is expected, as usual, to read the required data written to the stream by the default serialization. It should call defaultReadObject first before reading any optional data. The writeObject method is expected as usual to call defaultWriteObject to write the required data and then may write optional data.<\/li>\n<li><strong>Removing writeObject\/readObject methods<\/strong> &#8211; If the class reading the stream does not have these methods, the required data will be read by default serialization, and the optional data will be discarded.<\/li>\n<li><strong>Adding java.io.Serializable<\/strong> &#8211; This is equivalent to adding types. There will be no values in the stream for this class so its fields will be initialized to default values. The support for subclassing nonserializable classes requires that the class&#8217;s super type have a no-arg constructor and the class itself will be initialized to default values. If the no-arg constructor is not available, the <code>InvalidClassException<\/code> is thrown.<\/li>\n<li><strong>Changing the access to a field<\/strong> &#8211; The <a href=\"https:\/\/howtodoinjava.com\/java\/oops\/java-access-modifiers\/\">access modifiers<\/a> public, package, protected, and private have no effect on the ability of serialization to assign values to the fields.<\/li>\n<li><strong>Changing a field from static to non-static or transient to non transient<\/strong> &#8211; When relying on default serialization to compute the serializable fields, this change is equivalent to adding a field to the class. The new field will be written to the stream but earlier classes will ignore the value since serialization will not assign values to <a href=\"https:\/\/howtodoinjava.com\/java\/keywords\/java-static-keyword\/\">static<\/a> or <a href=\"https:\/\/howtodoinjava.com\/java\/keywords\/transient-keyword-in-java-with-real-time-example\/\">transient<\/a> fields.<\/li>\n<\/ol>\n<h2>3. serialVersionUID<\/h2>\n<p>The serialVersionUID is a universal version identifier for a <code>Serializable<\/code> class. Deserialization uses this number to ensure that a loaded class corresponds exactly to a serialized object. If no match is found, then an <strong>InvalidClassException<\/strong> is thrown.<\/p>\n<ol>\n<li><strong>Always include it as a field<\/strong>, for example: &#8220;private static final long serialVersionUID = 7526472295622776147L; &#8221; include this field even in the first version of the class, as a reminder of its importance.<\/li>\n<li><strong>Do not change the value of this field in future versions, unless you are knowingly making changes<\/strong> to the class which will render it incompatible with old serialized objects. If needed, follow above given guidelines.<\/li>\n<\/ol>\n<h2>4. readObject and writeObject methods<\/h2>\n<ol>\n<li>Deserialization must be treated as any constructor : <strong>validate the object state at the end of deserializing<\/strong> &#8211; this implies that readObject should almost always be implemented in Serializable classes, such that this validation is performed.<\/li>\n<li>If constructors<strong> make defensive copies<\/strong> for mutable object fields, so must readObject.<\/li>\n<\/ol>\n<h2>5. More serialization best practices<\/h2>\n<ol>\n<li>Use javadoc&#8217;s <code>@serial<\/code> tag to denote Serializable fields.<\/li>\n<li>The .ser extension is conventionally used for files representing serialized objects.<\/li>\n<li>No static or transient fields undergo default serialization.<\/li>\n<li>Extendable classes should not be Serializable, unless necessary.<\/li>\n<li>Inner classes should rarely, if ever, implement Serializable.<\/li>\n<li>Container classes should usually follow the style of Hashtable, which implements Serializable by storing keys and values, as opposed to a large hash table data structure.<\/li>\n<\/ol>\n<h2>6. Sample class following serialization best practices<\/h2>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npackage staticTest;\r\n\r\nimport java.io.Serializable;\r\nimport java.text.StringCharacterIterator;\r\nimport java.util.*;\r\nimport java.io.*;\r\n\r\npublic final class UserDetails implements Serializable {\r\n\r\n\/**\r\n* This constructor requires all fields\r\n*\r\n* @param aFirstName\r\n* contains only letters, spaces, and apostrophes.\r\n* @param aLastName\r\n* contains only letters, spaces, and apostrophes.\r\n* @param aAccountNumber\r\n* is non-negative.\r\n* @param aDateOpened\r\n* has a non-negative number of milliseconds.\r\n*\/\r\npublic UserDetails(String aFirstName, String aLastName, int aAccountNumber,\r\n\t\t\t\t\t\tDate aDateOpened) \r\n{\r\n  super();\r\n  setFirstName(aFirstName);\r\n  setLastName(aLastName);\r\n  setAccountNumber(aAccountNumber);\r\n  setDateOpened(aDateOpened);\r\n  \/\/ there is no need here to call verifyUserDetails.\r\n}\r\n\r\n\/\/ The default constructor\r\npublic UserDetails() {\r\n  this(&quot;FirstName&quot;, &quot;LastName&quot;, 0, new Date(System.currentTimeMillis()));\r\n}\r\n\r\npublic final String getFirstName() {\r\n  return fFirstName;\r\n}\r\n\r\npublic final String getLastName() {\r\n  return fLastName;\r\n}\r\n\r\npublic final int getAccountNumber() {\r\n  return fAccountNumber;\r\n}\r\n\r\n\/**\r\n* Returns a defensive copy of the field so that no one can change this\r\n* field.\r\n*\/\r\npublic final Date getDateOpened() {\r\n  return new Date(fDateOpened.getTime());\r\n}\r\n\r\n\/**\r\n* Names must contain only letters, spaces, and apostrophes. Validate before\r\n* setting field to new value.\r\n*\r\n* @throws IllegalArgumentException\r\n* if the new value is not acceptable.\r\n*\/\r\npublic final void setFirstName(String aNewFirstName) {\r\n  verifyNameProperty(aNewFirstName);\r\n  fFirstName = aNewFirstName;\r\n}\r\n\r\n\/**\r\n* Names must contain only letters, spaces, and apostrophes. Validate before\r\n* setting field to new value.\r\n*\r\n* @throws IllegalArgumentException\r\n* if the new value is not acceptable.\r\n*\/\r\npublic final void setLastName(String aNewLastName) {\r\n  verifyNameProperty(aNewLastName);\r\n  fLastName = aNewLastName;\r\n}\r\n\r\n\/**\r\n* Validate before setting field to new value.\r\n*\r\n* @throws IllegalArgumentException\r\n* if the new value is not acceptable.\r\n*\/\r\npublic final void setAccountNumber(int aNewAccountNumber) {\r\n  validateAccountNumber(aNewAccountNumber);\r\n  fAccountNumber = aNewAccountNumber;\r\n}\r\n\r\npublic final void setDateOpened(Date aNewDate) {\r\n  \/\/ make a defensive copy of the mutable date object\r\n  Date newDate = new Date(aNewDate.getTime());\r\n  validateAccountOpenDate(newDate);\r\n  fDateOpened = newDate;\r\n}\r\n\r\n\/**\r\n* The client's first name.\r\n*\r\n* @serial\r\n*\/\r\nprivate String fFirstName;\r\n\r\n\/**\r\n* The client's last name.\r\n*\r\n* @serial\r\n*\/\r\nprivate String fLastName;\r\n\r\n\/**\r\n* The client's account number.\r\n*\r\n* @serial\r\n*\/\r\nprivate int fAccountNumber;\r\n\r\n\/**\r\n* The date the account was opened.\r\n*\r\n* @serial\r\n*\/\r\nprivate Date fDateOpened;\r\n\r\n\/**\r\n* Determines if a de-serialized file is compatible with this class.\r\n* Included here as a reminder of its importance.\r\n*\/\r\nprivate static final long serialVersionUID = 7526471155622776147L;\r\n\r\n\/**\r\n* Verify that all fields of this object take permissible values\r\n*\r\n* @throws IllegalArgumentException\r\n* if any field takes an unpermitted value.\r\n*\/\r\nprivate void verifyUserDetails() {\r\n  validateAccountNumber(fAccountNumber);\r\n  verifyNameProperty(fFirstName);\r\n  verifyNameProperty(fLastName);\r\n  validateAccountOpenDate(fDateOpened);\r\n}\r\n\r\n\/**\r\n* Ensure names contain only letters, spaces, and apostrophes.\r\n*\r\n* @throws IllegalArgumentException\r\n* if field takes an unpermitted value.\r\n*\/\r\nprivate void verifyNameProperty(String aName) {\r\nboolean nameHasContent = (aName != null) &amp;&amp; (!aName.equals(&quot;&quot;));\r\n  if (!nameHasContent) {\r\n    throw new IllegalArgumentException(\r\n    &quot;Names must be non-null and non-empty.&quot;);\r\n  }\r\n\r\nStringCharacterIterator iterator = new StringCharacterIterator(aName);\r\nchar character = iterator.current();\r\n  while (character != StringCharacterIterator.DONE) {\r\n    boolean isValidChar = (Character.isLetter(character)\r\n    || Character.isSpaceChar(character) || character == ''');\r\n    if (isValidChar) {\r\n      \/\/ do nothing\r\n    } else {\r\n      String message = &quot;Names can contain only letters, spaces, and apostrophes.&quot;;\r\n      throw new IllegalArgumentException(message);\r\n    }\r\n    character = iterator.next();\r\n  }\r\n}\r\n\r\n\/**\r\n* AccountNumber must be non-negative.\r\n*\r\n* @throws IllegalArgumentException\r\n* if field takes an unpermitted value.\r\n*\/\r\nprivate void validateAccountNumber(int aAccountNumber) {\r\n  if (aAccountNumber &lt; 0) {\r\n    String message = &quot;Account Number must be greater than or equal to 0.&quot;;\r\n    throw new IllegalArgumentException(message);\r\n  }\r\n}\r\n\r\n\/**\r\n* DateOpened must be after 1970.\r\n*\r\n* @throws IllegalArgumentException\r\n* if field takes an unpermitted value.\r\n*\/\r\nprivate void validateAccountOpenDate(Date aDateOpened) {\r\n  if (aDateOpened.getTime() &lt; 0) {\r\n    throw new IllegalArgumentException(\r\n      &quot;Date Opened must be after 1970.&quot;);\r\n  }\r\n}\r\n\r\n\/**\r\n* Always treat deserialization as a full-blown constructor, by validating\r\n* the final state of the de-serialized object.\r\n*\/\r\nprivate void readObject(ObjectInputStream aInputStream)\r\nthrows ClassNotFoundException, IOException {\r\n  \/\/ always perform the default deserialization first\r\n  aInputStream.defaultReadObject();\r\n\r\n  \/\/ make defensive copy of the mutable Date field\r\n  fDateOpened = new Date(fDateOpened.getTime());\r\n\r\n  \/\/ ensure that object state has not been corrupted or tampered with\r\n  \/\/ malicious code\r\n  verifyUserDetails();\r\n}\r\n\r\n\/**\r\n* This is the default implementation of writeObject. Customise if\r\n* necessary.\r\n*\/\r\nprivate void writeObject(ObjectOutputStream aOutputStream)\r\nthrows IOException {\r\n  \/\/ perform the default serialization for all non-transient, non-static\r\n  \/\/ fields\r\n  aOutputStream.defaultWriteObject();\r\n}\r\n}\r\n<\/pre>\n<p>Lets see now how to do serialization and deserialization in Java.<\/p>\n<h2>Serialization and deserialization example<\/h2>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npackage serializationTest;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\npublic class TestUserDetails {\r\n  public static void main(String[] args) {\r\n    \/\/ Create new UserDetails object\r\n    UserDetails myDetails = new UserDetails(&quot;Lokesh&quot;, &quot;Gupta&quot;, 102825,\r\n    new Date(Calendar.getInstance().getTimeInMillis()));\r\n\r\n    \/\/ Serialization code\r\n    try {\r\n      FileOutputStream fileOut = new FileOutputStream(&quot;userDetails.ser&quot;);\r\n      ObjectOutputStream out = new ObjectOutputStream(fileOut);\r\n      out.writeObject(myDetails);\r\n      out.close();\r\n      fileOut.close();\r\n    } catch (IOException i) {\r\n      i.printStackTrace();\r\n    }\r\n\r\n    \/\/ deserialization code\r\n    @SuppressWarnings(&quot;unused&quot;)\r\n    UserDetails deserializedUserDetails = null;\r\n    try {\r\n      FileInputStream fileIn = new FileInputStream(&quot;userDetails.ser&quot;);\r\n      ObjectInputStream in = new ObjectInputStream(fileIn);\r\n      deserializedUserDetails = (UserDetails) in.readObject();\r\n      in.close();\r\n      fileIn.close();\r\n\r\n      \/\/ verify the object state\r\n      System.out.println(deserializedUserDetails.getFirstName());\r\n      System.out.println(deserializedUserDetails.getLastName());\r\n      System.out.println(deserializedUserDetails.getAccountNumber());\r\n      System.out.println(deserializedUserDetails.getDateOpened());\r\n    } catch (IOException ioe) {\r\n      ioe.printStackTrace();\r\n    } catch (ClassNotFoundException cnfe) {\r\n      cnfe.printStackTrace();\r\n    }\r\n  }\r\n}\r\nOutput:\r\n\r\nLokesh\r\nGupta\r\n102825\r\nWed Nov 21 15:06:34 GMT+05:30 2012\r\n\r\n<\/pre>\n<p>References:<\/p>\n<p><a title=\"serialization spec\" href=\"https:\/\/docs.oracle.com\/javase\/7\/docs\/platform\/serialization\/spec\/serialTOC.html\">http:\/\/docs.oracle.com\/javase\/7\/docs\/platform\/serialization\/spec\/serialTOC.html<\/a><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Java Serialization &#8211; Dos and don&#8217;ts for correct serialization and deserialization. Learn to use serialVersionUID, readObject and writeObject with example.<\/p>\n","protected":false},"author":2,"featured_media":4758,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[790],"tags":[3,43],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8.jpg",200,200,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8-150x150.jpg",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8.jpg",200,200,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8.jpg",200,200,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8.jpg",200,200,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8.jpg",200,200,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8.jpg",200,200,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2015\/06\/java-8.jpg",120,120,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":15,"uagb_excerpt":"Java Serialization - Dos and don'ts for correct serialization and deserialization. Learn to use serialVersionUID, readObject and writeObject with example.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/389"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=389"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/389\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/4758"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=389"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=389"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=389"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}