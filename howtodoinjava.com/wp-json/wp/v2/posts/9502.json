{"id":9502,"date":"2017-08-20T17:12:35","date_gmt":"2017-08-20T11:42:35","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=9502"},"modified":"2020-12-26T00:52:01","modified_gmt":"2020-12-25T19:22:01","slug":"java9-new-features-enhancements","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/","title":{"rendered":"Java 9 Features and Enhancements"},"content":{"rendered":"<p>Java 9 is bringing lots of new enhancements which are going to affect your programming style and habit, in big way. The biggest change is the modularization of Java. It&#8217;s another big change after <a href=\"https:\/\/howtodoinjava.com\/java8\/lambda-expressions\/\">Lambdas<\/a> in <a href=\"https:\/\/howtodoinjava.com\/java-8-tutorial\/\">Java 8<\/a>. In this article, I am listing down changes which will be part of JDK 9 release.<\/p>\n<pre><strong>What is new in Java 9<\/strong>\r\n\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#jpms\">Java platform module system<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#interface-private-methods\">Interface Private Methods<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#http2\">HTTP 2 Client<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#jshell\">JShell - REPL Tool<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#unified-logging\">Platform and JVM Logging<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#process-api\">Process API Updates<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#collections\">Collection API Updates<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#stream-api\">Stream API Improvements<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#multirelease-jars\">Multi-Release JAR Files<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#deprecated-tag\">@Deprecated Tag Changes<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#stack-walking\">Stack Walking<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#javadocs\">Java Docs Updates<\/a>\r\n<a href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/#misc\">Miscellaneous Other Features<\/a><\/pre>\n<p><a id=\"jpms\"><\/a><\/p>\n<h2>Java platform module system<\/h2>\n<p>JPMS (Java Platform Module System) is the core highlight of new Java 9 release. It is also known as <a href=\"http:\/\/openjdk.java.net\/projects\/jigsaw\/\" target=\"_blank\" rel=\"noopener noreferrer\">Project Jigshaw<\/a>. A module is new construct like we already have packages. An application, developed using new modular programming, can be seen as collection of interacting modules with a well-defined boundaries and dependencies between those modules.<\/p>\n<p>The JPMS consists of providing support for writing modular applications as well as modularizing the JDK source code as well. JDK 9 is coming with around 92 modules (changes are possible in GA release). Java 9 Module System has a <strong>\u201cjava.base\u201d<\/strong> Module. It\u2019s known as Base Module. It\u2019s an Independent module and does NOT dependent on any other modules. By default, all other modules are dependent on \u201cjava.base\u201d.<\/p>\n<p>In java modular programming-<\/p>\n<ol>\n<li>A module is typically just a jar file that has a <code>module-info.class<\/code> file at the root.<\/li>\n<li>To use a module, include the jar file into <code>modulepath<\/code> instead of the <code>classpath<\/code>. A modular jar file added to classpath is normal jar file and <code>module-info.class<\/code> file will be ignored.<\/li>\n<\/ol>\n<p>Typical <code>module-info.java<\/code> classes looks like this:<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nmodule helloworld {\r\n    exports com.howtodoinjava.demo;\r\n}\r\n \r\nmodule test {\r\n    requires helloworld;\r\n}\r\n<\/pre>\n<blockquote><p>Read More: <a href=\"https:\/\/howtodoinjava.com\/java9\/java-9-modules-tutorial\/\">Java 9 Modules Tutorial<\/a><\/p><\/blockquote>\n<p><a id=\"interface-private-methods\"><\/a><\/p>\n<h2>Interface Private Methods<\/h2>\n<p>Java 8 allowed you to write default methods in interfaces, and it was widely appreciated feature. So after this, interfaces only lack few things and only non-private methods was one of them. Java 9 onward, you are allowed to include private methods in interfaces.<\/p>\n<p>These private methods will improve code re-usability inside interfaces. Foe example, if two default methods needed to share code, a private interface method would allow them to do so, but without exposing that private method to it\u2019s implementing classes.<\/p>\n<p>Using private methods in interfaces have four rules :<\/p>\n<ol>\n<li>Private interface method cannot be abstract.<\/li>\n<li>Private method can be used only inside interface.<\/li>\n<li>Private static method can be used inside other static and non-static interface methods.<\/li>\n<li>Private non-static methods cannot be used inside private static methods.<\/li>\n<\/ol>\n<p>An example of using private methods in interfaces &#8211; <\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npublic interface CustomCalculator \r\n{\r\n    default int addEvenNumbers(int... nums) {\r\n        return add(n -&gt; n % 2 == 0, nums);\r\n    }\r\n \r\n    default int addOddNumbers(int... nums) {\r\n        return add(n -&gt; n % 2 != 0, nums);\r\n    }\r\n \r\n    private int add(IntPredicate predicate, int... nums) { \r\n        return IntStream.of(nums)\r\n                .filter(predicate)\r\n                .sum();\r\n    }\r\n}\r\n<\/pre>\n<blockquote><p><a href=\"https:\/\/howtodoinjava.com\/java9\/java9-private-interface-methods\/\">Java 9 &#8211; Private Methods in Interface<\/a><\/p><\/blockquote>\n<p><a id=\"http2\"><\/a><\/p>\n<h2>HTTP\/2 Client<\/h2>\n<p>HTTP\/1.1 client was released on 1997. A lot has changed since. So for Java 9 a new API been introduced that is cleaner and clearer to use and which also adds support for HTTP\/2. New API uses 3 major classes i.e. <code>HttpClient<\/code>, <code>HttpRequest<\/code> and <code>HttpResponse<\/code>.<\/p>\n<p>To make a request, it is as simple as getting your client, building a request and sending it as shown below.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nHttpClient httpClient = HttpClient.newHttpClient(); \r\nHttpRequest httpRequest = HttpRequest.newBuilder().uri(new URI(&quot;\/\/howtodoinjava.com\/&quot;)).GET().build(); \r\nHttpResponse&lt;String&gt; httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandler.asString()); \r\nSystem.out.println( httpResponse.body() ); \r\n<\/pre>\n<p>Above code looks much cleaner and readable. <\/p>\n<p>New API also support Async HTTP requests using <code>httpClient.sendAsync()<\/code> method. It returns <code>CompletableFuture<\/code> object which can be used to determine whether the request has been completed or not. It also  provide you access to the <code>HttpResponse<\/code> once request is completed. Best part is that if you desire you can even cancel the request before it completes. e.g.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nif(httpResponse.isDone()) {\r\n    System.out.println(httpResponse.get().statusCode());\r\n    System.out.println(httpResponse.get().body());\r\n} else {\r\n    httpResponse.cancel(true);\r\n}\r\n<\/pre>\n<p><a id=\"jshell\"><\/a><\/p>\n<h2>JShell &#8211; REPL Tool<\/h2>\n<p><strong>JShell<\/strong> is new command line interactive tool shipped with <strong>JDK 9<\/strong> distribution [<a href=\"http:\/\/openjdk.java.net\/jeps\/222\" target=\"_blank\" rel=\"noopener noreferrer\">JEP 222<\/a>] to evaluate declarations, statements and expressions written in Java. JShell allows us to execute Java code snippets and get immediate results without having to create a solution or project.<\/p>\n<p>Jshell is much like what we have command window in linux OS. Difference is that JShell is Java specific. It has lots of other capabilities, other than executing simple code snippets. e.g.<\/p>\n<ul>\n<li>Launch inbuilt code editor in separate window<\/li>\n<li>Launch code editor of your choice in separate window<\/li>\n<li>Execute code when Save operation happen in these external editors<\/li>\n<li>Load pre-written classes from file system<\/li>\n<\/ul>\n<blockquote><p><a href=\"https:\/\/howtodoinjava.com\/java9\/complete-jshell-tutorial-examples\/\">Java 9 JShell Tutorial<\/a><\/p><\/blockquote>\n<p><a id=\"unified-logging\"><\/a><\/p>\n<h2>Platform and JVM Logging<\/h2>\n<p>JDK 9 has improved logging in platform classes (JDK classes) and JVM components, through a new loging API. It lets you specify a logging framework of your choice (e.g. <a href=\"https:\/\/howtodoinjava.com\/log4j2\/\">Log4J2<\/a>) as logging backend for logging messages from JDK classes. There are few things you should know about this API:<\/p>\n<ol>\n<li>The API is meant to be used by the classes in the JDK, not by application classes.<\/li>\n<li>For your application code, you will continue using other logging APIs as before.<\/li>\n<li>The API does not let you configure the logger programmatically.<\/li>\n<\/ol>\n<p>The API consists of the following:<\/p>\n<ul>\n<li>A service interface, <code>java.lang.System.LoggerFinder<\/code>, which is an abstract static class<\/li>\n<li>An interface, <code>java.lang.System.Logger<\/code>, which provides the logging API<\/li>\n<li>An overloaded method <code>getLogger()<\/code> in the <code>java.lang.System<\/code> class, which returns a logger instance.<\/li>\n<\/ul>\n<p>JDK 9 also added a new command-line option, <code>-Xlog<\/code> , that gives you a single point of access to all messages logged from all classes of the JVM. The following is the syntax to use the <code>-Xlog<\/code> option:<\/p>\n<pre>-Xlog[:<contents>][:[<output>][:[<decorators>][:<output-options>]]]<\/pre>\n<p>All options are optional. If a preceding part in <code>-Xlog<\/code> is missing, you must use a colon for that part. For example, <code>-Xlog::stderr<\/code> indicates that all parts are defaulted, output wich is set as <code>stderr<\/code>.<\/p>\n<p>I will cover this topic in deep, in a separate post.<\/p>\n<p><a id=\"process-api\"><\/a><\/p>\n<h2>Process API Updates<\/h2>\n<p> Prior to Java 5, the only way to spawn a new process was to use the <code>Runtime.getRuntime().exec()<\/code> method. Then in Java 5, <code>ProcessBuilder<\/code> API was introduced which supported a cleaner way of spawning new processes. Now Java 9 is adding a new way of getting information about current and any spawned process.<\/p>\n<p> To get information of any process, now you should use <code>java.lang.ProcessHandle.Info<\/code> interface. This interface can be useful in getting lots of information e.g.<\/p>\n<ul>\n<li>the command used to start the process<\/li>\n<li>the arguments of the command<\/li>\n<li>time instant when the process was started<\/li>\n<li>total time spent by it and the user who created it<\/li>\n<\/ul>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nProcessHandle processHandle = ProcessHandle.current();\r\nProcessHandle.Info processInfo = processHandle.info();\r\n\r\nSystem.out.println( processHandle.getPid() );\r\nSystem.out.println( processInfo.arguments().isPresent() );\r\nSystem.out.println( pprocessInfo.command().isPresent() );\r\nSystem.out.println( processInfo.command().get().contains(&quot;java&quot;) );\r\nSystem.out.println( processInfo.startInstant().isPresent() );\r\n<\/pre>\n<p>To get the information of a new spawned process, use <code>process.toHandle()<\/code> method to get <code>ProcessHandle<\/code> instance. Rest all of things are as above.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nString javaPrompt = ProcessUtils.getJavaCmd().getAbsolutePath();\r\nProcessBuilder processBuilder = new ProcessBuilder(javaPrompt, &quot;-version&quot;);\r\nProcess process = processBuilder.inheritIO().start();\r\nProcessHandle processHandle = process.toHandle();\r\n<\/pre>\n<p>Also use <code>ProcessHandle.allProcesses()<\/code> to get a stream of ProcessHandle of all processes available in system.<\/p>\n<p>To get the list of all child processes (direct as well as n-level deep), use <code>children()<\/code> and <code>descendants()<\/code> method.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nStream&lt;ProcessHandle&gt; children    = ProcessHandle.current().children();\r\nStream&lt;ProcessHandle&gt; descendants = ProcessHandle.current().descendants();\r\n<\/pre>\n<p><a id=\"collections\"><\/a><\/p>\n<h2>Collection API Updates<\/h2>\n<p>Since Java 9, you can create immutable collections such as immutable list, immutable set and immutable map using new factory methods. e.g.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nimport java.util.List;\r\n \r\npublic class ImmutableCollections \r\n{\r\n    public static void main(String[] args) \r\n    {\r\n        List&lt;String&gt; namesList = List.of(&quot;Lokesh&quot;, &quot;Amit&quot;, &quot;John&quot;);\r\n\r\n        Set&lt;String&gt; namesSet = Set.of(&quot;Lokesh&quot;, &quot;Amit&quot;, &quot;John&quot;);\r\n\r\n        Map&lt;String, String&gt; namesMap = Map.ofEntries(\r\n\t\t\t\t\t                Map.entry(&quot;1&quot;, &quot;Lokesh&quot;),\r\n\t\t\t\t\t                Map.entry(&quot;2&quot;, &quot;Amit&quot;),\r\n\t\t\t\t\t                Map.entry(&quot;3&quot;, &quot;Brian&quot;));\r\n    }\r\n}\r\n<\/pre>\n<blockquote><p><a href=\"https:\/\/howtodoinjava.com\/java9\/create-immutable-collections-factory-methods\/\">Java 9 Collections API Improvements<\/a><\/p><\/blockquote>\n<p><a id=\"stream-api\"><\/a><\/p>\n<h2>Stream API Improvements<\/h2>\n<p>Java 9 has introduced two new methods to interact with Streams i.e. <code>takeWhile<\/code> \/ <code>dropWhile<\/code> methods. Additionally, it has added two overloaded methods i.e. <code>ofNullable<\/code> and <code>iterate<\/code> methods.<\/p>\n<p>The new methods <code>takeWhile<\/code> and <code>dropWhile<\/code> allow you to get portions of a stream based on a predicate. <\/p>\n<ol>\n<li>On an ordered stream, <code>takeWhile<\/code> returns the \u201clongest prefix\u201d of elements taken from the stream that match the given predicate, starting at the beginning of the stream. <code>dropWhile<\/code> returns the remaining items which were not matched by <code>takeWhile<\/code>.<\/li>\n<li>On an un-ordered stream, <code>takeWhile<\/code> returns a subset of the stream\u2019s elements that match the given predicate (but not all), starting at the beginning of the stream. <code>dropWhile<\/code> returns remaining stream elements after dropping subset of elements that match the given predicate.<\/li>\n<\/ol>\n<p>Similarily, till Java 8, you cannot have <code>null<\/code> value in a stream. It would have caused <code>NullPointerException<\/code>. Since Java 9, <code>Stream.ofNullable()<\/code> method lets you create a single-element stream which wraps a value if not <code>null<\/code>, or is an empty stream otherwise. Technically, <code>Stream.ofNullable()<\/code> is very similar to null condition check, when talking in context of stream API.<\/p>\n<blockquote><p><a href=\"https:\/\/howtodoinjava.com\/java9\/stream-api-improvements\/\">Java 9 Stream API Improvements<\/a><\/p><\/blockquote>\n<p><a id=\"multirelease-jars\"><\/a><\/p>\n<h2>Multi-Release JAR Files<\/h2>\n<p>This enhancement is related to how you package application classes in jar files. Previously, you had to package all classes into a jar file and drop in the classpath of the another application, which wish to use it.<\/p>\n<p>Using multi-release feature, now a jar can contains different versions of a class &#8211; compatible to different JDK releases. The information regarding different versions of a class, and in which JDK version which class shall be picked up by class loaded, is stored in <code>MANIFEST.MF<\/code> file. In this case, <code>MANIFEST.MF<\/code> file includes the entry <code>Multi-Release: true<\/code> in its main section. <\/p>\n<p>Furthermore, META-INF contains a versions subdirectory whose integer-named subdirectories &#8212; starting with 9 (for Java 9) &#8212; store version-specific class and resource files. e.g.<\/p>\n<pre>JAR content root\r\n  A.class\r\n  B.class\r\n  C.class\r\n  D.class\r\n  META-INF\r\n     MANIFEST.MF\r\n     versions\r\n        9\r\n           A.class\r\n           B.class<\/pre>\n<p>Let&#8217;s assume that in JDK 10, <code>A.class<\/code> is updated to leverage some Java 10 features, then this Jar file can be updated like this:<\/p>\n<pre>JAR content root\r\n  A.class\r\n  B.class\r\n  C.class\r\n  D.class\r\n  META-INF\r\n     MANIFEST.MF\r\n     versions\r\n        9\r\n           A.class\r\n           B.class\r\n        10\r\n           A.class<\/pre>\n<p>It looks really promising step to solve the dependency hell often seen in large application where jars with different versions are not compatible with each other. This feature can be a big help to tackle those scenarios.<\/p>\n<p><a id=\"deprecated-tag\"><\/a><\/p>\n<h2>@Deprecated Tag Changes<\/h2>\n<p>From Java 9, <a href=\"https:\/\/docs.oracle.com\/javase\/9\/docs\/api\/java\/lang\/Deprecated.html\">@Deprecated<\/a> annotation will have two attributes i.e. <code>forRemoval<\/code> and <code>since<\/code>.<\/p>\n<ol>\n<li><em>forRemoval<\/em> &#8211; Indicates whether the annotated element is subject to removal in a future version.<\/li>\n<li><em>since<\/em>  &#8211; It returns the version in which the annotated element became deprecated.<\/li>\n<\/ol>\n<p>It is strongly recommended that the reason for deprecating a program element be explained in the documentation, using the @deprecated javadoc tag. The documentation should also suggest and link to a recommended replacement API, if applicable. A replacement API often has subtly different semantics, so such issues should be discussed as well.<\/p>\n<p><a id=\"stack-walking\"><\/a><\/p>\n<h2>Stack Walking<\/h2>\n<p>The stack is a Last-In-First-Out (LIFO) data structure. At JVM level, a stack stores frames. A new frame is created and pushed to the top of the stack each time a method is invoked. A frame is destroyed (popped out of stack) when the method invocation completes. Each frame on a stack contains its own array of local variables, as well as its own operand stack, return value, and reference to the runtime constant pool of the current method\u2019s class. <\/p>\n<p>In a given thread, only one frame is active at any point. The active frame is known as the current frame and its method is known as the current method . [<a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-2.html#jvms-2.5.2\">Read More<\/a>]<\/p>\n<p>Till Java 8, <code>StackTraceElement<\/code> represents a stack frame. To get complete stack, you had to use <code>Thread.getStackTrace()<\/code> and <code>Throwable.getStackTrace()<\/code>. It returned an array of <code>StackTraceElement<\/code> which you can iterate to get required information.<\/p>\n<p>In Java 9, a new class <code>StackWalker<\/code> has been introduced. The class provides easy and efficient stack walking using sequential stream of stack frames for the current thread. The <code>StackWalker<\/code> class is very efficient because it evaluates the stack frames lazily. <\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n\/\/ Prints the details of all stack frames of the current thread\r\n\r\nStackWalker.getInstance().forEach(System.out::println);\r\n<\/pre>\n<p>There are other lots of things you can do with this stream, which we will cover in some other decdicated post.<\/p>\n<p><a id=\"javadocs\"><\/a><\/p>\n<h2>Java Docs Updates<\/h2>\n<p>Java 9 enhances the <code>javadoc<\/code> tool to generate HTML5 markup. It currently generates pages in HTML 4.01. <\/p>\n<p>In order to generate a HTML5 Javadoc, the parameter <code>-html5<\/code> needs to go in the command line arguments. To generate the document on the command line, you would run:<\/p>\n<pre>javadoc [options] [packagenames] [sourcefiles] [@files]<\/pre>\n<p>Using HTML5 confers the benefits of the easier HTML5 structure. It also implements the <a href=\"https:\/\/w3c.github.io\/wai-website\/standards-guidelines\/aria\/\">WAI-ARIA standard<\/a> for accessibility. This aims to make it easier for people with physical or visual impairments to access javadocs pages using tools such as screen readers. <\/p>\n<p><a href=\"http:\/\/openjdk.java.net\/jeps\/225\">JEP 225<\/a> gives the ability to search a javadoc for program elements and tagged words and phrases.<\/p>\n<p>The following will be indexed and searchable:<\/p>\n<ul>\n<li>Declared names of modules<\/li>\n<li>Packages<\/li>\n<li>Types and members<\/li>\n<li>The simple name of method parameter types<\/li>\n<\/ul>\n<p>This is implemented client side, with a new <code>search.js<\/code> Javascript file, along with indexes generated when the javadoc is generated. A search box is available on the generated HTML5 API pages.<\/p>\n<p>Please note that Search option will be added by default, but can be turned off with the argument: <code>-noindex<\/code>.<\/p>\n<p><a id=\"misc\"><\/a><\/p>\n<h2>Miscellaneous Other Features<\/h2>\n<p>There are other features as well in Java 9, which I am listing down here for quick reference. We will discuss all these features in coming posts.<\/p>\n<ul>\n<li>Reactive Streams API<\/li>\n<li>GC (Garbage Collector) Improvements<\/li>\n<li>Filter Incoming Serialization Data<\/li>\n<li>Deprecate the Applet API<\/li>\n<li>Indify String Concatenation<\/li>\n<li>Enhanced Method Handles<\/li>\n<li>Compact Strings<\/li>\n<li>Parser API for Nashorn<\/li>\n<\/ul>\n<div class=\"noticeboxesde bluenoticebox\">Java 9 is scheduled to release on 2017\/09\/21. For latest changes, follow this <a href=\"http:\/\/openjdk.java.net\/projects\/jdk9\/\" target=\"_blank\" rel=\"noopener noreferrer\">link<\/a>.<\/div>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Java 9 is bringing lots of new enhancements which are going to affect your programming style and habit, in big way. The biggest change is the modularization of Java. It&#8217;s another big change after Lambdas in Java 8. In this article, I am listing down changes which will be part of JDK 9 release. What &#8230; <a title=\"Java 9 Features and Enhancements\" class=\"read-more\" href=\"https:\/\/howtodoinjava.com\/java9\/java9-new-features-enhancements\/\" aria-label=\"More on Java 9 Features and Enhancements\">Read more<\/a><\/p>\n","protected":false},"author":2,"featured_media":9504,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[1063],"tags":[1435],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",580,300,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",150,78,false],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",300,155,false],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",580,300,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",580,300,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",580,300,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",580,300,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/08\/java9.png",120,62,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":1,"uagb_excerpt":"Java 9 is bringing lots of new enhancements which are going to affect your programming style and habit, in big way. The biggest change is the modularization of Java. It&#8217;s another big change after Lambdas in Java 8. In this article, I am listing down changes which will be part of JDK 9 release. What&hellip;","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/9502"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=9502"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/9502\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/9504"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=9502"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=9502"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=9502"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}