{"id":8116,"date":"2017-05-22T15:09:13","date_gmt":"2017-05-22T09:39:13","guid":{"rendered":"http:\/\/howtodoinjava.com\/?p=8116"},"modified":"2022-01-25T14:47:11","modified_gmt":"2022-01-25T09:17:11","slug":"rxjava-tutorial","status":"publish","type":"post","link":"https:\/\/howtodoinjava.com\/java\/library\/rxjava-tutorial\/","title":{"rendered":"RxJava Tutorial"},"content":{"rendered":"<p><a href=\"http:\/\/reactivex.io\/\" target=\"_default\" rel=\"noopener noreferrer\">RxJava 2.0<\/a> is open source extension to java for asynchronous programming by NetFlix. It is much closer to functional programming as seen in <a href=\"https:\/\/howtodoinjava.com\/java8\/lambda-expressions\/\">java 8 lambda expressions<\/a>. The basic building blocks of reactive code are <em>Observables<\/em> and <em>Subscribers<\/em>. An <code>Observable<\/code> emits items; a <code>Subscriber<\/code> consumes those items.<\/p>\n<p>RxJava looks like <a href=\"https:\/\/howtodoinjava.com\/design-patterns\/behavioral\/observer-design-pattern\/\" rel=\"noopener noreferrer\" target=\"_blank\">Observer design pattern<\/a> too &#8211; but with a difference &#8211; Observables often don&#8217;t start emitting items until someone explicitly subscribes to them. <\/p>\n<pre>Table of Contents\r\n\r\n<a href=\"#what-is-rxjava\">1. What is RxJava and Reactive Programming<\/a>\r\n<a href=\"#dependency\">2. RxJava 2 Dependency<\/a>\r\n<a href=\"#transform\">3. Transformation<\/a>\r\n<a href=\"#summary\">4. Conclusion<\/a><\/pre>\n<p><a id=\"what-is-rxjava\"><\/a><\/p>\n<h2>1. What is RxJava and Reactive Programming<\/h2>\n<p><strong>Reactive programming<\/strong> is a general programming term that is focused on reacting to changes, such as data values or events. A callback is an approach to reactive programming done imperatively.<\/p>\n<p>For example, if you have one source of data (producer) and one target for data (consumer); then after connecting the consumer to subscriber &#8211; reactive programming framework is responsible for pushing the data, generated by the producer, to the consumer. Please note that an observable can have any number of subscribers.<\/p>\n<p>Let&#8217;s look at a very basic <strong>RxJava hello world example<\/strong>.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\npackage com.howtodoinjava.app;\r\n\r\nimport io.reactivex.Observable;\r\nimport io.reactivex.functions.Consumer;\r\n\r\npublic class RxJava2Example \r\n{\r\n      public static void main(String[] args) \r\n      {     \r\n            \/\/producer\r\n            Observable&lt;String&gt; observable = Observable.just(&quot;how&quot;, &quot;to&quot;, &quot;do&quot;, &quot;in&quot;, &quot;java&quot;);\r\n\r\n            \/\/consumer\r\n            Consumer&lt;? super String&gt; consumer = System.out::println;\r\n\r\n            \/\/Attaching producer to consumer\r\n            observable.subscribe(consumer);\r\n      }\r\n}\r\n<\/pre>\n<p>In above example, <code>\"how\", \"to\", \"do\", \"in\", \"java\"<\/code> can be considered as stream of events. An <code>observable<\/code> is created for these events. Then we create a <code>consumer<\/code> which can act on these words &#8211; in this case it is just printing them out to console. This consumer is nothing but the <code>subscriber<\/code>.<\/p>\n<p>Lastly, we connect the subscriber to consumer using <code>subscribe()<\/code>. As soon as, we connect both, words\/events start flowing and subscriber start printing them in console.<\/p>\n<p>Internally in code, when a new word is emitted from the observable, the <code>onNext()<\/code> method is called on each subscriber. When the observable finishes all of words either successful or with an error, the <code>onComplete()<\/code> or the <code>onError()<\/code> method is called on the subscriber.<\/p>\n<p><a id=\"dependency\"><\/a><\/p>\n<h2>2. RxJava 2 Dependency<\/h2>\n<p>To include RxJava 2.0 into your project runtime, you may choose between given maven config, gradle config or jar file into classpath.<\/p>\n<h4>2.1. RxJava 2.0 Maven Dependency<\/h4>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\n&lt;!-- https:\/\/mvnrepository.com\/artifact\/io.reactivex.rxjava2\/rxjava --&gt;\r\n&lt;dependency&gt;\r\n      &lt;groupId&gt;io.reactivex.rxjava2&lt;\/groupId&gt;\r\n      &lt;artifactId&gt;rxjava&lt;\/artifactId&gt;\r\n      &lt;version&gt;2.1.0&lt;\/version&gt;\r\n&lt;\/dependency&gt;\r\n<\/pre>\n<h4>2.2. RxJava 2.0 Gradle Dependency<\/h4>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\ncompile group: 'io.reactivex.rxjava2', name: 'rxjava', version: '2.1.0'\r\n<\/pre>\n<h4>2.3. RxJava 2.0 Jar Dependency<\/h4>\n<p><a href=\"http:\/\/central.maven.org\/maven2\/io\/reactivex\/rxjava2\/rxjava\/2.1.0\/rxjava-2.1.0.jar\" target=\"_default\" rel=\"noopener noreferrer\">Download RxJava 2.0 Jar file link<\/a>.<\/p>\n<p><a id=\"transform\"><\/a><\/p>\n<h2>3. Transformation in RxJava<\/h2>\n<p>In RxJava, the event type which subscriber receive from observable and event type which subscriber emits, do not need to be same. They can be different in data it contain, the data types or any other major difference between received and emitted event. <\/p>\n<p>This is necessary to provide support for intermediate <em>transformation of events<\/em> between the source and target, so that both work the way they designed for and still they are compatible. It&#8217;s much like <a href=\"\/\/howtodoinjava.com\/2014\/05\/10\/adapter-design-pattern-in-java\/\">adapter design pattern<\/a>.<\/p>\n<p>Let&#8217;s take an example. In our hello world example, we want to print the words in UPPERCASE. It is a simple transformation, but you will get the concept.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nObservable&lt;String&gt; observable = Observable.just(&quot;how&quot;, &quot;to&quot;, &quot;do&quot;, &quot;in&quot;, &quot;java&quot;);\r\nConsumer&lt;? super String&gt; consumer = System.out::println;\r\n\r\n\/\/Transformation using map() method\r\nobservable.map(w -&gt; w.toUpperCase()).subscribe(consumer);\r\n<\/pre>\n<p>In above example, we have added one intermediate method <code>map()<\/code> before subscribing the observable. So every word first goes through <code>map()<\/code> method and then goes to subscriber for further handling. It is called transformation.<\/p>\n<p>As mentioned before, you can change the data type of the event as well in transformation process. e.g.<\/p>\n<pre class=\"brush: java; title: ; notranslate\" title=\"\">\r\nObservable&lt;String&gt; observable = Observable.just(&quot;how&quot;, &quot;to&quot;, &quot;do&quot;, &quot;in&quot;, &quot;java&quot;);\r\nConsumer&lt;? super Integer&gt; consumer = System.out::println;\r\n\r\nobservable.map(w -&gt; w.toUpperCase().hashCode()).subscribe(consumer); \r\n<\/pre>\n<p>In this program, we are iterating over words and then in transformation we get the hashcode of the word and pass it to subscriber, which print the hashcode in console. So, here we connect the observable, which emits string, and subscriber, which accept integer.<\/p>\n<p><a id=\"summary\"><\/a><\/p>\n<h2>4. Conclusion<\/h2>\n<p>The way observable and subscriber are connected loosely, it brings great advantage to developers. They don&#8217;t need to think about whole concurrency paradigm, which is already a daunting task for many of us. You just connect the producer and subscriber &#8211; and everything just works &#8211; flawlessly.<\/p>\n<p>Also, you don&#8217;t need to think about both  observable and subscriber at same time. You can develop them independently with their best design choices, and then connect them using transformation concept. Great !!<\/p>\n<p>This <strong>RxJava Tutorial<\/strong> was more of <strong>introduction to RxJava<\/strong>. I will cover it&#8217;s important concepts related to <strong>reactive programming tutorial<\/strong> in more depth in coming <strong>rxjava tutorials for beginners<\/strong>.<\/p>\n<p>Happy Learning !!<\/p>\n","protected":false},"excerpt":{"rendered":"<p>RxJava 2.0 is open source extension to java for asynchronous programming by NetFlix. It is much closer to functional programming as seen in java 8 lambda expressions. The basic building blocks of reactive code are Observables and Subscribers. An Observable emits items; a Subscriber consumes those items.<\/p>\n","protected":false},"author":2,"featured_media":8117,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[2],"tags":[1514,1229],"uagb_featured_image_src":{"full":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo.png",400,400,false],"thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo-150x150.png",150,150,true],"medium":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo-300x300.png",300,300,true],"medium_large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo.png",400,400,false],"large":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo.png",400,400,false],"1536x1536":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo.png",400,400,false],"2048x2048":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo.png",400,400,false],"yarpp-thumbnail":["https:\/\/howtodoinjava.com\/wp-content\/uploads\/2017\/05\/RxJava-Logo.png",120,120,false]},"uagb_author_info":{"display_name":"Lokesh Gupta","author_link":"https:\/\/howtodoinjava.com\/author\/lokeshgupta1981\/"},"uagb_comment_info":0,"uagb_excerpt":"RxJava 2.0 is open source extension to java for asynchronous programming by NetFlix. It is much closer to functional programming as seen in java 8 lambda expressions. The basic building blocks of reactive code are Observables and Subscribers. An Observable emits items; a Subscriber consumes those items.","_links":{"self":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/8116"}],"collection":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/comments?post=8116"}],"version-history":[{"count":0,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/posts\/8116\/revisions"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media\/8117"}],"wp:attachment":[{"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/media?parent=8116"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/categories?post=8116"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/howtodoinjava.com\/wp-json\/wp\/v2\/tags?post=8116"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}